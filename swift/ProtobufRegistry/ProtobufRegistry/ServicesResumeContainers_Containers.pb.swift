// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation
public extension Services.Resume{ public struct Containers { }}

public func == (lhs: Services.Resume.Containers.ApproximateDateV1, rhs: Services.Resume.Containers.ApproximateDateV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasYear == rhs.hasYear) && (!lhs.hasYear || lhs.year == rhs.year)
  fieldCheck = fieldCheck && (lhs.hasMonth == rhs.hasMonth) && (!lhs.hasMonth || lhs.month == rhs.month)
  fieldCheck = fieldCheck && (lhs.hasDay == rhs.hasDay) && (!lhs.hasDay || lhs.day == rhs.day)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Services.Resume.Containers.ResumeV1, rhs: Services.Resume.Containers.ResumeV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
  fieldCheck = fieldCheck && (lhs.educations == rhs.educations)
  fieldCheck = fieldCheck && (lhs.positions == rhs.positions)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Services.Resume.Containers.EducationV1, rhs: Services.Resume.Containers.EducationV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasSchoolName == rhs.hasSchoolName) && (!lhs.hasSchoolName || lhs.schoolName == rhs.schoolName)
  fieldCheck = fieldCheck && (lhs.hasStartDate == rhs.hasStartDate) && (!lhs.hasStartDate || lhs.startDate == rhs.startDate)
  fieldCheck = fieldCheck && (lhs.hasEndDate == rhs.hasEndDate) && (!lhs.hasEndDate || lhs.endDate == rhs.endDate)
  fieldCheck = fieldCheck && (lhs.hasNotes == rhs.hasNotes) && (!lhs.hasNotes || lhs.notes == rhs.notes)
  fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
  fieldCheck = fieldCheck && (lhs.hasActivities == rhs.hasActivities) && (!lhs.hasActivities || lhs.activities == rhs.activities)
  fieldCheck = fieldCheck && (lhs.hasFieldOfStudy == rhs.hasFieldOfStudy) && (!lhs.hasFieldOfStudy || lhs.fieldOfStudy == rhs.fieldOfStudy)
  fieldCheck = fieldCheck && (lhs.hasDegree == rhs.hasDegree) && (!lhs.hasDegree || lhs.degree == rhs.degree)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Services.Resume.Containers.PositionV1, rhs: Services.Resume.Containers.PositionV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasTitle == rhs.hasTitle) && (!lhs.hasTitle || lhs.title == rhs.title)
  fieldCheck = fieldCheck && (lhs.hasStartDate == rhs.hasStartDate) && (!lhs.hasStartDate || lhs.startDate == rhs.startDate)
  fieldCheck = fieldCheck && (lhs.hasEndDate == rhs.hasEndDate) && (!lhs.hasEndDate || lhs.endDate == rhs.endDate)
  fieldCheck = fieldCheck && (lhs.hasSummary == rhs.hasSummary) && (!lhs.hasSummary || lhs.summary == rhs.summary)
  fieldCheck = fieldCheck && (lhs.hasCompany == rhs.hasCompany) && (!lhs.hasCompany || lhs.company == rhs.company)
  fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
  fieldCheck = fieldCheck && (lhs.hasIsCurrent == rhs.hasIsCurrent) && (!lhs.hasIsCurrent || lhs.isCurrent == rhs.isCurrent)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Services.Resume.Containers.CompanyV1, rhs: Services.Resume.Containers.CompanyV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
  fieldCheck = fieldCheck && (lhs.hasLinkedinId == rhs.hasLinkedinId) && (!lhs.hasLinkedinId || lhs.linkedinId == rhs.linkedinId)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public extension Services.Resume.Containers {
  public struct ContainersRoot {
    public static var sharedInstance : ContainersRoot {
     struct Static {
         static let instance : ContainersRoot = ContainersRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }

  final public class ApproximateDateV1 : GeneratedMessage, GeneratedMessageProtocol {
    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           case "year": return year
           case "month": return month
           case "day": return day
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasYear:Bool = false
    public private(set) var year:UInt32 = UInt32(0)

    public private(set) var hasMonth:Bool = false
    public private(set) var month:UInt32 = UInt32(0)

    public private(set) var hasDay:Bool = false
    public private(set) var day:UInt32 = UInt32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      if hasYear {
        output.writeUInt32(2, value:year)
      }
      if hasMonth {
        output.writeUInt32(3, value:month)
      }
      if hasDay {
        output.writeUInt32(4, value:day)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasYear {
        serialize_size += year.computeUInt32Size(2)
      }
      if hasMonth {
        serialize_size += month.computeUInt32Size(3)
      }
      if hasDay {
        serialize_size += day.computeUInt32Size(4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Services.Resume.Containers.ApproximateDateV1 {
      return Services.Resume.Containers.ApproximateDateV1.builder().mergeFromData(data, extensionRegistry:Services.Resume.Containers.ContainersRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.ApproximateDateV1 {
      return Services.Resume.Containers.ApproximateDateV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Services.Resume.Containers.ApproximateDateV1 {
      return Services.Resume.Containers.ApproximateDateV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Services.Resume.Containers.ApproximateDateV1 {
      return Services.Resume.Containers.ApproximateDateV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Services.Resume.Containers.ApproximateDateV1 {
      return Services.Resume.Containers.ApproximateDateV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.ApproximateDateV1 {
      return Services.Resume.Containers.ApproximateDateV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Services.Resume.Containers.ApproximateDateV1Builder {
      return Services.Resume.Containers.ApproximateDateV1.classBuilder() as! Services.Resume.Containers.ApproximateDateV1Builder
    }
    public func builder() -> Services.Resume.Containers.ApproximateDateV1Builder {
      return classBuilder() as! Services.Resume.Containers.ApproximateDateV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Services.Resume.Containers.ApproximateDateV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Services.Resume.Containers.ApproximateDateV1.builder()
    }
    public func toBuilder() -> Services.Resume.Containers.ApproximateDateV1Builder {
      return Services.Resume.Containers.ApproximateDateV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Services.Resume.Containers.ApproximateDateV1) -> Services.Resume.Containers.ApproximateDateV1Builder {
      return Services.Resume.Containers.ApproximateDateV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasYear {
        output += "\(indent) year: \(year) \n"
      }
      if hasMonth {
        output += "\(indent) month: \(month) \n"
      }
      if hasDay {
        output += "\(indent) day: \(day) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasYear {
               hashCode = (hashCode &* 31) &+ year.hashValue
            }
            if hasMonth {
               hashCode = (hashCode &* 31) &+ month.hashValue
            }
            if hasDay {
               hashCode = (hashCode &* 31) &+ day.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Services.Resume.Containers.ApproximateDateV1"
    }
    override public func className() -> String {
        return "Services.Resume.Containers.ApproximateDateV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Services.Resume.Containers.ApproximateDateV1.self
    }
    //Meta information declaration end

  }

  final public class ApproximateDateV1Builder : GeneratedMessageBuilder {
    private var builderResult:Services.Resume.Containers.ApproximateDateV1

    required override public init () {
       builderResult = Services.Resume.Containers.ApproximateDateV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Services.Resume.Containers.ApproximateDateV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Services.Resume.Containers.ApproximateDateV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    public var hasYear:Bool {
         get {
              return builderResult.hasYear
         }
    }
    public var year:UInt32 {
         get {
              return builderResult.year
         }
         set (value) {
             builderResult.hasYear = true
             builderResult.year = value
         }
    }
    public func setYear(value:UInt32)-> Services.Resume.Containers.ApproximateDateV1Builder {
      self.year = value
      return self
    }
    public func clearYear() -> Services.Resume.Containers.ApproximateDateV1Builder{
         builderResult.hasYear = false
         builderResult.year = UInt32(0)
         return self
    }
    public var hasMonth:Bool {
         get {
              return builderResult.hasMonth
         }
    }
    public var month:UInt32 {
         get {
              return builderResult.month
         }
         set (value) {
             builderResult.hasMonth = true
             builderResult.month = value
         }
    }
    public func setMonth(value:UInt32)-> Services.Resume.Containers.ApproximateDateV1Builder {
      self.month = value
      return self
    }
    public func clearMonth() -> Services.Resume.Containers.ApproximateDateV1Builder{
         builderResult.hasMonth = false
         builderResult.month = UInt32(0)
         return self
    }
    public var hasDay:Bool {
         get {
              return builderResult.hasDay
         }
    }
    public var day:UInt32 {
         get {
              return builderResult.day
         }
         set (value) {
             builderResult.hasDay = true
             builderResult.day = value
         }
    }
    public func setDay(value:UInt32)-> Services.Resume.Containers.ApproximateDateV1Builder {
      self.day = value
      return self
    }
    public func clearDay() -> Services.Resume.Containers.ApproximateDateV1Builder{
         builderResult.hasDay = false
         builderResult.day = UInt32(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Services.Resume.Containers.ApproximateDateV1Builder {
      builderResult = Services.Resume.Containers.ApproximateDateV1()
      return self
    }
    public override func clone() -> Services.Resume.Containers.ApproximateDateV1Builder {
      return Services.Resume.Containers.ApproximateDateV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Services.Resume.Containers.ApproximateDateV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Services.Resume.Containers.ApproximateDateV1 {
      var returnMe:Services.Resume.Containers.ApproximateDateV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Services.Resume.Containers.ApproximateDateV1) -> Services.Resume.Containers.ApproximateDateV1Builder {
      if (other == Services.Resume.Containers.ApproximateDateV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      if other.hasYear {
           year = other.year
      }
      if other.hasMonth {
           month = other.month
      }
      if other.hasDay {
           day = other.day
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Services.Resume.Containers.ApproximateDateV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.ApproximateDateV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        case 16 :
          year = input.readUInt32()

        case 24 :
          month = input.readUInt32()

        case 32 :
          day = input.readUInt32()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class ResumeV1 : GeneratedMessage, GeneratedMessageProtocol {
    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           case "userId": return userId
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasUserId:Bool = false
    public private(set) var userId:String = ""

    public private(set) var educations:Array<Services.Resume.Containers.EducationV1>  = Array<Services.Resume.Containers.EducationV1>()
    public private(set) var positions:Array<Services.Resume.Containers.PositionV1>  = Array<Services.Resume.Containers.PositionV1>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      if hasUserId {
        output.writeString(2, value:userId)
      }
      for oneElementeducations in educations {
          output.writeMessage(3, value:oneElementeducations)
      }
      for oneElementpositions in positions {
          output.writeMessage(4, value:oneElementpositions)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasUserId {
        serialize_size += userId.computeStringSize(2)
      }
      for oneElementeducations in educations {
          serialize_size += oneElementeducations.computeMessageSize(3)
      }
      for oneElementpositions in positions {
          serialize_size += oneElementpositions.computeMessageSize(4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Services.Resume.Containers.ResumeV1 {
      return Services.Resume.Containers.ResumeV1.builder().mergeFromData(data, extensionRegistry:Services.Resume.Containers.ContainersRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.ResumeV1 {
      return Services.Resume.Containers.ResumeV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Services.Resume.Containers.ResumeV1 {
      return Services.Resume.Containers.ResumeV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Services.Resume.Containers.ResumeV1 {
      return Services.Resume.Containers.ResumeV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Services.Resume.Containers.ResumeV1 {
      return Services.Resume.Containers.ResumeV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.ResumeV1 {
      return Services.Resume.Containers.ResumeV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Services.Resume.Containers.ResumeV1Builder {
      return Services.Resume.Containers.ResumeV1.classBuilder() as! Services.Resume.Containers.ResumeV1Builder
    }
    public func builder() -> Services.Resume.Containers.ResumeV1Builder {
      return classBuilder() as! Services.Resume.Containers.ResumeV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Services.Resume.Containers.ResumeV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Services.Resume.Containers.ResumeV1.builder()
    }
    public func toBuilder() -> Services.Resume.Containers.ResumeV1Builder {
      return Services.Resume.Containers.ResumeV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Services.Resume.Containers.ResumeV1) -> Services.Resume.Containers.ResumeV1Builder {
      return Services.Resume.Containers.ResumeV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasUserId {
        output += "\(indent) userId: \(userId) \n"
      }
      var educationsElementIndex:Int = 0
      for oneElementeducations in educations {
          output += "\(indent) educations[\(educationsElementIndex)] {\n"
          oneElementeducations.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          educationsElementIndex++
      }
      var positionsElementIndex:Int = 0
      for oneElementpositions in positions {
          output += "\(indent) positions[\(positionsElementIndex)] {\n"
          oneElementpositions.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          positionsElementIndex++
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasUserId {
               hashCode = (hashCode &* 31) &+ userId.hashValue
            }
            for oneElementeducations in educations {
                hashCode = (hashCode &* 31) &+ oneElementeducations.hashValue
            }
            for oneElementpositions in positions {
                hashCode = (hashCode &* 31) &+ oneElementpositions.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Services.Resume.Containers.ResumeV1"
    }
    override public func className() -> String {
        return "Services.Resume.Containers.ResumeV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Services.Resume.Containers.ResumeV1.self
    }
    //Meta information declaration end

  }

  final public class ResumeV1Builder : GeneratedMessageBuilder {
    private var builderResult:Services.Resume.Containers.ResumeV1

    required override public init () {
       builderResult = Services.Resume.Containers.ResumeV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Services.Resume.Containers.ResumeV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Services.Resume.Containers.ResumeV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    public var hasUserId:Bool {
         get {
              return builderResult.hasUserId
         }
    }
    public var userId:String {
         get {
              return builderResult.userId
         }
         set (value) {
             builderResult.hasUserId = true
             builderResult.userId = value
         }
    }
    public func setUserId(value:String)-> Services.Resume.Containers.ResumeV1Builder {
      self.userId = value
      return self
    }
    public func clearUserId() -> Services.Resume.Containers.ResumeV1Builder{
         builderResult.hasUserId = false
         builderResult.userId = ""
         return self
    }
    public var educations:Array<Services.Resume.Containers.EducationV1> {
         get {
             return builderResult.educations
         }
         set (value) {
             builderResult.educations = value
         }
    }
    public func setEducations(value:Array<Services.Resume.Containers.EducationV1>)-> Services.Resume.Containers.ResumeV1Builder {
      self.educations = value
      return self
    }
    public func clearEducations() -> Services.Resume.Containers.ResumeV1Builder {
      builderResult.educations.removeAll(keepCapacity: false)
      return self
    }
    public var positions:Array<Services.Resume.Containers.PositionV1> {
         get {
             return builderResult.positions
         }
         set (value) {
             builderResult.positions = value
         }
    }
    public func setPositions(value:Array<Services.Resume.Containers.PositionV1>)-> Services.Resume.Containers.ResumeV1Builder {
      self.positions = value
      return self
    }
    public func clearPositions() -> Services.Resume.Containers.ResumeV1Builder {
      builderResult.positions.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Services.Resume.Containers.ResumeV1Builder {
      builderResult = Services.Resume.Containers.ResumeV1()
      return self
    }
    public override func clone() -> Services.Resume.Containers.ResumeV1Builder {
      return Services.Resume.Containers.ResumeV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Services.Resume.Containers.ResumeV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Services.Resume.Containers.ResumeV1 {
      var returnMe:Services.Resume.Containers.ResumeV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Services.Resume.Containers.ResumeV1) -> Services.Resume.Containers.ResumeV1Builder {
      if (other == Services.Resume.Containers.ResumeV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      if other.hasUserId {
           userId = other.userId
      }
      if !other.educations.isEmpty  {
         builderResult.educations += other.educations
      }
      if !other.positions.isEmpty  {
         builderResult.positions += other.positions
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Services.Resume.Containers.ResumeV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.ResumeV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        case 18 :
          userId = input.readString()

        case 26 :
          var subBuilder = Services.Resume.Containers.EducationV1.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          educations += [subBuilder.buildPartial()]

        case 34 :
          var subBuilder = Services.Resume.Containers.PositionV1.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          positions += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class EducationV1 : GeneratedMessage, GeneratedMessageProtocol {
    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           case "id": return id
           case "schoolName": return schoolName
           case "startDate": return startDate
           case "endDate": return endDate
           case "notes": return notes
           case "userId": return userId
           case "activities": return activities
           case "fieldOfStudy": return fieldOfStudy
           case "degree": return degree
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasId:Bool = false
    public private(set) var id:String = ""

    public private(set) var hasSchoolName:Bool = false
    public private(set) var schoolName:String = ""

    public private(set) var hasStartDate:Bool = false
    public private(set) var startDate:Services.Resume.Containers.ApproximateDateV1!
    public private(set) var hasEndDate:Bool = false
    public private(set) var endDate:Services.Resume.Containers.ApproximateDateV1!
    public private(set) var hasNotes:Bool = false
    public private(set) var notes:String = ""

    public private(set) var hasUserId:Bool = false
    public private(set) var userId:String = ""

    public private(set) var hasActivities:Bool = false
    public private(set) var activities:String = ""

    public private(set) var hasFieldOfStudy:Bool = false
    public private(set) var fieldOfStudy:String = ""

    public private(set) var hasDegree:Bool = false
    public private(set) var degree:String = ""

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      if hasId {
        output.writeString(2, value:id)
      }
      if hasSchoolName {
        output.writeString(3, value:schoolName)
      }
      if hasStartDate {
        output.writeMessage(4, value:startDate)
      }
      if hasEndDate {
        output.writeMessage(5, value:endDate)
      }
      if hasNotes {
        output.writeString(6, value:notes)
      }
      if hasUserId {
        output.writeString(7, value:userId)
      }
      if hasActivities {
        output.writeString(8, value:activities)
      }
      if hasFieldOfStudy {
        output.writeString(9, value:fieldOfStudy)
      }
      if hasDegree {
        output.writeString(10, value:degree)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasId {
        serialize_size += id.computeStringSize(2)
      }
      if hasSchoolName {
        serialize_size += schoolName.computeStringSize(3)
      }
      if hasStartDate {
          if let varSizestartDate = startDate?.computeMessageSize(4) {
              serialize_size += varSizestartDate
          }
      }
      if hasEndDate {
          if let varSizeendDate = endDate?.computeMessageSize(5) {
              serialize_size += varSizeendDate
          }
      }
      if hasNotes {
        serialize_size += notes.computeStringSize(6)
      }
      if hasUserId {
        serialize_size += userId.computeStringSize(7)
      }
      if hasActivities {
        serialize_size += activities.computeStringSize(8)
      }
      if hasFieldOfStudy {
        serialize_size += fieldOfStudy.computeStringSize(9)
      }
      if hasDegree {
        serialize_size += degree.computeStringSize(10)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Services.Resume.Containers.EducationV1 {
      return Services.Resume.Containers.EducationV1.builder().mergeFromData(data, extensionRegistry:Services.Resume.Containers.ContainersRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.EducationV1 {
      return Services.Resume.Containers.EducationV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Services.Resume.Containers.EducationV1 {
      return Services.Resume.Containers.EducationV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Services.Resume.Containers.EducationV1 {
      return Services.Resume.Containers.EducationV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Services.Resume.Containers.EducationV1 {
      return Services.Resume.Containers.EducationV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.EducationV1 {
      return Services.Resume.Containers.EducationV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Services.Resume.Containers.EducationV1Builder {
      return Services.Resume.Containers.EducationV1.classBuilder() as! Services.Resume.Containers.EducationV1Builder
    }
    public func builder() -> Services.Resume.Containers.EducationV1Builder {
      return classBuilder() as! Services.Resume.Containers.EducationV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Services.Resume.Containers.EducationV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Services.Resume.Containers.EducationV1.builder()
    }
    public func toBuilder() -> Services.Resume.Containers.EducationV1Builder {
      return Services.Resume.Containers.EducationV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Services.Resume.Containers.EducationV1) -> Services.Resume.Containers.EducationV1Builder {
      return Services.Resume.Containers.EducationV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasId {
        output += "\(indent) id: \(id) \n"
      }
      if hasSchoolName {
        output += "\(indent) schoolName: \(schoolName) \n"
      }
      if hasStartDate {
        output += "\(indent) startDate {\n"
        startDate?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasEndDate {
        output += "\(indent) endDate {\n"
        endDate?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasNotes {
        output += "\(indent) notes: \(notes) \n"
      }
      if hasUserId {
        output += "\(indent) userId: \(userId) \n"
      }
      if hasActivities {
        output += "\(indent) activities: \(activities) \n"
      }
      if hasFieldOfStudy {
        output += "\(indent) fieldOfStudy: \(fieldOfStudy) \n"
      }
      if hasDegree {
        output += "\(indent) degree: \(degree) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasId {
               hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasSchoolName {
               hashCode = (hashCode &* 31) &+ schoolName.hashValue
            }
            if hasStartDate {
                if let hashValuestartDate = startDate?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuestartDate
                }
            }
            if hasEndDate {
                if let hashValueendDate = endDate?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueendDate
                }
            }
            if hasNotes {
               hashCode = (hashCode &* 31) &+ notes.hashValue
            }
            if hasUserId {
               hashCode = (hashCode &* 31) &+ userId.hashValue
            }
            if hasActivities {
               hashCode = (hashCode &* 31) &+ activities.hashValue
            }
            if hasFieldOfStudy {
               hashCode = (hashCode &* 31) &+ fieldOfStudy.hashValue
            }
            if hasDegree {
               hashCode = (hashCode &* 31) &+ degree.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Services.Resume.Containers.EducationV1"
    }
    override public func className() -> String {
        return "Services.Resume.Containers.EducationV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Services.Resume.Containers.EducationV1.self
    }
    //Meta information declaration end

  }

  final public class EducationV1Builder : GeneratedMessageBuilder {
    private var builderResult:Services.Resume.Containers.EducationV1

    required override public init () {
       builderResult = Services.Resume.Containers.EducationV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Services.Resume.Containers.EducationV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Services.Resume.Containers.EducationV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:String {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(value:String)-> Services.Resume.Containers.EducationV1Builder {
      self.id = value
      return self
    }
    public func clearId() -> Services.Resume.Containers.EducationV1Builder{
         builderResult.hasId = false
         builderResult.id = ""
         return self
    }
    public var hasSchoolName:Bool {
         get {
              return builderResult.hasSchoolName
         }
    }
    public var schoolName:String {
         get {
              return builderResult.schoolName
         }
         set (value) {
             builderResult.hasSchoolName = true
             builderResult.schoolName = value
         }
    }
    public func setSchoolName(value:String)-> Services.Resume.Containers.EducationV1Builder {
      self.schoolName = value
      return self
    }
    public func clearSchoolName() -> Services.Resume.Containers.EducationV1Builder{
         builderResult.hasSchoolName = false
         builderResult.schoolName = ""
         return self
    }
    public var hasStartDate:Bool {
         get {
             return builderResult.hasStartDate
         }
    }
    public var startDate:Services.Resume.Containers.ApproximateDateV1! {
         get {
             return builderResult.startDate
         }
         set (value) {
             builderResult.hasStartDate = true
             builderResult.startDate = value
         }
    }
    public func setStartDate(value:Services.Resume.Containers.ApproximateDateV1!)-> Services.Resume.Containers.EducationV1Builder {
      self.startDate = value
      return self
    }
    public func mergeStartDate(value:Services.Resume.Containers.ApproximateDateV1) -> Services.Resume.Containers.EducationV1Builder {
      if (builderResult.hasStartDate) {
        builderResult.startDate = Services.Resume.Containers.ApproximateDateV1.builderWithPrototype(builderResult.startDate).mergeFrom(value).buildPartial()
      } else {
        builderResult.startDate = value
      }
      builderResult.hasStartDate = true
      return self
    }
    public func clearStartDate() -> Services.Resume.Containers.EducationV1Builder {
      builderResult.hasStartDate = false
      builderResult.startDate = nil
      return self
    }
    public var hasEndDate:Bool {
         get {
             return builderResult.hasEndDate
         }
    }
    public var endDate:Services.Resume.Containers.ApproximateDateV1! {
         get {
             return builderResult.endDate
         }
         set (value) {
             builderResult.hasEndDate = true
             builderResult.endDate = value
         }
    }
    public func setEndDate(value:Services.Resume.Containers.ApproximateDateV1!)-> Services.Resume.Containers.EducationV1Builder {
      self.endDate = value
      return self
    }
    public func mergeEndDate(value:Services.Resume.Containers.ApproximateDateV1) -> Services.Resume.Containers.EducationV1Builder {
      if (builderResult.hasEndDate) {
        builderResult.endDate = Services.Resume.Containers.ApproximateDateV1.builderWithPrototype(builderResult.endDate).mergeFrom(value).buildPartial()
      } else {
        builderResult.endDate = value
      }
      builderResult.hasEndDate = true
      return self
    }
    public func clearEndDate() -> Services.Resume.Containers.EducationV1Builder {
      builderResult.hasEndDate = false
      builderResult.endDate = nil
      return self
    }
    public var hasNotes:Bool {
         get {
              return builderResult.hasNotes
         }
    }
    public var notes:String {
         get {
              return builderResult.notes
         }
         set (value) {
             builderResult.hasNotes = true
             builderResult.notes = value
         }
    }
    public func setNotes(value:String)-> Services.Resume.Containers.EducationV1Builder {
      self.notes = value
      return self
    }
    public func clearNotes() -> Services.Resume.Containers.EducationV1Builder{
         builderResult.hasNotes = false
         builderResult.notes = ""
         return self
    }
    public var hasUserId:Bool {
         get {
              return builderResult.hasUserId
         }
    }
    public var userId:String {
         get {
              return builderResult.userId
         }
         set (value) {
             builderResult.hasUserId = true
             builderResult.userId = value
         }
    }
    public func setUserId(value:String)-> Services.Resume.Containers.EducationV1Builder {
      self.userId = value
      return self
    }
    public func clearUserId() -> Services.Resume.Containers.EducationV1Builder{
         builderResult.hasUserId = false
         builderResult.userId = ""
         return self
    }
    public var hasActivities:Bool {
         get {
              return builderResult.hasActivities
         }
    }
    public var activities:String {
         get {
              return builderResult.activities
         }
         set (value) {
             builderResult.hasActivities = true
             builderResult.activities = value
         }
    }
    public func setActivities(value:String)-> Services.Resume.Containers.EducationV1Builder {
      self.activities = value
      return self
    }
    public func clearActivities() -> Services.Resume.Containers.EducationV1Builder{
         builderResult.hasActivities = false
         builderResult.activities = ""
         return self
    }
    public var hasFieldOfStudy:Bool {
         get {
              return builderResult.hasFieldOfStudy
         }
    }
    public var fieldOfStudy:String {
         get {
              return builderResult.fieldOfStudy
         }
         set (value) {
             builderResult.hasFieldOfStudy = true
             builderResult.fieldOfStudy = value
         }
    }
    public func setFieldOfStudy(value:String)-> Services.Resume.Containers.EducationV1Builder {
      self.fieldOfStudy = value
      return self
    }
    public func clearFieldOfStudy() -> Services.Resume.Containers.EducationV1Builder{
         builderResult.hasFieldOfStudy = false
         builderResult.fieldOfStudy = ""
         return self
    }
    public var hasDegree:Bool {
         get {
              return builderResult.hasDegree
         }
    }
    public var degree:String {
         get {
              return builderResult.degree
         }
         set (value) {
             builderResult.hasDegree = true
             builderResult.degree = value
         }
    }
    public func setDegree(value:String)-> Services.Resume.Containers.EducationV1Builder {
      self.degree = value
      return self
    }
    public func clearDegree() -> Services.Resume.Containers.EducationV1Builder{
         builderResult.hasDegree = false
         builderResult.degree = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Services.Resume.Containers.EducationV1Builder {
      builderResult = Services.Resume.Containers.EducationV1()
      return self
    }
    public override func clone() -> Services.Resume.Containers.EducationV1Builder {
      return Services.Resume.Containers.EducationV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Services.Resume.Containers.EducationV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Services.Resume.Containers.EducationV1 {
      var returnMe:Services.Resume.Containers.EducationV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Services.Resume.Containers.EducationV1) -> Services.Resume.Containers.EducationV1Builder {
      if (other == Services.Resume.Containers.EducationV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      if other.hasId {
           id = other.id
      }
      if other.hasSchoolName {
           schoolName = other.schoolName
      }
      if (other.hasStartDate) {
          mergeStartDate(other.startDate)
      }
      if (other.hasEndDate) {
          mergeEndDate(other.endDate)
      }
      if other.hasNotes {
           notes = other.notes
      }
      if other.hasUserId {
           userId = other.userId
      }
      if other.hasActivities {
           activities = other.activities
      }
      if other.hasFieldOfStudy {
           fieldOfStudy = other.fieldOfStudy
      }
      if other.hasDegree {
           degree = other.degree
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Services.Resume.Containers.EducationV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.EducationV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        case 18 :
          id = input.readString()

        case 26 :
          schoolName = input.readString()

        case 34 :
          var subBuilder:Services.Resume.Containers.ApproximateDateV1Builder = Services.Resume.Containers.ApproximateDateV1.builder()
          if hasStartDate {
            subBuilder.mergeFrom(startDate)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          startDate = subBuilder.buildPartial()

        case 42 :
          var subBuilder:Services.Resume.Containers.ApproximateDateV1Builder = Services.Resume.Containers.ApproximateDateV1.builder()
          if hasEndDate {
            subBuilder.mergeFrom(endDate)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          endDate = subBuilder.buildPartial()

        case 50 :
          notes = input.readString()

        case 58 :
          userId = input.readString()

        case 66 :
          activities = input.readString()

        case 74 :
          fieldOfStudy = input.readString()

        case 82 :
          degree = input.readString()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class PositionV1 : GeneratedMessage, GeneratedMessageProtocol {
    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           case "id": return id
           case "title": return title
           case "startDate": return startDate
           case "endDate": return endDate
           case "summary": return summary
           case "company": return company
           case "userId": return userId
           case "isCurrent": return isCurrent
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasId:Bool = false
    public private(set) var id:String = ""

    public private(set) var hasTitle:Bool = false
    public private(set) var title:String = ""

    public private(set) var hasStartDate:Bool = false
    public private(set) var startDate:Services.Resume.Containers.ApproximateDateV1!
    public private(set) var hasEndDate:Bool = false
    public private(set) var endDate:Services.Resume.Containers.ApproximateDateV1!
    public private(set) var hasSummary:Bool = false
    public private(set) var summary:String = ""

    public private(set) var hasCompany:Bool = false
    public private(set) var company:Services.Resume.Containers.CompanyV1!
    public private(set) var hasUserId:Bool = false
    public private(set) var userId:String = ""

    public private(set) var hasIsCurrent:Bool = false
    public private(set) var isCurrent:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      if hasId {
        output.writeString(2, value:id)
      }
      if hasTitle {
        output.writeString(3, value:title)
      }
      if hasStartDate {
        output.writeMessage(4, value:startDate)
      }
      if hasEndDate {
        output.writeMessage(5, value:endDate)
      }
      if hasSummary {
        output.writeString(6, value:summary)
      }
      if hasCompany {
        output.writeMessage(7, value:company)
      }
      if hasUserId {
        output.writeString(8, value:userId)
      }
      if hasIsCurrent {
        output.writeBool(9, value:isCurrent)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasId {
        serialize_size += id.computeStringSize(2)
      }
      if hasTitle {
        serialize_size += title.computeStringSize(3)
      }
      if hasStartDate {
          if let varSizestartDate = startDate?.computeMessageSize(4) {
              serialize_size += varSizestartDate
          }
      }
      if hasEndDate {
          if let varSizeendDate = endDate?.computeMessageSize(5) {
              serialize_size += varSizeendDate
          }
      }
      if hasSummary {
        serialize_size += summary.computeStringSize(6)
      }
      if hasCompany {
          if let varSizecompany = company?.computeMessageSize(7) {
              serialize_size += varSizecompany
          }
      }
      if hasUserId {
        serialize_size += userId.computeStringSize(8)
      }
      if hasIsCurrent {
        serialize_size += isCurrent.computeBoolSize(9)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Services.Resume.Containers.PositionV1 {
      return Services.Resume.Containers.PositionV1.builder().mergeFromData(data, extensionRegistry:Services.Resume.Containers.ContainersRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.PositionV1 {
      return Services.Resume.Containers.PositionV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Services.Resume.Containers.PositionV1 {
      return Services.Resume.Containers.PositionV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Services.Resume.Containers.PositionV1 {
      return Services.Resume.Containers.PositionV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Services.Resume.Containers.PositionV1 {
      return Services.Resume.Containers.PositionV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.PositionV1 {
      return Services.Resume.Containers.PositionV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Services.Resume.Containers.PositionV1Builder {
      return Services.Resume.Containers.PositionV1.classBuilder() as! Services.Resume.Containers.PositionV1Builder
    }
    public func builder() -> Services.Resume.Containers.PositionV1Builder {
      return classBuilder() as! Services.Resume.Containers.PositionV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Services.Resume.Containers.PositionV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Services.Resume.Containers.PositionV1.builder()
    }
    public func toBuilder() -> Services.Resume.Containers.PositionV1Builder {
      return Services.Resume.Containers.PositionV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Services.Resume.Containers.PositionV1) -> Services.Resume.Containers.PositionV1Builder {
      return Services.Resume.Containers.PositionV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasId {
        output += "\(indent) id: \(id) \n"
      }
      if hasTitle {
        output += "\(indent) title: \(title) \n"
      }
      if hasStartDate {
        output += "\(indent) startDate {\n"
        startDate?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasEndDate {
        output += "\(indent) endDate {\n"
        endDate?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasSummary {
        output += "\(indent) summary: \(summary) \n"
      }
      if hasCompany {
        output += "\(indent) company {\n"
        company?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasUserId {
        output += "\(indent) userId: \(userId) \n"
      }
      if hasIsCurrent {
        output += "\(indent) isCurrent: \(isCurrent) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasId {
               hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasTitle {
               hashCode = (hashCode &* 31) &+ title.hashValue
            }
            if hasStartDate {
                if let hashValuestartDate = startDate?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuestartDate
                }
            }
            if hasEndDate {
                if let hashValueendDate = endDate?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueendDate
                }
            }
            if hasSummary {
               hashCode = (hashCode &* 31) &+ summary.hashValue
            }
            if hasCompany {
                if let hashValuecompany = company?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecompany
                }
            }
            if hasUserId {
               hashCode = (hashCode &* 31) &+ userId.hashValue
            }
            if hasIsCurrent {
               hashCode = (hashCode &* 31) &+ isCurrent.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Services.Resume.Containers.PositionV1"
    }
    override public func className() -> String {
        return "Services.Resume.Containers.PositionV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Services.Resume.Containers.PositionV1.self
    }
    //Meta information declaration end

  }

  final public class PositionV1Builder : GeneratedMessageBuilder {
    private var builderResult:Services.Resume.Containers.PositionV1

    required override public init () {
       builderResult = Services.Resume.Containers.PositionV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Services.Resume.Containers.PositionV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Services.Resume.Containers.PositionV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:String {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(value:String)-> Services.Resume.Containers.PositionV1Builder {
      self.id = value
      return self
    }
    public func clearId() -> Services.Resume.Containers.PositionV1Builder{
         builderResult.hasId = false
         builderResult.id = ""
         return self
    }
    public var hasTitle:Bool {
         get {
              return builderResult.hasTitle
         }
    }
    public var title:String {
         get {
              return builderResult.title
         }
         set (value) {
             builderResult.hasTitle = true
             builderResult.title = value
         }
    }
    public func setTitle(value:String)-> Services.Resume.Containers.PositionV1Builder {
      self.title = value
      return self
    }
    public func clearTitle() -> Services.Resume.Containers.PositionV1Builder{
         builderResult.hasTitle = false
         builderResult.title = ""
         return self
    }
    public var hasStartDate:Bool {
         get {
             return builderResult.hasStartDate
         }
    }
    public var startDate:Services.Resume.Containers.ApproximateDateV1! {
         get {
             return builderResult.startDate
         }
         set (value) {
             builderResult.hasStartDate = true
             builderResult.startDate = value
         }
    }
    public func setStartDate(value:Services.Resume.Containers.ApproximateDateV1!)-> Services.Resume.Containers.PositionV1Builder {
      self.startDate = value
      return self
    }
    public func mergeStartDate(value:Services.Resume.Containers.ApproximateDateV1) -> Services.Resume.Containers.PositionV1Builder {
      if (builderResult.hasStartDate) {
        builderResult.startDate = Services.Resume.Containers.ApproximateDateV1.builderWithPrototype(builderResult.startDate).mergeFrom(value).buildPartial()
      } else {
        builderResult.startDate = value
      }
      builderResult.hasStartDate = true
      return self
    }
    public func clearStartDate() -> Services.Resume.Containers.PositionV1Builder {
      builderResult.hasStartDate = false
      builderResult.startDate = nil
      return self
    }
    public var hasEndDate:Bool {
         get {
             return builderResult.hasEndDate
         }
    }
    public var endDate:Services.Resume.Containers.ApproximateDateV1! {
         get {
             return builderResult.endDate
         }
         set (value) {
             builderResult.hasEndDate = true
             builderResult.endDate = value
         }
    }
    public func setEndDate(value:Services.Resume.Containers.ApproximateDateV1!)-> Services.Resume.Containers.PositionV1Builder {
      self.endDate = value
      return self
    }
    public func mergeEndDate(value:Services.Resume.Containers.ApproximateDateV1) -> Services.Resume.Containers.PositionV1Builder {
      if (builderResult.hasEndDate) {
        builderResult.endDate = Services.Resume.Containers.ApproximateDateV1.builderWithPrototype(builderResult.endDate).mergeFrom(value).buildPartial()
      } else {
        builderResult.endDate = value
      }
      builderResult.hasEndDate = true
      return self
    }
    public func clearEndDate() -> Services.Resume.Containers.PositionV1Builder {
      builderResult.hasEndDate = false
      builderResult.endDate = nil
      return self
    }
    public var hasSummary:Bool {
         get {
              return builderResult.hasSummary
         }
    }
    public var summary:String {
         get {
              return builderResult.summary
         }
         set (value) {
             builderResult.hasSummary = true
             builderResult.summary = value
         }
    }
    public func setSummary(value:String)-> Services.Resume.Containers.PositionV1Builder {
      self.summary = value
      return self
    }
    public func clearSummary() -> Services.Resume.Containers.PositionV1Builder{
         builderResult.hasSummary = false
         builderResult.summary = ""
         return self
    }
    public var hasCompany:Bool {
         get {
             return builderResult.hasCompany
         }
    }
    public var company:Services.Resume.Containers.CompanyV1! {
         get {
             return builderResult.company
         }
         set (value) {
             builderResult.hasCompany = true
             builderResult.company = value
         }
    }
    public func setCompany(value:Services.Resume.Containers.CompanyV1!)-> Services.Resume.Containers.PositionV1Builder {
      self.company = value
      return self
    }
    public func mergeCompany(value:Services.Resume.Containers.CompanyV1) -> Services.Resume.Containers.PositionV1Builder {
      if (builderResult.hasCompany) {
        builderResult.company = Services.Resume.Containers.CompanyV1.builderWithPrototype(builderResult.company).mergeFrom(value).buildPartial()
      } else {
        builderResult.company = value
      }
      builderResult.hasCompany = true
      return self
    }
    public func clearCompany() -> Services.Resume.Containers.PositionV1Builder {
      builderResult.hasCompany = false
      builderResult.company = nil
      return self
    }
    public var hasUserId:Bool {
         get {
              return builderResult.hasUserId
         }
    }
    public var userId:String {
         get {
              return builderResult.userId
         }
         set (value) {
             builderResult.hasUserId = true
             builderResult.userId = value
         }
    }
    public func setUserId(value:String)-> Services.Resume.Containers.PositionV1Builder {
      self.userId = value
      return self
    }
    public func clearUserId() -> Services.Resume.Containers.PositionV1Builder{
         builderResult.hasUserId = false
         builderResult.userId = ""
         return self
    }
    public var hasIsCurrent:Bool {
         get {
              return builderResult.hasIsCurrent
         }
    }
    public var isCurrent:Bool {
         get {
              return builderResult.isCurrent
         }
         set (value) {
             builderResult.hasIsCurrent = true
             builderResult.isCurrent = value
         }
    }
    public func setIsCurrent(value:Bool)-> Services.Resume.Containers.PositionV1Builder {
      self.isCurrent = value
      return self
    }
    public func clearIsCurrent() -> Services.Resume.Containers.PositionV1Builder{
         builderResult.hasIsCurrent = false
         builderResult.isCurrent = false
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Services.Resume.Containers.PositionV1Builder {
      builderResult = Services.Resume.Containers.PositionV1()
      return self
    }
    public override func clone() -> Services.Resume.Containers.PositionV1Builder {
      return Services.Resume.Containers.PositionV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Services.Resume.Containers.PositionV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Services.Resume.Containers.PositionV1 {
      var returnMe:Services.Resume.Containers.PositionV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Services.Resume.Containers.PositionV1) -> Services.Resume.Containers.PositionV1Builder {
      if (other == Services.Resume.Containers.PositionV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      if other.hasId {
           id = other.id
      }
      if other.hasTitle {
           title = other.title
      }
      if (other.hasStartDate) {
          mergeStartDate(other.startDate)
      }
      if (other.hasEndDate) {
          mergeEndDate(other.endDate)
      }
      if other.hasSummary {
           summary = other.summary
      }
      if (other.hasCompany) {
          mergeCompany(other.company)
      }
      if other.hasUserId {
           userId = other.userId
      }
      if other.hasIsCurrent {
           isCurrent = other.isCurrent
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Services.Resume.Containers.PositionV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.PositionV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        case 18 :
          id = input.readString()

        case 26 :
          title = input.readString()

        case 34 :
          var subBuilder:Services.Resume.Containers.ApproximateDateV1Builder = Services.Resume.Containers.ApproximateDateV1.builder()
          if hasStartDate {
            subBuilder.mergeFrom(startDate)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          startDate = subBuilder.buildPartial()

        case 42 :
          var subBuilder:Services.Resume.Containers.ApproximateDateV1Builder = Services.Resume.Containers.ApproximateDateV1.builder()
          if hasEndDate {
            subBuilder.mergeFrom(endDate)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          endDate = subBuilder.buildPartial()

        case 50 :
          summary = input.readString()

        case 58 :
          var subBuilder:Services.Resume.Containers.CompanyV1Builder = Services.Resume.Containers.CompanyV1.builder()
          if hasCompany {
            subBuilder.mergeFrom(company)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          company = subBuilder.buildPartial()

        case 66 :
          userId = input.readString()

        case 72 :
          isCurrent = input.readBool()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class CompanyV1 : GeneratedMessage, GeneratedMessageProtocol {
    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           case "id": return id
           case "name": return name
           case "linkedinId": return linkedinId
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasId:Bool = false
    public private(set) var id:String = ""

    public private(set) var hasName:Bool = false
    public private(set) var name:String = ""

    public private(set) var hasLinkedinId:Bool = false
    public private(set) var linkedinId:String = ""

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      if hasId {
        output.writeString(2, value:id)
      }
      if hasName {
        output.writeString(3, value:name)
      }
      if hasLinkedinId {
        output.writeString(4, value:linkedinId)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasId {
        serialize_size += id.computeStringSize(2)
      }
      if hasName {
        serialize_size += name.computeStringSize(3)
      }
      if hasLinkedinId {
        serialize_size += linkedinId.computeStringSize(4)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Services.Resume.Containers.CompanyV1 {
      return Services.Resume.Containers.CompanyV1.builder().mergeFromData(data, extensionRegistry:Services.Resume.Containers.ContainersRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.CompanyV1 {
      return Services.Resume.Containers.CompanyV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Services.Resume.Containers.CompanyV1 {
      return Services.Resume.Containers.CompanyV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Services.Resume.Containers.CompanyV1 {
      return Services.Resume.Containers.CompanyV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Services.Resume.Containers.CompanyV1 {
      return Services.Resume.Containers.CompanyV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.CompanyV1 {
      return Services.Resume.Containers.CompanyV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Services.Resume.Containers.CompanyV1Builder {
      return Services.Resume.Containers.CompanyV1.classBuilder() as! Services.Resume.Containers.CompanyV1Builder
    }
    public func builder() -> Services.Resume.Containers.CompanyV1Builder {
      return classBuilder() as! Services.Resume.Containers.CompanyV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Services.Resume.Containers.CompanyV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Services.Resume.Containers.CompanyV1.builder()
    }
    public func toBuilder() -> Services.Resume.Containers.CompanyV1Builder {
      return Services.Resume.Containers.CompanyV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Services.Resume.Containers.CompanyV1) -> Services.Resume.Containers.CompanyV1Builder {
      return Services.Resume.Containers.CompanyV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasId {
        output += "\(indent) id: \(id) \n"
      }
      if hasName {
        output += "\(indent) name: \(name) \n"
      }
      if hasLinkedinId {
        output += "\(indent) linkedinId: \(linkedinId) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasId {
               hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasName {
               hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasLinkedinId {
               hashCode = (hashCode &* 31) &+ linkedinId.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Services.Resume.Containers.CompanyV1"
    }
    override public func className() -> String {
        return "Services.Resume.Containers.CompanyV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Services.Resume.Containers.CompanyV1.self
    }
    //Meta information declaration end

  }

  final public class CompanyV1Builder : GeneratedMessageBuilder {
    private var builderResult:Services.Resume.Containers.CompanyV1

    required override public init () {
       builderResult = Services.Resume.Containers.CompanyV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Services.Resume.Containers.CompanyV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Services.Resume.Containers.CompanyV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    public var hasId:Bool {
         get {
              return builderResult.hasId
         }
    }
    public var id:String {
         get {
              return builderResult.id
         }
         set (value) {
             builderResult.hasId = true
             builderResult.id = value
         }
    }
    public func setId(value:String)-> Services.Resume.Containers.CompanyV1Builder {
      self.id = value
      return self
    }
    public func clearId() -> Services.Resume.Containers.CompanyV1Builder{
         builderResult.hasId = false
         builderResult.id = ""
         return self
    }
    public var hasName:Bool {
         get {
              return builderResult.hasName
         }
    }
    public var name:String {
         get {
              return builderResult.name
         }
         set (value) {
             builderResult.hasName = true
             builderResult.name = value
         }
    }
    public func setName(value:String)-> Services.Resume.Containers.CompanyV1Builder {
      self.name = value
      return self
    }
    public func clearName() -> Services.Resume.Containers.CompanyV1Builder{
         builderResult.hasName = false
         builderResult.name = ""
         return self
    }
    public var hasLinkedinId:Bool {
         get {
              return builderResult.hasLinkedinId
         }
    }
    public var linkedinId:String {
         get {
              return builderResult.linkedinId
         }
         set (value) {
             builderResult.hasLinkedinId = true
             builderResult.linkedinId = value
         }
    }
    public func setLinkedinId(value:String)-> Services.Resume.Containers.CompanyV1Builder {
      self.linkedinId = value
      return self
    }
    public func clearLinkedinId() -> Services.Resume.Containers.CompanyV1Builder{
         builderResult.hasLinkedinId = false
         builderResult.linkedinId = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Services.Resume.Containers.CompanyV1Builder {
      builderResult = Services.Resume.Containers.CompanyV1()
      return self
    }
    public override func clone() -> Services.Resume.Containers.CompanyV1Builder {
      return Services.Resume.Containers.CompanyV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Services.Resume.Containers.CompanyV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Services.Resume.Containers.CompanyV1 {
      var returnMe:Services.Resume.Containers.CompanyV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Services.Resume.Containers.CompanyV1) -> Services.Resume.Containers.CompanyV1Builder {
      if (other == Services.Resume.Containers.CompanyV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      if other.hasId {
           id = other.id
      }
      if other.hasName {
           name = other.name
      }
      if other.hasLinkedinId {
           linkedinId = other.linkedinId
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Services.Resume.Containers.CompanyV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Services.Resume.Containers.CompanyV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        case 18 :
          id = input.readString()

        case 26 :
          name = input.readString()

        case 34 :
          linkedinId = input.readString()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// @@protoc_insertion_point(global_scope)
