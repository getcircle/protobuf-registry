// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file soa.proto

import Foundation

public struct Soa { }

public func == (lhs: Soa.ControlV1, rhs: Soa.ControlV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasToken == rhs.hasToken) && (!lhs.hasToken || lhs.token == rhs.token)
  fieldCheck = fieldCheck && (lhs.hasService == rhs.hasService) && (!lhs.hasService || lhs.service == rhs.service)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Soa.PaginatorV1, rhs: Soa.PaginatorV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasNextPage == rhs.hasNextPage) && (!lhs.hasNextPage || lhs.nextPage == rhs.nextPage)
  fieldCheck = fieldCheck && (lhs.hasPreviousPage == rhs.hasPreviousPage) && (!lhs.hasPreviousPage || lhs.previousPage == rhs.previousPage)
  fieldCheck = fieldCheck && (lhs.hasCount == rhs.hasCount) && (!lhs.hasCount || lhs.count == rhs.count)
  fieldCheck = fieldCheck && (lhs.hasPageSize == rhs.hasPageSize) && (!lhs.hasPageSize || lhs.pageSize == rhs.pageSize)
  fieldCheck = fieldCheck && (lhs.hasPage == rhs.hasPage) && (!lhs.hasPage || lhs.page == rhs.page)
  fieldCheck = fieldCheck && (lhs.hasTotalPages == rhs.hasTotalPages) && (!lhs.hasTotalPages || lhs.totalPages == rhs.totalPages)
  fieldCheck = fieldCheck && (lhs.hasDisabled == rhs.hasDisabled) && (!lhs.hasDisabled || lhs.disabled == rhs.disabled)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Soa.ActionControlV1, rhs: Soa.ActionControlV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasService == rhs.hasService) && (!lhs.hasService || lhs.service == rhs.service)
  fieldCheck = fieldCheck && (lhs.hasAction == rhs.hasAction) && (!lhs.hasAction || lhs.action == rhs.action)
  fieldCheck = fieldCheck && (lhs.hasPaginator == rhs.hasPaginator) && (!lhs.hasPaginator || lhs.paginator == rhs.paginator)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Soa.ActionRequestV1, rhs: Soa.ActionRequestV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasControl == rhs.hasControl) && (!lhs.hasControl || lhs.control == rhs.control)
  fieldCheck = fieldCheck && (lhs.hasParams == rhs.hasParams) && (!lhs.hasParams || lhs.params == rhs.params)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Soa.ActionRequestParamsV1, rhs: Soa.ActionRequestParamsV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(100), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Soa.ActionResultV1, rhs: Soa.ActionResultV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.errors == rhs.errors)
  fieldCheck = fieldCheck && (lhs.errorDetails == rhs.errorDetails)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(100), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Soa.ActionResultV1.ErrorDetailV1, rhs: Soa.ActionResultV1.ErrorDetailV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasError == rhs.hasError) && (!lhs.hasError || lhs.error == rhs.error)
  fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
  fieldCheck = fieldCheck && (lhs.hasDetail == rhs.hasDetail) && (!lhs.hasDetail || lhs.detail == rhs.detail)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Soa.ActionResponseV1, rhs: Soa.ActionResponseV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasControl == rhs.hasControl) && (!lhs.hasControl || lhs.control == rhs.control)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Soa.ServiceRequestV1, rhs: Soa.ServiceRequestV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasControl == rhs.hasControl) && (!lhs.hasControl || lhs.control == rhs.control)
  fieldCheck = fieldCheck && (lhs.actions == rhs.actions)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Soa.ServiceResponseV1, rhs: Soa.ServiceResponseV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasControl == rhs.hasControl) && (!lhs.hasControl || lhs.control == rhs.control)
  fieldCheck = fieldCheck && (lhs.actions == rhs.actions)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(1000), endExclusive:Int32(536870912))
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public extension Soa {
  public struct SoaRoot {
    public static var sharedInstance : SoaRoot {
     struct Static {
         static let instance : SoaRoot = SoaRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }

  final public class ControlV1 : ExtendableMessage, GeneratedMessageProtocol{
    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasToken:Bool = false
    public private(set) var token:String = ""

    public private(set) var hasService:Bool = false
    public private(set) var service:String = ""

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasToken {
        try output.writeString(2, value:token)
      }
      if hasService {
        try output.writeString(3, value:service)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasToken {
        serialize_size += token.computeStringSize(2)
      }
      if hasService {
        serialize_size += service.computeStringSize(3)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Soa.ControlV1> {
      var mergedArray = Array<Soa.ControlV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Soa.ControlV1? {
      return try Soa.ControlV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Soa.ControlV1 {
      return try Soa.ControlV1.Builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Soa.ControlV1 {
      return try Soa.ControlV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Soa.ControlV1 {
      return try Soa.ControlV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ControlV1 {
      return try Soa.ControlV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Soa.ControlV1 {
      return try Soa.ControlV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ControlV1 {
      return try Soa.ControlV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Soa.ControlV1.Builder {
      return Soa.ControlV1.classBuilder() as! Soa.ControlV1.Builder
    }
    public func getBuilder() -> Soa.ControlV1.Builder {
      return classBuilder() as! Soa.ControlV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ControlV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ControlV1.Builder()
    }
    public func toBuilder() throws -> Soa.ControlV1.Builder {
      return try Soa.ControlV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ControlV1) throws -> Soa.ControlV1.Builder {
      return try Soa.ControlV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasToken {
        output += "\(indent) token: \(token) \n"
      }
      if hasService {
        output += "\(indent) service: \(service) \n"
      }
      try writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasToken {
               hashCode = (hashCode &* 31) &+ token.hashValue
            }
            if hasService {
               hashCode = (hashCode &* 31) &+ service.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ControlV1"
    }
    override public func className() -> String {
        return "Soa.ControlV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ControlV1.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Soa.ControlV1 = Soa.ControlV1()
      public func getMessage() -> Soa.ControlV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Soa.ControlV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Soa.ControlV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
      public var hasToken:Bool {
           get {
                return builderResult.hasToken
           }
      }
      public var token:String {
           get {
                return builderResult.token
           }
           set (value) {
               builderResult.hasToken = true
               builderResult.token = value
           }
      }
      public func setToken(value:String) -> Soa.ControlV1.Builder {
        self.token = value
        return self
      }
      public func clearToken() -> Soa.ControlV1.Builder{
           builderResult.hasToken = false
           builderResult.token = ""
           return self
      }
      public var hasService:Bool {
           get {
                return builderResult.hasService
           }
      }
      public var service:String {
           get {
                return builderResult.service
           }
           set (value) {
               builderResult.hasService = true
               builderResult.service = value
           }
      }
      public func setService(value:String) -> Soa.ControlV1.Builder {
        self.service = value
        return self
      }
      public func clearService() -> Soa.ControlV1.Builder{
           builderResult.hasService = false
           builderResult.service = ""
           return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> Soa.ControlV1.Builder {
        builderResult = Soa.ControlV1()
        return self
      }
      public override func clone() throws -> Soa.ControlV1.Builder {
        return try Soa.ControlV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Soa.ControlV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Soa.ControlV1 {
        let returnMe:Soa.ControlV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Soa.ControlV1) throws -> Soa.ControlV1.Builder {
        if other == Soa.ControlV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if other.hasToken {
             token = other.token
        }
        if other.hasService {
             service = other.service
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Soa.ControlV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ControlV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 18 :
            token = try input.readString()

          case 26 :
            service = try input.readString()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final public class PaginatorV1 : ExtendableMessage, GeneratedMessageProtocol{
    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasNextPage:Bool = false
    public private(set) var nextPage:UInt32 = UInt32(0)

    public private(set) var hasPreviousPage:Bool = false
    public private(set) var previousPage:UInt32 = UInt32(0)

    public private(set) var hasCount:Bool = false
    public private(set) var count:UInt32 = UInt32(0)

    public private(set) var hasPageSize:Bool = false
    public private(set) var pageSize:UInt32 = UInt32(0)

    public private(set) var hasPage:Bool = false
    public private(set) var page:UInt32 = UInt32(1)

    public private(set) var hasTotalPages:Bool = false
    public private(set) var totalPages:UInt32 = UInt32(0)

    public private(set) var hasDisabled:Bool = false
    public private(set) var disabled:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasNextPage {
        try output.writeUInt32(2, value:nextPage)
      }
      if hasPreviousPage {
        try output.writeUInt32(3, value:previousPage)
      }
      if hasCount {
        try output.writeUInt32(4, value:count)
      }
      if hasPageSize {
        try output.writeUInt32(5, value:pageSize)
      }
      if hasPage {
        try output.writeUInt32(6, value:page)
      }
      if hasTotalPages {
        try output.writeUInt32(7, value:totalPages)
      }
      if hasDisabled {
        try output.writeBool(8, value:disabled)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasNextPage {
        serialize_size += nextPage.computeUInt32Size(2)
      }
      if hasPreviousPage {
        serialize_size += previousPage.computeUInt32Size(3)
      }
      if hasCount {
        serialize_size += count.computeUInt32Size(4)
      }
      if hasPageSize {
        serialize_size += pageSize.computeUInt32Size(5)
      }
      if hasPage {
        serialize_size += page.computeUInt32Size(6)
      }
      if hasTotalPages {
        serialize_size += totalPages.computeUInt32Size(7)
      }
      if hasDisabled {
        serialize_size += disabled.computeBoolSize(8)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Soa.PaginatorV1> {
      var mergedArray = Array<Soa.PaginatorV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Soa.PaginatorV1? {
      return try Soa.PaginatorV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Soa.PaginatorV1 {
      return try Soa.PaginatorV1.Builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Soa.PaginatorV1 {
      return try Soa.PaginatorV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Soa.PaginatorV1 {
      return try Soa.PaginatorV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.PaginatorV1 {
      return try Soa.PaginatorV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Soa.PaginatorV1 {
      return try Soa.PaginatorV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.PaginatorV1 {
      return try Soa.PaginatorV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Soa.PaginatorV1.Builder {
      return Soa.PaginatorV1.classBuilder() as! Soa.PaginatorV1.Builder
    }
    public func getBuilder() -> Soa.PaginatorV1.Builder {
      return classBuilder() as! Soa.PaginatorV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.PaginatorV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.PaginatorV1.Builder()
    }
    public func toBuilder() throws -> Soa.PaginatorV1.Builder {
      return try Soa.PaginatorV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.PaginatorV1) throws -> Soa.PaginatorV1.Builder {
      return try Soa.PaginatorV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasNextPage {
        output += "\(indent) nextPage: \(nextPage) \n"
      }
      if hasPreviousPage {
        output += "\(indent) previousPage: \(previousPage) \n"
      }
      if hasCount {
        output += "\(indent) count: \(count) \n"
      }
      if hasPageSize {
        output += "\(indent) pageSize: \(pageSize) \n"
      }
      if hasPage {
        output += "\(indent) page: \(page) \n"
      }
      if hasTotalPages {
        output += "\(indent) totalPages: \(totalPages) \n"
      }
      if hasDisabled {
        output += "\(indent) disabled: \(disabled) \n"
      }
      try writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasNextPage {
               hashCode = (hashCode &* 31) &+ nextPage.hashValue
            }
            if hasPreviousPage {
               hashCode = (hashCode &* 31) &+ previousPage.hashValue
            }
            if hasCount {
               hashCode = (hashCode &* 31) &+ count.hashValue
            }
            if hasPageSize {
               hashCode = (hashCode &* 31) &+ pageSize.hashValue
            }
            if hasPage {
               hashCode = (hashCode &* 31) &+ page.hashValue
            }
            if hasTotalPages {
               hashCode = (hashCode &* 31) &+ totalPages.hashValue
            }
            if hasDisabled {
               hashCode = (hashCode &* 31) &+ disabled.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.PaginatorV1"
    }
    override public func className() -> String {
        return "Soa.PaginatorV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.PaginatorV1.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Soa.PaginatorV1 = Soa.PaginatorV1()
      public func getMessage() -> Soa.PaginatorV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Soa.PaginatorV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Soa.PaginatorV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
      public var hasNextPage:Bool {
           get {
                return builderResult.hasNextPage
           }
      }
      public var nextPage:UInt32 {
           get {
                return builderResult.nextPage
           }
           set (value) {
               builderResult.hasNextPage = true
               builderResult.nextPage = value
           }
      }
      public func setNextPage(value:UInt32) -> Soa.PaginatorV1.Builder {
        self.nextPage = value
        return self
      }
      public func clearNextPage() -> Soa.PaginatorV1.Builder{
           builderResult.hasNextPage = false
           builderResult.nextPage = UInt32(0)
           return self
      }
      public var hasPreviousPage:Bool {
           get {
                return builderResult.hasPreviousPage
           }
      }
      public var previousPage:UInt32 {
           get {
                return builderResult.previousPage
           }
           set (value) {
               builderResult.hasPreviousPage = true
               builderResult.previousPage = value
           }
      }
      public func setPreviousPage(value:UInt32) -> Soa.PaginatorV1.Builder {
        self.previousPage = value
        return self
      }
      public func clearPreviousPage() -> Soa.PaginatorV1.Builder{
           builderResult.hasPreviousPage = false
           builderResult.previousPage = UInt32(0)
           return self
      }
      public var hasCount:Bool {
           get {
                return builderResult.hasCount
           }
      }
      public var count:UInt32 {
           get {
                return builderResult.count
           }
           set (value) {
               builderResult.hasCount = true
               builderResult.count = value
           }
      }
      public func setCount(value:UInt32) -> Soa.PaginatorV1.Builder {
        self.count = value
        return self
      }
      public func clearCount() -> Soa.PaginatorV1.Builder{
           builderResult.hasCount = false
           builderResult.count = UInt32(0)
           return self
      }
      public var hasPageSize:Bool {
           get {
                return builderResult.hasPageSize
           }
      }
      public var pageSize:UInt32 {
           get {
                return builderResult.pageSize
           }
           set (value) {
               builderResult.hasPageSize = true
               builderResult.pageSize = value
           }
      }
      public func setPageSize(value:UInt32) -> Soa.PaginatorV1.Builder {
        self.pageSize = value
        return self
      }
      public func clearPageSize() -> Soa.PaginatorV1.Builder{
           builderResult.hasPageSize = false
           builderResult.pageSize = UInt32(0)
           return self
      }
      public var hasPage:Bool {
           get {
                return builderResult.hasPage
           }
      }
      public var page:UInt32 {
           get {
                return builderResult.page
           }
           set (value) {
               builderResult.hasPage = true
               builderResult.page = value
           }
      }
      public func setPage(value:UInt32) -> Soa.PaginatorV1.Builder {
        self.page = value
        return self
      }
      public func clearPage() -> Soa.PaginatorV1.Builder{
           builderResult.hasPage = false
           builderResult.page = UInt32(1)
           return self
      }
      public var hasTotalPages:Bool {
           get {
                return builderResult.hasTotalPages
           }
      }
      public var totalPages:UInt32 {
           get {
                return builderResult.totalPages
           }
           set (value) {
               builderResult.hasTotalPages = true
               builderResult.totalPages = value
           }
      }
      public func setTotalPages(value:UInt32) -> Soa.PaginatorV1.Builder {
        self.totalPages = value
        return self
      }
      public func clearTotalPages() -> Soa.PaginatorV1.Builder{
           builderResult.hasTotalPages = false
           builderResult.totalPages = UInt32(0)
           return self
      }
      public var hasDisabled:Bool {
           get {
                return builderResult.hasDisabled
           }
      }
      public var disabled:Bool {
           get {
                return builderResult.disabled
           }
           set (value) {
               builderResult.hasDisabled = true
               builderResult.disabled = value
           }
      }
      public func setDisabled(value:Bool) -> Soa.PaginatorV1.Builder {
        self.disabled = value
        return self
      }
      public func clearDisabled() -> Soa.PaginatorV1.Builder{
           builderResult.hasDisabled = false
           builderResult.disabled = false
           return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> Soa.PaginatorV1.Builder {
        builderResult = Soa.PaginatorV1()
        return self
      }
      public override func clone() throws -> Soa.PaginatorV1.Builder {
        return try Soa.PaginatorV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Soa.PaginatorV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Soa.PaginatorV1 {
        let returnMe:Soa.PaginatorV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Soa.PaginatorV1) throws -> Soa.PaginatorV1.Builder {
        if other == Soa.PaginatorV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if other.hasNextPage {
             nextPage = other.nextPage
        }
        if other.hasPreviousPage {
             previousPage = other.previousPage
        }
        if other.hasCount {
             count = other.count
        }
        if other.hasPageSize {
             pageSize = other.pageSize
        }
        if other.hasPage {
             page = other.page
        }
        if other.hasTotalPages {
             totalPages = other.totalPages
        }
        if other.hasDisabled {
             disabled = other.disabled
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Soa.PaginatorV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.PaginatorV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 16 :
            nextPage = try input.readUInt32()

          case 24 :
            previousPage = try input.readUInt32()

          case 32 :
            count = try input.readUInt32()

          case 40 :
            pageSize = try input.readUInt32()

          case 48 :
            page = try input.readUInt32()

          case 56 :
            totalPages = try input.readUInt32()

          case 64 :
            disabled = try input.readBool()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final public class ActionControlV1 : ExtendableMessage, GeneratedMessageProtocol{
    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasService:Bool = false
    public private(set) var service:String = ""

    public private(set) var hasAction:Bool = false
    public private(set) var action:String = ""

    public private(set) var hasPaginator:Bool = false
    public private(set) var paginator:Soa.PaginatorV1!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasPaginator {
       if !paginator.isInitialized() {
         return false
       }
      }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasService {
        try output.writeString(2, value:service)
      }
      if hasAction {
        try output.writeString(3, value:action)
      }
      if hasPaginator {
        try output.writeMessage(4, value:paginator)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasService {
        serialize_size += service.computeStringSize(2)
      }
      if hasAction {
        serialize_size += action.computeStringSize(3)
      }
      if hasPaginator {
          if let varSizepaginator = paginator?.computeMessageSize(4) {
              serialize_size += varSizepaginator
          }
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Soa.ActionControlV1> {
      var mergedArray = Array<Soa.ActionControlV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Soa.ActionControlV1? {
      return try Soa.ActionControlV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Soa.ActionControlV1 {
      return try Soa.ActionControlV1.Builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionControlV1 {
      return try Soa.ActionControlV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Soa.ActionControlV1 {
      return try Soa.ActionControlV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionControlV1 {
      return try Soa.ActionControlV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Soa.ActionControlV1 {
      return try Soa.ActionControlV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionControlV1 {
      return try Soa.ActionControlV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Soa.ActionControlV1.Builder {
      return Soa.ActionControlV1.classBuilder() as! Soa.ActionControlV1.Builder
    }
    public func getBuilder() -> Soa.ActionControlV1.Builder {
      return classBuilder() as! Soa.ActionControlV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ActionControlV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ActionControlV1.Builder()
    }
    public func toBuilder() throws -> Soa.ActionControlV1.Builder {
      return try Soa.ActionControlV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ActionControlV1) throws -> Soa.ActionControlV1.Builder {
      return try Soa.ActionControlV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasService {
        output += "\(indent) service: \(service) \n"
      }
      if hasAction {
        output += "\(indent) action: \(action) \n"
      }
      if hasPaginator {
        output += "\(indent) paginator {\n"
        try paginator?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      try writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasService {
               hashCode = (hashCode &* 31) &+ service.hashValue
            }
            if hasAction {
               hashCode = (hashCode &* 31) &+ action.hashValue
            }
            if hasPaginator {
                if let hashValuepaginator = paginator?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepaginator
                }
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ActionControlV1"
    }
    override public func className() -> String {
        return "Soa.ActionControlV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ActionControlV1.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Soa.ActionControlV1 = Soa.ActionControlV1()
      public func getMessage() -> Soa.ActionControlV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Soa.ActionControlV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Soa.ActionControlV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
      public var hasService:Bool {
           get {
                return builderResult.hasService
           }
      }
      public var service:String {
           get {
                return builderResult.service
           }
           set (value) {
               builderResult.hasService = true
               builderResult.service = value
           }
      }
      public func setService(value:String) -> Soa.ActionControlV1.Builder {
        self.service = value
        return self
      }
      public func clearService() -> Soa.ActionControlV1.Builder{
           builderResult.hasService = false
           builderResult.service = ""
           return self
      }
      public var hasAction:Bool {
           get {
                return builderResult.hasAction
           }
      }
      public var action:String {
           get {
                return builderResult.action
           }
           set (value) {
               builderResult.hasAction = true
               builderResult.action = value
           }
      }
      public func setAction(value:String) -> Soa.ActionControlV1.Builder {
        self.action = value
        return self
      }
      public func clearAction() -> Soa.ActionControlV1.Builder{
           builderResult.hasAction = false
           builderResult.action = ""
           return self
      }
      public var hasPaginator:Bool {
           get {
               return builderResult.hasPaginator
           }
      }
      public var paginator:Soa.PaginatorV1! {
           get {
               if paginatorBuilder_ != nil {
                  builderResult.paginator = paginatorBuilder_.getMessage()
               }
               return builderResult.paginator
           }
           set (value) {
               builderResult.hasPaginator = true
               builderResult.paginator = value
           }
      }
      private var paginatorBuilder_:Soa.PaginatorV1.Builder! {
           didSet {
              builderResult.hasPaginator = true
           }
      }
      public func getPaginatorBuilder() -> Soa.PaginatorV1.Builder {
        if paginatorBuilder_ == nil {
           paginatorBuilder_ = Soa.PaginatorV1.Builder()
           builderResult.paginator = paginatorBuilder_.getMessage()
           if paginator != nil {
              try! paginatorBuilder_.mergeFrom(paginator)
           }
        }
        return paginatorBuilder_
      }
      public func setPaginator(value:Soa.PaginatorV1!) -> Soa.ActionControlV1.Builder {
        self.paginator = value
        return self
      }
      public func mergePaginator(value:Soa.PaginatorV1) throws -> Soa.ActionControlV1.Builder {
        if builderResult.hasPaginator {
          builderResult.paginator = try Soa.PaginatorV1.builderWithPrototype(builderResult.paginator).mergeFrom(value).buildPartial()
        } else {
          builderResult.paginator = value
        }
        builderResult.hasPaginator = true
        return self
      }
      public func clearPaginator() -> Soa.ActionControlV1.Builder {
        paginatorBuilder_ = nil
        builderResult.hasPaginator = false
        builderResult.paginator = nil
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> Soa.ActionControlV1.Builder {
        builderResult = Soa.ActionControlV1()
        return self
      }
      public override func clone() throws -> Soa.ActionControlV1.Builder {
        return try Soa.ActionControlV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Soa.ActionControlV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Soa.ActionControlV1 {
        let returnMe:Soa.ActionControlV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Soa.ActionControlV1) throws -> Soa.ActionControlV1.Builder {
        if other == Soa.ActionControlV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if other.hasService {
             service = other.service
        }
        if other.hasAction {
             action = other.action
        }
        if (other.hasPaginator) {
            try mergePaginator(other.paginator)
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Soa.ActionControlV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionControlV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 18 :
            service = try input.readString()

          case 26 :
            action = try input.readString()

          case 34 :
            let subBuilder:Soa.PaginatorV1.Builder = Soa.PaginatorV1.Builder()
            if hasPaginator {
              try subBuilder.mergeFrom(paginator)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            paginator = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final public class ActionRequestV1 : ExtendableMessage, GeneratedMessageProtocol{
    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasControl:Bool = false
    public private(set) var control:Soa.ActionControlV1!
    public private(set) var hasParams:Bool = false
    public private(set) var params:Soa.ActionRequestParamsV1!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasControl {
       if !control.isInitialized() {
         return false
       }
      }
      if hasParams {
       if !params.isInitialized() {
         return false
       }
      }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasControl {
        try output.writeMessage(2, value:control)
      }
      if hasParams {
        try output.writeMessage(3, value:params)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasControl {
          if let varSizecontrol = control?.computeMessageSize(2) {
              serialize_size += varSizecontrol
          }
      }
      if hasParams {
          if let varSizeparams = params?.computeMessageSize(3) {
              serialize_size += varSizeparams
          }
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Soa.ActionRequestV1> {
      var mergedArray = Array<Soa.ActionRequestV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Soa.ActionRequestV1? {
      return try Soa.ActionRequestV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Soa.ActionRequestV1 {
      return try Soa.ActionRequestV1.Builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionRequestV1 {
      return try Soa.ActionRequestV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Soa.ActionRequestV1 {
      return try Soa.ActionRequestV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionRequestV1 {
      return try Soa.ActionRequestV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Soa.ActionRequestV1 {
      return try Soa.ActionRequestV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionRequestV1 {
      return try Soa.ActionRequestV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Soa.ActionRequestV1.Builder {
      return Soa.ActionRequestV1.classBuilder() as! Soa.ActionRequestV1.Builder
    }
    public func getBuilder() -> Soa.ActionRequestV1.Builder {
      return classBuilder() as! Soa.ActionRequestV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ActionRequestV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ActionRequestV1.Builder()
    }
    public func toBuilder() throws -> Soa.ActionRequestV1.Builder {
      return try Soa.ActionRequestV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ActionRequestV1) throws -> Soa.ActionRequestV1.Builder {
      return try Soa.ActionRequestV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasControl {
        output += "\(indent) control {\n"
        try control?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasParams {
        output += "\(indent) params {\n"
        try params?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      try writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasControl {
                if let hashValuecontrol = control?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecontrol
                }
            }
            if hasParams {
                if let hashValueparams = params?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueparams
                }
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ActionRequestV1"
    }
    override public func className() -> String {
        return "Soa.ActionRequestV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ActionRequestV1.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Soa.ActionRequestV1 = Soa.ActionRequestV1()
      public func getMessage() -> Soa.ActionRequestV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Soa.ActionRequestV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Soa.ActionRequestV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
      public var hasControl:Bool {
           get {
               return builderResult.hasControl
           }
      }
      public var control:Soa.ActionControlV1! {
           get {
               if controlBuilder_ != nil {
                  builderResult.control = controlBuilder_.getMessage()
               }
               return builderResult.control
           }
           set (value) {
               builderResult.hasControl = true
               builderResult.control = value
           }
      }
      private var controlBuilder_:Soa.ActionControlV1.Builder! {
           didSet {
              builderResult.hasControl = true
           }
      }
      public func getControlBuilder() -> Soa.ActionControlV1.Builder {
        if controlBuilder_ == nil {
           controlBuilder_ = Soa.ActionControlV1.Builder()
           builderResult.control = controlBuilder_.getMessage()
           if control != nil {
              try! controlBuilder_.mergeFrom(control)
           }
        }
        return controlBuilder_
      }
      public func setControl(value:Soa.ActionControlV1!) -> Soa.ActionRequestV1.Builder {
        self.control = value
        return self
      }
      public func mergeControl(value:Soa.ActionControlV1) throws -> Soa.ActionRequestV1.Builder {
        if builderResult.hasControl {
          builderResult.control = try Soa.ActionControlV1.builderWithPrototype(builderResult.control).mergeFrom(value).buildPartial()
        } else {
          builderResult.control = value
        }
        builderResult.hasControl = true
        return self
      }
      public func clearControl() -> Soa.ActionRequestV1.Builder {
        controlBuilder_ = nil
        builderResult.hasControl = false
        builderResult.control = nil
        return self
      }
      public var hasParams:Bool {
           get {
               return builderResult.hasParams
           }
      }
      public var params:Soa.ActionRequestParamsV1! {
           get {
               if paramsBuilder_ != nil {
                  builderResult.params = paramsBuilder_.getMessage()
               }
               return builderResult.params
           }
           set (value) {
               builderResult.hasParams = true
               builderResult.params = value
           }
      }
      private var paramsBuilder_:Soa.ActionRequestParamsV1.Builder! {
           didSet {
              builderResult.hasParams = true
           }
      }
      public func getParamsBuilder() -> Soa.ActionRequestParamsV1.Builder {
        if paramsBuilder_ == nil {
           paramsBuilder_ = Soa.ActionRequestParamsV1.Builder()
           builderResult.params = paramsBuilder_.getMessage()
           if params != nil {
              try! paramsBuilder_.mergeFrom(params)
           }
        }
        return paramsBuilder_
      }
      public func setParams(value:Soa.ActionRequestParamsV1!) -> Soa.ActionRequestV1.Builder {
        self.params = value
        return self
      }
      public func mergeParams(value:Soa.ActionRequestParamsV1) throws -> Soa.ActionRequestV1.Builder {
        if builderResult.hasParams {
          builderResult.params = try Soa.ActionRequestParamsV1.builderWithPrototype(builderResult.params).mergeFrom(value).buildPartial()
        } else {
          builderResult.params = value
        }
        builderResult.hasParams = true
        return self
      }
      public func clearParams() -> Soa.ActionRequestV1.Builder {
        paramsBuilder_ = nil
        builderResult.hasParams = false
        builderResult.params = nil
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> Soa.ActionRequestV1.Builder {
        builderResult = Soa.ActionRequestV1()
        return self
      }
      public override func clone() throws -> Soa.ActionRequestV1.Builder {
        return try Soa.ActionRequestV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Soa.ActionRequestV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Soa.ActionRequestV1 {
        let returnMe:Soa.ActionRequestV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Soa.ActionRequestV1) throws -> Soa.ActionRequestV1.Builder {
        if other == Soa.ActionRequestV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if (other.hasControl) {
            try mergeControl(other.control)
        }
        if (other.hasParams) {
            try mergeParams(other.params)
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Soa.ActionRequestV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionRequestV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 18 :
            let subBuilder:Soa.ActionControlV1.Builder = Soa.ActionControlV1.Builder()
            if hasControl {
              try subBuilder.mergeFrom(control)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            control = subBuilder.buildPartial()

          case 26 :
            let subBuilder:Soa.ActionRequestParamsV1.Builder = Soa.ActionRequestParamsV1.Builder()
            if hasParams {
              try subBuilder.mergeFrom(params)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            params = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final public class ActionRequestParamsV1 : ExtendableMessage, GeneratedMessageProtocol{
    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(100), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Soa.ActionRequestParamsV1> {
      var mergedArray = Array<Soa.ActionRequestParamsV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Soa.ActionRequestParamsV1? {
      return try Soa.ActionRequestParamsV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Soa.ActionRequestParamsV1 {
      return try Soa.ActionRequestParamsV1.Builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionRequestParamsV1 {
      return try Soa.ActionRequestParamsV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Soa.ActionRequestParamsV1 {
      return try Soa.ActionRequestParamsV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionRequestParamsV1 {
      return try Soa.ActionRequestParamsV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Soa.ActionRequestParamsV1 {
      return try Soa.ActionRequestParamsV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionRequestParamsV1 {
      return try Soa.ActionRequestParamsV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Soa.ActionRequestParamsV1.Builder {
      return Soa.ActionRequestParamsV1.classBuilder() as! Soa.ActionRequestParamsV1.Builder
    }
    public func getBuilder() -> Soa.ActionRequestParamsV1.Builder {
      return classBuilder() as! Soa.ActionRequestParamsV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ActionRequestParamsV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ActionRequestParamsV1.Builder()
    }
    public func toBuilder() throws -> Soa.ActionRequestParamsV1.Builder {
      return try Soa.ActionRequestParamsV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ActionRequestParamsV1) throws -> Soa.ActionRequestParamsV1.Builder {
      return try Soa.ActionRequestParamsV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      try writeExtensionDescription(&output, startInclusive:Int32(100), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(100), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ActionRequestParamsV1"
    }
    override public func className() -> String {
        return "Soa.ActionRequestParamsV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ActionRequestParamsV1.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Soa.ActionRequestParamsV1 = Soa.ActionRequestParamsV1()
      public func getMessage() -> Soa.ActionRequestParamsV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Soa.ActionRequestParamsV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Soa.ActionRequestParamsV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> Soa.ActionRequestParamsV1.Builder {
        builderResult = Soa.ActionRequestParamsV1()
        return self
      }
      public override func clone() throws -> Soa.ActionRequestParamsV1.Builder {
        return try Soa.ActionRequestParamsV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Soa.ActionRequestParamsV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Soa.ActionRequestParamsV1 {
        let returnMe:Soa.ActionRequestParamsV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Soa.ActionRequestParamsV1) throws -> Soa.ActionRequestParamsV1.Builder {
        if other == Soa.ActionRequestParamsV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Soa.ActionRequestParamsV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionRequestParamsV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final public class ActionResultV1 : ExtendableMessage, GeneratedMessageProtocol{


    //Nested type declaration start

      final public class ErrorDetailV1 : GeneratedMessage, GeneratedMessageProtocol {
        public private(set) var hasVersion:Bool = false
        public private(set) var version:UInt32 = UInt32(1)

        public private(set) var hasError:Bool = false
        public private(set) var error:String = ""

        public private(set) var hasKey:Bool = false
        public private(set) var key:String = ""

        public private(set) var hasDetail:Bool = false
        public private(set) var detail:String = ""

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
          if hasVersion {
            try output.writeUInt32(1, value:version)
          }
          if hasError {
            try output.writeString(2, value:error)
          }
          if hasKey {
            try output.writeString(3, value:key)
          }
          if hasDetail {
            try output.writeString(4, value:detail)
          }
          try unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasVersion {
            serialize_size += version.computeUInt32Size(1)
          }
          if hasError {
            serialize_size += error.computeStringSize(2)
          }
          if hasKey {
            serialize_size += key.computeStringSize(3)
          }
          if hasDetail {
            serialize_size += detail.computeStringSize(4)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Soa.ActionResultV1.ErrorDetailV1> {
          var mergedArray = Array<Soa.ActionResultV1.ErrorDetailV1>()
          while let value = try parseFromDelimitedFromInputStream(input) {
            mergedArray += [value]
          }
          return mergedArray
        }
        public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Soa.ActionResultV1.ErrorDetailV1? {
          return try Soa.ActionResultV1.ErrorDetailV1.Builder().mergeDelimitedFromInputStream(input)?.build()
        }
        public class func parseFromData(data:NSData) throws -> Soa.ActionResultV1.ErrorDetailV1 {
          return try Soa.ActionResultV1.ErrorDetailV1.Builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionResultV1.ErrorDetailV1 {
          return try Soa.ActionResultV1.ErrorDetailV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) throws -> Soa.ActionResultV1.ErrorDetailV1 {
          return try Soa.ActionResultV1.ErrorDetailV1.Builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionResultV1.ErrorDetailV1 {
          return try Soa.ActionResultV1.ErrorDetailV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Soa.ActionResultV1.ErrorDetailV1 {
          return try Soa.ActionResultV1.ErrorDetailV1.Builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionResultV1.ErrorDetailV1 {
          return try Soa.ActionResultV1.ErrorDetailV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func getBuilder() -> Soa.ActionResultV1.ErrorDetailV1.Builder {
          return Soa.ActionResultV1.ErrorDetailV1.classBuilder() as! Soa.ActionResultV1.ErrorDetailV1.Builder
        }
        public func getBuilder() -> Soa.ActionResultV1.ErrorDetailV1.Builder {
          return classBuilder() as! Soa.ActionResultV1.ErrorDetailV1.Builder
        }
        public override class func classBuilder() -> MessageBuilder {
          return Soa.ActionResultV1.ErrorDetailV1.Builder()
        }
        public override func classBuilder() -> MessageBuilder {
          return Soa.ActionResultV1.ErrorDetailV1.Builder()
        }
        public func toBuilder() throws -> Soa.ActionResultV1.ErrorDetailV1.Builder {
          return try Soa.ActionResultV1.ErrorDetailV1.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:Soa.ActionResultV1.ErrorDetailV1) throws -> Soa.ActionResultV1.ErrorDetailV1.Builder {
          return try Soa.ActionResultV1.ErrorDetailV1.Builder().mergeFrom(prototype)
        }
        override public func writeDescriptionTo(inout output:String, indent:String) throws {
          if hasVersion {
            output += "\(indent) version: \(version) \n"
          }
          if hasError {
            output += "\(indent) error: \(error) \n"
          }
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if hasDetail {
            output += "\(indent) detail: \(detail) \n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasVersion {
                   hashCode = (hashCode &* 31) &+ version.hashValue
                }
                if hasError {
                   hashCode = (hashCode &* 31) &+ error.hashValue
                }
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasDetail {
                   hashCode = (hashCode &* 31) &+ detail.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Soa.ActionResultV1.ErrorDetailV1"
        }
        override public func className() -> String {
            return "Soa.ActionResultV1.ErrorDetailV1"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return Soa.ActionResultV1.ErrorDetailV1.self
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
          private var builderResult:Soa.ActionResultV1.ErrorDetailV1 = Soa.ActionResultV1.ErrorDetailV1()
          public func getMessage() -> Soa.ActionResultV1.ErrorDetailV1 {
              return builderResult
          }

          required override public init () {
             super.init()
          }
          public var hasVersion:Bool {
               get {
                    return builderResult.hasVersion
               }
          }
          public var version:UInt32 {
               get {
                    return builderResult.version
               }
               set (value) {
                   builderResult.hasVersion = true
                   builderResult.version = value
               }
          }
          public func setVersion(value:UInt32) -> Soa.ActionResultV1.ErrorDetailV1.Builder {
            self.version = value
            return self
          }
          public func clearVersion() -> Soa.ActionResultV1.ErrorDetailV1.Builder{
               builderResult.hasVersion = false
               builderResult.version = UInt32(1)
               return self
          }
          public var hasError:Bool {
               get {
                    return builderResult.hasError
               }
          }
          public var error:String {
               get {
                    return builderResult.error
               }
               set (value) {
                   builderResult.hasError = true
                   builderResult.error = value
               }
          }
          public func setError(value:String) -> Soa.ActionResultV1.ErrorDetailV1.Builder {
            self.error = value
            return self
          }
          public func clearError() -> Soa.ActionResultV1.ErrorDetailV1.Builder{
               builderResult.hasError = false
               builderResult.error = ""
               return self
          }
          public var hasKey:Bool {
               get {
                    return builderResult.hasKey
               }
          }
          public var key:String {
               get {
                    return builderResult.key
               }
               set (value) {
                   builderResult.hasKey = true
                   builderResult.key = value
               }
          }
          public func setKey(value:String) -> Soa.ActionResultV1.ErrorDetailV1.Builder {
            self.key = value
            return self
          }
          public func clearKey() -> Soa.ActionResultV1.ErrorDetailV1.Builder{
               builderResult.hasKey = false
               builderResult.key = ""
               return self
          }
          public var hasDetail:Bool {
               get {
                    return builderResult.hasDetail
               }
          }
          public var detail:String {
               get {
                    return builderResult.detail
               }
               set (value) {
                   builderResult.hasDetail = true
                   builderResult.detail = value
               }
          }
          public func setDetail(value:String) -> Soa.ActionResultV1.ErrorDetailV1.Builder {
            self.detail = value
            return self
          }
          public func clearDetail() -> Soa.ActionResultV1.ErrorDetailV1.Builder{
               builderResult.hasDetail = false
               builderResult.detail = ""
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          public override func clear() -> Soa.ActionResultV1.ErrorDetailV1.Builder {
            builderResult = Soa.ActionResultV1.ErrorDetailV1()
            return self
          }
          public override func clone() throws -> Soa.ActionResultV1.ErrorDetailV1.Builder {
            return try Soa.ActionResultV1.ErrorDetailV1.builderWithPrototype(builderResult)
          }
          public override func build() throws -> Soa.ActionResultV1.ErrorDetailV1 {
               try checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> Soa.ActionResultV1.ErrorDetailV1 {
            let returnMe:Soa.ActionResultV1.ErrorDetailV1 = builderResult
            return returnMe
          }
          public func mergeFrom(other:Soa.ActionResultV1.ErrorDetailV1) throws -> Soa.ActionResultV1.ErrorDetailV1.Builder {
            if other == Soa.ActionResultV1.ErrorDetailV1() {
             return self
            }
            if other.hasVersion {
                 version = other.version
            }
            if other.hasError {
                 error = other.error
            }
            if other.hasKey {
                 key = other.key
            }
            if other.hasDetail {
                 detail = other.detail
            }
            try mergeUnknownFields(other.unknownFields)
            return self
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Soa.ActionResultV1.ErrorDetailV1.Builder {
               return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionResultV1.ErrorDetailV1.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              let tag = try input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = try unknownFieldsBuilder.build()
                return self

              case 8 :
                version = try input.readUInt32()

              case 18 :
                error = try input.readString()

              case 26 :
                key = try input.readString()

              case 34 :
                detail = try input.readString()

              default:
                if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
                   unknownFields = try unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }

      }

    //Nested type declaration end

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasSuccess:Bool = false
    public private(set) var success:Bool = false

    public private(set) var errors:Array<String> = Array<String>()
    public private(set) var errorDetails:Array<Soa.ActionResultV1.ErrorDetailV1>  = Array<Soa.ActionResultV1.ErrorDetailV1>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasSuccess {
        try output.writeBool(2, value:success)
      }
      if !errors.isEmpty {
        for oneValueerrors in errors {
          try output.writeString(3, value:oneValueerrors)
        }
      }
      for oneElementerrorDetails in errorDetails {
          try output.writeMessage(4, value:oneElementerrorDetails)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(100), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasSuccess {
        serialize_size += success.computeBoolSize(2)
      }
      var dataSizeErrors:Int32 = 0
      for oneValueerrors in errors {
          dataSizeErrors += oneValueerrors.computeStringSizeNoTag()
      }
      serialize_size += dataSizeErrors
      serialize_size += 1 * Int32(errors.count)
      for oneElementerrorDetails in errorDetails {
          serialize_size += oneElementerrorDetails.computeMessageSize(4)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Soa.ActionResultV1> {
      var mergedArray = Array<Soa.ActionResultV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Soa.ActionResultV1? {
      return try Soa.ActionResultV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Soa.ActionResultV1 {
      return try Soa.ActionResultV1.Builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionResultV1 {
      return try Soa.ActionResultV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Soa.ActionResultV1 {
      return try Soa.ActionResultV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionResultV1 {
      return try Soa.ActionResultV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Soa.ActionResultV1 {
      return try Soa.ActionResultV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionResultV1 {
      return try Soa.ActionResultV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Soa.ActionResultV1.Builder {
      return Soa.ActionResultV1.classBuilder() as! Soa.ActionResultV1.Builder
    }
    public func getBuilder() -> Soa.ActionResultV1.Builder {
      return classBuilder() as! Soa.ActionResultV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ActionResultV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ActionResultV1.Builder()
    }
    public func toBuilder() throws -> Soa.ActionResultV1.Builder {
      return try Soa.ActionResultV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ActionResultV1) throws -> Soa.ActionResultV1.Builder {
      return try Soa.ActionResultV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      var errorsElementIndex:Int = 0
      for oneValueerrors in errors  {
          output += "\(indent) errors[\(errorsElementIndex)]: \(oneValueerrors)\n"
          errorsElementIndex++
      }
      var errorDetailsElementIndex:Int = 0
      for oneElementerrorDetails in errorDetails {
          output += "\(indent) errorDetails[\(errorDetailsElementIndex)] {\n"
          try oneElementerrorDetails.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          errorDetailsElementIndex++
      }
      try writeExtensionDescription(&output, startInclusive:Int32(100), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            for oneValueerrors in errors {
                hashCode = (hashCode &* 31) &+ oneValueerrors.hashValue
            }
            for oneElementerrorDetails in errorDetails {
                hashCode = (hashCode &* 31) &+ oneElementerrorDetails.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(100), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ActionResultV1"
    }
    override public func className() -> String {
        return "Soa.ActionResultV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ActionResultV1.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Soa.ActionResultV1 = Soa.ActionResultV1()
      public func getMessage() -> Soa.ActionResultV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Soa.ActionResultV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Soa.ActionResultV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
      public var hasSuccess:Bool {
           get {
                return builderResult.hasSuccess
           }
      }
      public var success:Bool {
           get {
                return builderResult.success
           }
           set (value) {
               builderResult.hasSuccess = true
               builderResult.success = value
           }
      }
      public func setSuccess(value:Bool) -> Soa.ActionResultV1.Builder {
        self.success = value
        return self
      }
      public func clearSuccess() -> Soa.ActionResultV1.Builder{
           builderResult.hasSuccess = false
           builderResult.success = false
           return self
      }
      public var errors:Array<String> {
           get {
               return builderResult.errors
           }
           set (array) {
               builderResult.errors = array
           }
      }
      public func setErrors(value:Array<String>) -> Soa.ActionResultV1.Builder {
        self.errors = value
        return self
      }
      public func clearErrors() -> Soa.ActionResultV1.Builder {
         builderResult.errors.removeAll(keepCapacity: false)
         return self
      }
      public var errorDetails:Array<Soa.ActionResultV1.ErrorDetailV1> {
           get {
               return builderResult.errorDetails
           }
           set (value) {
               builderResult.errorDetails = value
           }
      }
      public func setErrorDetails(value:Array<Soa.ActionResultV1.ErrorDetailV1>) -> Soa.ActionResultV1.Builder {
        self.errorDetails = value
        return self
      }
      public func clearErrorDetails() -> Soa.ActionResultV1.Builder {
        builderResult.errorDetails.removeAll(keepCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> Soa.ActionResultV1.Builder {
        builderResult = Soa.ActionResultV1()
        return self
      }
      public override func clone() throws -> Soa.ActionResultV1.Builder {
        return try Soa.ActionResultV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Soa.ActionResultV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Soa.ActionResultV1 {
        let returnMe:Soa.ActionResultV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Soa.ActionResultV1) throws -> Soa.ActionResultV1.Builder {
        if other == Soa.ActionResultV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if other.hasSuccess {
             success = other.success
        }
        if !other.errors.isEmpty {
            builderResult.errors += other.errors
        }
        if !other.errorDetails.isEmpty  {
           builderResult.errorDetails += other.errorDetails
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Soa.ActionResultV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionResultV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 16 :
            success = try input.readBool()

          case 26 :
            errors += [try input.readString()]

          case 34 :
            let subBuilder = Soa.ActionResultV1.ErrorDetailV1.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            errorDetails += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final public class ActionResponseV1 : ExtendableMessage, GeneratedMessageProtocol{
    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasControl:Bool = false
    public private(set) var control:Soa.ActionControlV1!
    public private(set) var hasResult:Bool = false
    public private(set) var result:Soa.ActionResultV1!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasControl {
       if !control.isInitialized() {
         return false
       }
      }
      if hasResult {
       if !result.isInitialized() {
         return false
       }
      }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasControl {
        try output.writeMessage(2, value:control)
      }
      if hasResult {
        try output.writeMessage(3, value:result)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasControl {
          if let varSizecontrol = control?.computeMessageSize(2) {
              serialize_size += varSizecontrol
          }
      }
      if hasResult {
          if let varSizeresult = result?.computeMessageSize(3) {
              serialize_size += varSizeresult
          }
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Soa.ActionResponseV1> {
      var mergedArray = Array<Soa.ActionResponseV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Soa.ActionResponseV1? {
      return try Soa.ActionResponseV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Soa.ActionResponseV1 {
      return try Soa.ActionResponseV1.Builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionResponseV1 {
      return try Soa.ActionResponseV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Soa.ActionResponseV1 {
      return try Soa.ActionResponseV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionResponseV1 {
      return try Soa.ActionResponseV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Soa.ActionResponseV1 {
      return try Soa.ActionResponseV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionResponseV1 {
      return try Soa.ActionResponseV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Soa.ActionResponseV1.Builder {
      return Soa.ActionResponseV1.classBuilder() as! Soa.ActionResponseV1.Builder
    }
    public func getBuilder() -> Soa.ActionResponseV1.Builder {
      return classBuilder() as! Soa.ActionResponseV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ActionResponseV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ActionResponseV1.Builder()
    }
    public func toBuilder() throws -> Soa.ActionResponseV1.Builder {
      return try Soa.ActionResponseV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ActionResponseV1) throws -> Soa.ActionResponseV1.Builder {
      return try Soa.ActionResponseV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasControl {
        output += "\(indent) control {\n"
        try control?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasResult {
        output += "\(indent) result {\n"
        try result?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      try writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasControl {
                if let hashValuecontrol = control?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecontrol
                }
            }
            if hasResult {
                if let hashValueresult = result?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueresult
                }
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ActionResponseV1"
    }
    override public func className() -> String {
        return "Soa.ActionResponseV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ActionResponseV1.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Soa.ActionResponseV1 = Soa.ActionResponseV1()
      public func getMessage() -> Soa.ActionResponseV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Soa.ActionResponseV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Soa.ActionResponseV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
      public var hasControl:Bool {
           get {
               return builderResult.hasControl
           }
      }
      public var control:Soa.ActionControlV1! {
           get {
               if controlBuilder_ != nil {
                  builderResult.control = controlBuilder_.getMessage()
               }
               return builderResult.control
           }
           set (value) {
               builderResult.hasControl = true
               builderResult.control = value
           }
      }
      private var controlBuilder_:Soa.ActionControlV1.Builder! {
           didSet {
              builderResult.hasControl = true
           }
      }
      public func getControlBuilder() -> Soa.ActionControlV1.Builder {
        if controlBuilder_ == nil {
           controlBuilder_ = Soa.ActionControlV1.Builder()
           builderResult.control = controlBuilder_.getMessage()
           if control != nil {
              try! controlBuilder_.mergeFrom(control)
           }
        }
        return controlBuilder_
      }
      public func setControl(value:Soa.ActionControlV1!) -> Soa.ActionResponseV1.Builder {
        self.control = value
        return self
      }
      public func mergeControl(value:Soa.ActionControlV1) throws -> Soa.ActionResponseV1.Builder {
        if builderResult.hasControl {
          builderResult.control = try Soa.ActionControlV1.builderWithPrototype(builderResult.control).mergeFrom(value).buildPartial()
        } else {
          builderResult.control = value
        }
        builderResult.hasControl = true
        return self
      }
      public func clearControl() -> Soa.ActionResponseV1.Builder {
        controlBuilder_ = nil
        builderResult.hasControl = false
        builderResult.control = nil
        return self
      }
      public var hasResult:Bool {
           get {
               return builderResult.hasResult
           }
      }
      public var result:Soa.ActionResultV1! {
           get {
               if resultBuilder_ != nil {
                  builderResult.result = resultBuilder_.getMessage()
               }
               return builderResult.result
           }
           set (value) {
               builderResult.hasResult = true
               builderResult.result = value
           }
      }
      private var resultBuilder_:Soa.ActionResultV1.Builder! {
           didSet {
              builderResult.hasResult = true
           }
      }
      public func getResultBuilder() -> Soa.ActionResultV1.Builder {
        if resultBuilder_ == nil {
           resultBuilder_ = Soa.ActionResultV1.Builder()
           builderResult.result = resultBuilder_.getMessage()
           if result != nil {
              try! resultBuilder_.mergeFrom(result)
           }
        }
        return resultBuilder_
      }
      public func setResult(value:Soa.ActionResultV1!) -> Soa.ActionResponseV1.Builder {
        self.result = value
        return self
      }
      public func mergeResult(value:Soa.ActionResultV1) throws -> Soa.ActionResponseV1.Builder {
        if builderResult.hasResult {
          builderResult.result = try Soa.ActionResultV1.builderWithPrototype(builderResult.result).mergeFrom(value).buildPartial()
        } else {
          builderResult.result = value
        }
        builderResult.hasResult = true
        return self
      }
      public func clearResult() -> Soa.ActionResponseV1.Builder {
        resultBuilder_ = nil
        builderResult.hasResult = false
        builderResult.result = nil
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> Soa.ActionResponseV1.Builder {
        builderResult = Soa.ActionResponseV1()
        return self
      }
      public override func clone() throws -> Soa.ActionResponseV1.Builder {
        return try Soa.ActionResponseV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Soa.ActionResponseV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Soa.ActionResponseV1 {
        let returnMe:Soa.ActionResponseV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Soa.ActionResponseV1) throws -> Soa.ActionResponseV1.Builder {
        if other == Soa.ActionResponseV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if (other.hasControl) {
            try mergeControl(other.control)
        }
        if (other.hasResult) {
            try mergeResult(other.result)
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Soa.ActionResponseV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ActionResponseV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 18 :
            let subBuilder:Soa.ActionControlV1.Builder = Soa.ActionControlV1.Builder()
            if hasControl {
              try subBuilder.mergeFrom(control)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            control = subBuilder.buildPartial()

          case 26 :
            let subBuilder:Soa.ActionResultV1.Builder = Soa.ActionResultV1.Builder()
            if hasResult {
              try subBuilder.mergeFrom(result)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            result = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final public class ServiceRequestV1 : ExtendableMessage, GeneratedMessageProtocol{
    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasControl:Bool = false
    public private(set) var control:Soa.ControlV1!
    public private(set) var actions:Array<Soa.ActionRequestV1>  = Array<Soa.ActionRequestV1>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasControl {
       if !control.isInitialized() {
         return false
       }
      }
      var isInitactions:Bool = true
      for oneElementactions in actions {
          if (!oneElementactions.isInitialized()) {
              isInitactions = false
              break 
          }
      }
      if !isInitactions {
       return isInitactions
       }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasControl {
        try output.writeMessage(2, value:control)
      }
      for oneElementactions in actions {
          try output.writeMessage(3, value:oneElementactions)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasControl {
          if let varSizecontrol = control?.computeMessageSize(2) {
              serialize_size += varSizecontrol
          }
      }
      for oneElementactions in actions {
          serialize_size += oneElementactions.computeMessageSize(3)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Soa.ServiceRequestV1> {
      var mergedArray = Array<Soa.ServiceRequestV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Soa.ServiceRequestV1? {
      return try Soa.ServiceRequestV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Soa.ServiceRequestV1 {
      return try Soa.ServiceRequestV1.Builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Soa.ServiceRequestV1 {
      return try Soa.ServiceRequestV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Soa.ServiceRequestV1 {
      return try Soa.ServiceRequestV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ServiceRequestV1 {
      return try Soa.ServiceRequestV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Soa.ServiceRequestV1 {
      return try Soa.ServiceRequestV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ServiceRequestV1 {
      return try Soa.ServiceRequestV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Soa.ServiceRequestV1.Builder {
      return Soa.ServiceRequestV1.classBuilder() as! Soa.ServiceRequestV1.Builder
    }
    public func getBuilder() -> Soa.ServiceRequestV1.Builder {
      return classBuilder() as! Soa.ServiceRequestV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ServiceRequestV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ServiceRequestV1.Builder()
    }
    public func toBuilder() throws -> Soa.ServiceRequestV1.Builder {
      return try Soa.ServiceRequestV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ServiceRequestV1) throws -> Soa.ServiceRequestV1.Builder {
      return try Soa.ServiceRequestV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasControl {
        output += "\(indent) control {\n"
        try control?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      var actionsElementIndex:Int = 0
      for oneElementactions in actions {
          output += "\(indent) actions[\(actionsElementIndex)] {\n"
          try oneElementactions.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          actionsElementIndex++
      }
      try writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasControl {
                if let hashValuecontrol = control?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecontrol
                }
            }
            for oneElementactions in actions {
                hashCode = (hashCode &* 31) &+ oneElementactions.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ServiceRequestV1"
    }
    override public func className() -> String {
        return "Soa.ServiceRequestV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ServiceRequestV1.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Soa.ServiceRequestV1 = Soa.ServiceRequestV1()
      public func getMessage() -> Soa.ServiceRequestV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Soa.ServiceRequestV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Soa.ServiceRequestV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
      public var hasControl:Bool {
           get {
               return builderResult.hasControl
           }
      }
      public var control:Soa.ControlV1! {
           get {
               if controlBuilder_ != nil {
                  builderResult.control = controlBuilder_.getMessage()
               }
               return builderResult.control
           }
           set (value) {
               builderResult.hasControl = true
               builderResult.control = value
           }
      }
      private var controlBuilder_:Soa.ControlV1.Builder! {
           didSet {
              builderResult.hasControl = true
           }
      }
      public func getControlBuilder() -> Soa.ControlV1.Builder {
        if controlBuilder_ == nil {
           controlBuilder_ = Soa.ControlV1.Builder()
           builderResult.control = controlBuilder_.getMessage()
           if control != nil {
              try! controlBuilder_.mergeFrom(control)
           }
        }
        return controlBuilder_
      }
      public func setControl(value:Soa.ControlV1!) -> Soa.ServiceRequestV1.Builder {
        self.control = value
        return self
      }
      public func mergeControl(value:Soa.ControlV1) throws -> Soa.ServiceRequestV1.Builder {
        if builderResult.hasControl {
          builderResult.control = try Soa.ControlV1.builderWithPrototype(builderResult.control).mergeFrom(value).buildPartial()
        } else {
          builderResult.control = value
        }
        builderResult.hasControl = true
        return self
      }
      public func clearControl() -> Soa.ServiceRequestV1.Builder {
        controlBuilder_ = nil
        builderResult.hasControl = false
        builderResult.control = nil
        return self
      }
      public var actions:Array<Soa.ActionRequestV1> {
           get {
               return builderResult.actions
           }
           set (value) {
               builderResult.actions = value
           }
      }
      public func setActions(value:Array<Soa.ActionRequestV1>) -> Soa.ServiceRequestV1.Builder {
        self.actions = value
        return self
      }
      public func clearActions() -> Soa.ServiceRequestV1.Builder {
        builderResult.actions.removeAll(keepCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> Soa.ServiceRequestV1.Builder {
        builderResult = Soa.ServiceRequestV1()
        return self
      }
      public override func clone() throws -> Soa.ServiceRequestV1.Builder {
        return try Soa.ServiceRequestV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Soa.ServiceRequestV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Soa.ServiceRequestV1 {
        let returnMe:Soa.ServiceRequestV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Soa.ServiceRequestV1) throws -> Soa.ServiceRequestV1.Builder {
        if other == Soa.ServiceRequestV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if (other.hasControl) {
            try mergeControl(other.control)
        }
        if !other.actions.isEmpty  {
           builderResult.actions += other.actions
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Soa.ServiceRequestV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ServiceRequestV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 18 :
            let subBuilder:Soa.ControlV1.Builder = Soa.ControlV1.Builder()
            if hasControl {
              try subBuilder.mergeFrom(control)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            control = subBuilder.buildPartial()

          case 26 :
            let subBuilder = Soa.ActionRequestV1.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            actions += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final public class ServiceResponseV1 : ExtendableMessage, GeneratedMessageProtocol{
    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasControl:Bool = false
    public private(set) var control:Soa.ControlV1!
    public private(set) var actions:Array<Soa.ActionResponseV1>  = Array<Soa.ActionResponseV1>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasControl {
       if !control.isInitialized() {
         return false
       }
      }
      var isInitactions:Bool = true
      for oneElementactions in actions {
          if (!oneElementactions.isInitialized()) {
              isInitactions = false
              break 
          }
      }
      if !isInitactions {
       return isInitactions
       }
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasControl {
        try output.writeMessage(2, value:control)
      }
      for oneElementactions in actions {
          try output.writeMessage(3, value:oneElementactions)
      }
      try writeExtensionsToCodedOutputStream(output, startInclusive:Int32(1000), endExclusive:Int32(536870912))
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasControl {
          if let varSizecontrol = control?.computeMessageSize(2) {
              serialize_size += varSizecontrol
          }
      }
      for oneElementactions in actions {
          serialize_size += oneElementactions.computeMessageSize(3)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Soa.ServiceResponseV1> {
      var mergedArray = Array<Soa.ServiceResponseV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Soa.ServiceResponseV1? {
      return try Soa.ServiceResponseV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Soa.ServiceResponseV1 {
      return try Soa.ServiceResponseV1.Builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Soa.ServiceResponseV1 {
      return try Soa.ServiceResponseV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Soa.ServiceResponseV1 {
      return try Soa.ServiceResponseV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ServiceResponseV1 {
      return try Soa.ServiceResponseV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Soa.ServiceResponseV1 {
      return try Soa.ServiceResponseV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ServiceResponseV1 {
      return try Soa.ServiceResponseV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Soa.ServiceResponseV1.Builder {
      return Soa.ServiceResponseV1.classBuilder() as! Soa.ServiceResponseV1.Builder
    }
    public func getBuilder() -> Soa.ServiceResponseV1.Builder {
      return classBuilder() as! Soa.ServiceResponseV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ServiceResponseV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ServiceResponseV1.Builder()
    }
    public func toBuilder() throws -> Soa.ServiceResponseV1.Builder {
      return try Soa.ServiceResponseV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ServiceResponseV1) throws -> Soa.ServiceResponseV1.Builder {
      return try Soa.ServiceResponseV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasControl {
        output += "\(indent) control {\n"
        try control?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      var actionsElementIndex:Int = 0
      for oneElementactions in actions {
          output += "\(indent) actions[\(actionsElementIndex)] {\n"
          try oneElementactions.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          actionsElementIndex++
      }
      try writeExtensionDescription(&output, startInclusive:Int32(1000), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasControl {
                if let hashValuecontrol = control?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecontrol
                }
            }
            for oneElementactions in actions {
                hashCode = (hashCode &* 31) &+ oneElementactions.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(1000), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ServiceResponseV1"
    }
    override public func className() -> String {
        return "Soa.ServiceResponseV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ServiceResponseV1.self
    }
    //Meta information declaration end

    final public class Builder : ExtendableMessageBuilder {
      private var builderResult:Soa.ServiceResponseV1 = Soa.ServiceResponseV1()
      public func getMessage() -> Soa.ServiceResponseV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Soa.ServiceResponseV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Soa.ServiceResponseV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
      public var hasControl:Bool {
           get {
               return builderResult.hasControl
           }
      }
      public var control:Soa.ControlV1! {
           get {
               if controlBuilder_ != nil {
                  builderResult.control = controlBuilder_.getMessage()
               }
               return builderResult.control
           }
           set (value) {
               builderResult.hasControl = true
               builderResult.control = value
           }
      }
      private var controlBuilder_:Soa.ControlV1.Builder! {
           didSet {
              builderResult.hasControl = true
           }
      }
      public func getControlBuilder() -> Soa.ControlV1.Builder {
        if controlBuilder_ == nil {
           controlBuilder_ = Soa.ControlV1.Builder()
           builderResult.control = controlBuilder_.getMessage()
           if control != nil {
              try! controlBuilder_.mergeFrom(control)
           }
        }
        return controlBuilder_
      }
      public func setControl(value:Soa.ControlV1!) -> Soa.ServiceResponseV1.Builder {
        self.control = value
        return self
      }
      public func mergeControl(value:Soa.ControlV1) throws -> Soa.ServiceResponseV1.Builder {
        if builderResult.hasControl {
          builderResult.control = try Soa.ControlV1.builderWithPrototype(builderResult.control).mergeFrom(value).buildPartial()
        } else {
          builderResult.control = value
        }
        builderResult.hasControl = true
        return self
      }
      public func clearControl() -> Soa.ServiceResponseV1.Builder {
        controlBuilder_ = nil
        builderResult.hasControl = false
        builderResult.control = nil
        return self
      }
      public var actions:Array<Soa.ActionResponseV1> {
           get {
               return builderResult.actions
           }
           set (value) {
               builderResult.actions = value
           }
      }
      public func setActions(value:Array<Soa.ActionResponseV1>) -> Soa.ServiceResponseV1.Builder {
        self.actions = value
        return self
      }
      public func clearActions() -> Soa.ServiceResponseV1.Builder {
        builderResult.actions.removeAll(keepCapacity: false)
        return self
      }
      override public var internalGetResult:ExtendableMessage {
           get {
               return builderResult
           }
      }
      public override func clear() -> Soa.ServiceResponseV1.Builder {
        builderResult = Soa.ServiceResponseV1()
        return self
      }
      public override func clone() throws -> Soa.ServiceResponseV1.Builder {
        return try Soa.ServiceResponseV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Soa.ServiceResponseV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Soa.ServiceResponseV1 {
        let returnMe:Soa.ServiceResponseV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Soa.ServiceResponseV1) throws -> Soa.ServiceResponseV1.Builder {
        if other == Soa.ServiceResponseV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if (other.hasControl) {
            try mergeControl(other.control)
        }
        if !other.actions.isEmpty  {
           builderResult.actions += other.actions
        }
        try mergeExtensionFields(other)
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Soa.ServiceResponseV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Soa.ServiceResponseV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 18 :
            let subBuilder:Soa.ControlV1.Builder = Soa.ControlV1.Builder()
            if hasControl {
              try subBuilder.mergeFrom(control)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            control = subBuilder.buildPartial()

          case 26 :
            let subBuilder = Soa.ActionResponseV1.Builder()
            try input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
            actions += [subBuilder.buildPartial()]

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

}

// @@protoc_insertion_point(global_scope)
