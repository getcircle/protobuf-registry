// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation

public struct SoaRoot {
  public static var sharedInstance : SoaRoot {
   struct Static {
       static let instance : SoaRoot = SoaRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
  }
  public func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

public func == (lhs: Control, rhs: Control) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasToken == rhs.hasToken) && (!lhs.hasToken || lhs.token == rhs.token)
  fieldCheck = fieldCheck && (lhs.hasService == rhs.hasService) && (!lhs.hasService || lhs.service == rhs.service)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: ActionControl, rhs: ActionControl) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasService == rhs.hasService) && (!lhs.hasService || lhs.service == rhs.service)
  fieldCheck = fieldCheck && (lhs.hasAction == rhs.hasAction) && (!lhs.hasAction || lhs.action == rhs.action)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: ActionRequest, rhs: ActionRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasControl == rhs.hasControl) && (!lhs.hasControl || lhs.control == rhs.control)
  fieldCheck = fieldCheck && (lhs.hasParams == rhs.hasParams) && (!lhs.hasParams || lhs.params == rhs.params)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: ActionRequestParams, rhs: ActionRequestParams) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(100), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: ActionResponseResult.ErrorDetail, rhs: ActionResponseResult.ErrorDetail) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasError == rhs.hasError) && (!lhs.hasError || lhs.error == rhs.error)
  fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
  fieldCheck = fieldCheck && (lhs.hasDetail == rhs.hasDetail) && (!lhs.hasDetail || lhs.detail == rhs.detail)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: ActionResponseResult, rhs: ActionResponseResult) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.errors == rhs.errors)
  fieldCheck = fieldCheck && (lhs.error_details == rhs.error_details)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(100), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: ActionResponse, rhs: ActionResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasControl == rhs.hasControl) && (!lhs.hasControl || lhs.control == rhs.control)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: ServiceRequest, rhs: ServiceRequest) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasControl == rhs.hasControl) && (!lhs.hasControl || lhs.control == rhs.control)
  fieldCheck = fieldCheck && (lhs.actions == rhs.actions)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: ServiceResponse, rhs: ServiceResponse) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasControl == rhs.hasControl) && (!lhs.hasControl || lhs.control == rhs.control)
  fieldCheck = fieldCheck && (lhs.actions == rhs.actions)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

final public class Control : GeneratedMessage {
  public subscript(key: String) -> Any? {
         switch key {
         case "token": return token
         case "service": return service
         default: return nil
         }
  }

  public private(set) var hasToken:Bool = false
  public private(set) var token:String = ""

  public private(set) var hasService:Bool = false
  public private(set) var service:String = ""

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasService {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasToken {
      output.writeString(1, value:token)
    }
    if hasService {
      output.writeString(2, value:service)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasToken {
      size += WireFormat.computeStringSize(1, value:token)
    }
    if hasService {
      size += WireFormat.computeStringSize(2, value:service)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  public class func parseFromData(data:[Byte]) -> Control {
    return Control.builder().mergeFromData(data).build()
  }
  public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> Control {
    return Control.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) -> Control {
    return Control.builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Control {
    return Control.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) -> Control {
    return Control.builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Control {
    return Control.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func builder() -> ControlBuilder {
    return Control.classBuilder() as ControlBuilder
  }
  public func builder() -> ControlBuilder {
    return classBuilder() as ControlBuilder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ControlBuilder()
  }
  public override func classBuilder() -> MessageBuilder {
    return Control.builder()
  }
  public func toBuilder() -> ControlBuilder {
    return Control.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:Control) -> ControlBuilder {
    return Control.builder().mergeFrom(prototype)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasToken {
      output += "\(indent) token: \(token) \n"
    }
    if hasService {
      output += "\(indent) service: \(service) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasToken {
             hashCode = (hashCode &* 31) &+ token.hashValue
          }
          if hasService {
             hashCode = (hashCode &* 31) &+ service.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "Control"
  }
  override public func className() -> String {
      return "Control"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return Control.self
  }


  //Meta information declaration end

}

final public class ControlBuilder : GeneratedMessageBuilder {
  private var builderResult:Control

  required override public init () {
     builderResult = Control()
     super.init()
  }
  public var hasToken:Bool {
       get {
            return builderResult.hasToken
       }
  }
  public var token:String {
       get {
            return builderResult.token
       }
       set (value) {
           builderResult.hasToken = true
           builderResult.token = value
       }
  }
  public func clearToken() -> ControlBuilder{
       builderResult.hasToken = false
       builderResult.token = ""
       return self
  }
  public var hasService:Bool {
       get {
            return builderResult.hasService
       }
  }
  public var service:String {
       get {
            return builderResult.service
       }
       set (value) {
           builderResult.hasService = true
           builderResult.service = value
       }
  }
  public func clearService() -> ControlBuilder{
       builderResult.hasService = false
       builderResult.service = ""
       return self
  }
  override public var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  public override func clear() -> ControlBuilder {
    builderResult = Control()
    return self
  }
  public override func clone() -> ControlBuilder {
    return Control.builderWithPrototype(builderResult)
  }
  public override func build() -> Control {
       checkInitialized()
       return buildPartial()
  }
  public func buildPartial() -> Control {
    var returnMe:Control = builderResult
    return returnMe
  }
  public func mergeFrom(other:Control) -> ControlBuilder {
    if (other == Control()) {
     return self
    }
    if other.hasToken {
         token = other.token
    }
    if other.hasService {
         service = other.service
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream) ->ControlBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ControlBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        token = input.readString()

      case 18 :
        service = input.readString()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class ActionControl : GeneratedMessage {
  public subscript(key: String) -> Any? {
         switch key {
         case "service": return service
         case "action": return action
         default: return nil
         }
  }

  public private(set) var hasService:Bool = false
  public private(set) var service:String = ""

  public private(set) var hasAction:Bool = false
  public private(set) var action:String = ""

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasService {
      return false
    }
    if !hasAction {
      return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasService {
      output.writeString(1, value:service)
    }
    if hasAction {
      output.writeString(2, value:action)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasService {
      size += WireFormat.computeStringSize(1, value:service)
    }
    if hasAction {
      size += WireFormat.computeStringSize(2, value:action)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  public class func parseFromData(data:[Byte]) -> ActionControl {
    return ActionControl.builder().mergeFromData(data).build()
  }
  public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> ActionControl {
    return ActionControl.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) -> ActionControl {
    return ActionControl.builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ActionControl {
    return ActionControl.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) -> ActionControl {
    return ActionControl.builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ActionControl {
    return ActionControl.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func builder() -> ActionControlBuilder {
    return ActionControl.classBuilder() as ActionControlBuilder
  }
  public func builder() -> ActionControlBuilder {
    return classBuilder() as ActionControlBuilder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ActionControlBuilder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ActionControl.builder()
  }
  public func toBuilder() -> ActionControlBuilder {
    return ActionControl.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ActionControl) -> ActionControlBuilder {
    return ActionControl.builder().mergeFrom(prototype)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasService {
      output += "\(indent) service: \(service) \n"
    }
    if hasAction {
      output += "\(indent) action: \(action) \n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasService {
             hashCode = (hashCode &* 31) &+ service.hashValue
          }
          if hasAction {
             hashCode = (hashCode &* 31) &+ action.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ActionControl"
  }
  override public func className() -> String {
      return "ActionControl"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ActionControl.self
  }


  //Meta information declaration end

}

final public class ActionControlBuilder : GeneratedMessageBuilder {
  private var builderResult:ActionControl

  required override public init () {
     builderResult = ActionControl()
     super.init()
  }
  public var hasService:Bool {
       get {
            return builderResult.hasService
       }
  }
  public var service:String {
       get {
            return builderResult.service
       }
       set (value) {
           builderResult.hasService = true
           builderResult.service = value
       }
  }
  public func clearService() -> ActionControlBuilder{
       builderResult.hasService = false
       builderResult.service = ""
       return self
  }
  public var hasAction:Bool {
       get {
            return builderResult.hasAction
       }
  }
  public var action:String {
       get {
            return builderResult.action
       }
       set (value) {
           builderResult.hasAction = true
           builderResult.action = value
       }
  }
  public func clearAction() -> ActionControlBuilder{
       builderResult.hasAction = false
       builderResult.action = ""
       return self
  }
  override public var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  public override func clear() -> ActionControlBuilder {
    builderResult = ActionControl()
    return self
  }
  public override func clone() -> ActionControlBuilder {
    return ActionControl.builderWithPrototype(builderResult)
  }
  public override func build() -> ActionControl {
       checkInitialized()
       return buildPartial()
  }
  public func buildPartial() -> ActionControl {
    var returnMe:ActionControl = builderResult
    return returnMe
  }
  public func mergeFrom(other:ActionControl) -> ActionControlBuilder {
    if (other == ActionControl()) {
     return self
    }
    if other.hasService {
         service = other.service
    }
    if other.hasAction {
         action = other.action
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream) ->ActionControlBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ActionControlBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        service = input.readString()

      case 18 :
        action = input.readString()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class ActionRequest : GeneratedMessage {
  public subscript(key: String) -> Any? {
         switch key {
         case "control": return control
         case "params": return params
         default: return nil
         }
  }

  public private(set) var hasControl:Bool = false
  public private(set) var control:ActionControl = ActionControl()
  public private(set) var hasParams:Bool = false
  public private(set) var params:ActionRequestParams = ActionRequestParams()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasControl {
      return false
    }
    if !control.isInitialized() {
      return false
    }
    if hasParams {
     if !params.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasControl {
      output.writeMessage(1, value:control)
    }
    if hasParams {
      output.writeMessage(2, value:params)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasControl {
      size += WireFormat.computeMessageSize(1, value:control)
    }
    if hasParams {
      size += WireFormat.computeMessageSize(2, value:params)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  public class func parseFromData(data:[Byte]) -> ActionRequest {
    return ActionRequest.builder().mergeFromData(data).build()
  }
  public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> ActionRequest {
    return ActionRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) -> ActionRequest {
    return ActionRequest.builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ActionRequest {
    return ActionRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) -> ActionRequest {
    return ActionRequest.builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ActionRequest {
    return ActionRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func builder() -> ActionRequestBuilder {
    return ActionRequest.classBuilder() as ActionRequestBuilder
  }
  public func builder() -> ActionRequestBuilder {
    return classBuilder() as ActionRequestBuilder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ActionRequestBuilder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ActionRequest.builder()
  }
  public func toBuilder() -> ActionRequestBuilder {
    return ActionRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ActionRequest) -> ActionRequestBuilder {
    return ActionRequest.builder().mergeFrom(prototype)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasControl {
      output += "\(indent) control {\n"
      control.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasParams {
      output += "\(indent) params {\n"
      params.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasControl {
            hashCode = (hashCode &* 31) &+ control.hashValue
          }
          if hasParams {
            hashCode = (hashCode &* 31) &+ params.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ActionRequest"
  }
  override public func className() -> String {
      return "ActionRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ActionRequest.self
  }


  //Meta information declaration end

}

final public class ActionRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:ActionRequest

  required override public init () {
     builderResult = ActionRequest()
     super.init()
  }
  public var hasControl:Bool {
       get {
           return builderResult.hasControl
       }
  }
  public var control:ActionControl {
       get {
           return builderResult.control
       }
       set (value) {
           builderResult.hasControl = true
           builderResult.control = value
       }
  }
  public func setControlBuilder(builderForValue:ActionControlBuilder) -> ActionRequestBuilder {
    control = builderForValue.build()
    return self
  }
  public func mergeControl(value:ActionControl) -> ActionRequestBuilder {
    if (builderResult.hasControl) {
      builderResult.control = ActionControl.builderWithPrototype(builderResult.control).mergeFrom(value).buildPartial()
    } else {
      builderResult.control = value
    }
    builderResult.hasControl = true
    return self
  }
  public func clearControl() -> ActionRequestBuilder {
    builderResult.hasControl = false
    builderResult.control = ActionControl()
    return self
  }
  public var hasParams:Bool {
       get {
           return builderResult.hasParams
       }
  }
  public var params:ActionRequestParams {
       get {
           return builderResult.params
       }
       set (value) {
           builderResult.hasParams = true
           builderResult.params = value
       }
  }
  public func setParamsBuilder(builderForValue:ActionRequestParamsBuilder) -> ActionRequestBuilder {
    params = builderForValue.build()
    return self
  }
  public func mergeParams(value:ActionRequestParams) -> ActionRequestBuilder {
    if (builderResult.hasParams) {
      builderResult.params = ActionRequestParams.builderWithPrototype(builderResult.params).mergeFrom(value).buildPartial()
    } else {
      builderResult.params = value
    }
    builderResult.hasParams = true
    return self
  }
  public func clearParams() -> ActionRequestBuilder {
    builderResult.hasParams = false
    builderResult.params = ActionRequestParams()
    return self
  }
  override public var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  public override func clear() -> ActionRequestBuilder {
    builderResult = ActionRequest()
    return self
  }
  public override func clone() -> ActionRequestBuilder {
    return ActionRequest.builderWithPrototype(builderResult)
  }
  public override func build() -> ActionRequest {
       checkInitialized()
       return buildPartial()
  }
  public func buildPartial() -> ActionRequest {
    var returnMe:ActionRequest = builderResult
    return returnMe
  }
  public func mergeFrom(other:ActionRequest) -> ActionRequestBuilder {
    if (other == ActionRequest()) {
     return self
    }
    if (other.hasControl) {
        mergeControl(other.control)
    }
    if (other.hasParams) {
        mergeParams(other.params)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream) ->ActionRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ActionRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:ActionControlBuilder = ActionControl.builder()
        if hasControl {
          subBuilder.mergeFrom(control)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        control = subBuilder.buildPartial()

      case 18 :
        var subBuilder:ActionRequestParamsBuilder = ActionRequestParams.builder()
        if hasParams {
          subBuilder.mergeFrom(params)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        params = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class ActionRequestParams : ExtendableMessage {
  public subscript(key: String) -> Any? {
         switch key {
         default: return nil
         }
  }

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(100), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  public class func parseFromData(data:[Byte]) -> ActionRequestParams {
    return ActionRequestParams.builder().mergeFromData(data).build()
  }
  public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> ActionRequestParams {
    return ActionRequestParams.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) -> ActionRequestParams {
    return ActionRequestParams.builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ActionRequestParams {
    return ActionRequestParams.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) -> ActionRequestParams {
    return ActionRequestParams.builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ActionRequestParams {
    return ActionRequestParams.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func builder() -> ActionRequestParamsBuilder {
    return ActionRequestParams.classBuilder() as ActionRequestParamsBuilder
  }
  public func builder() -> ActionRequestParamsBuilder {
    return classBuilder() as ActionRequestParamsBuilder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ActionRequestParamsBuilder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ActionRequestParams.builder()
  }
  public func toBuilder() -> ActionRequestParamsBuilder {
    return ActionRequestParams.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ActionRequestParams) -> ActionRequestParamsBuilder {
    return ActionRequestParams.builder().mergeFrom(prototype)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    writeExtensionDescription(&output, startInclusive:Int32(100), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(100), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ActionRequestParams"
  }
  override public func className() -> String {
      return "ActionRequestParams"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ActionRequestParams.self
  }


  //Meta information declaration end

}

final public class ActionRequestParamsBuilder : ExtendableMessageBuilder {
  private var builderResult:ActionRequestParams

  required override public init () {
     builderResult = ActionRequestParams()
     super.init()
  }
  override public var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  public override func clear() -> ActionRequestParamsBuilder {
    builderResult = ActionRequestParams()
    return self
  }
  public override func clone() -> ActionRequestParamsBuilder {
    return ActionRequestParams.builderWithPrototype(builderResult)
  }
  public override func build() -> ActionRequestParams {
       checkInitialized()
       return buildPartial()
  }
  public func buildPartial() -> ActionRequestParams {
    var returnMe:ActionRequestParams = builderResult
    return returnMe
  }
  public func mergeFrom(other:ActionRequestParams) -> ActionRequestParamsBuilder {
    if (other == ActionRequestParams()) {
     return self
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream) ->ActionRequestParamsBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ActionRequestParamsBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class ActionResponseResult : ExtendableMessage {


  //Nested type declaration start

    final public class ErrorDetail : GeneratedMessage {
      public subscript(key: String) -> Any? {
             switch key {
             case "error": return error
             case "key": return key
             case "detail": return detail
             default: return nil
             }
      }

      public private(set) var hasError:Bool = false
      public private(set) var error:String = ""

      public private(set) var hasKey:Bool = false
      public private(set) var key:String = ""

      public private(set) var hasDetail:Bool = false
      public private(set) var detail:String = ""

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        if hasError {
          output.writeString(1, value:error)
        }
        if hasKey {
          output.writeString(2, value:key)
        }
        if hasDetail {
          output.writeString(3, value:detail)
        }
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        if hasError {
          size += WireFormat.computeStringSize(1, value:error)
        }
        if hasKey {
          size += WireFormat.computeStringSize(2, value:key)
        }
        if hasDetail {
          size += WireFormat.computeStringSize(3, value:detail)
        }
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      public class func parseFromData(data:[Byte]) -> ActionResponseResult.ErrorDetail {
        return ActionResponseResult.ErrorDetail.builder().mergeFromData(data).build()
      }
      public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> ActionResponseResult.ErrorDetail {
        return ActionResponseResult.ErrorDetail.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) -> ActionResponseResult.ErrorDetail {
        return ActionResponseResult.ErrorDetail.builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ActionResponseResult.ErrorDetail {
        return ActionResponseResult.ErrorDetail.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) -> ActionResponseResult.ErrorDetail {
        return ActionResponseResult.ErrorDetail.builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ActionResponseResult.ErrorDetail {
        return ActionResponseResult.ErrorDetail.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func builder() -> ActionResponseResult.ErrorDetailBuilder {
        return ActionResponseResult.ErrorDetail.classBuilder() as ActionResponseResult.ErrorDetailBuilder
      }
      public func builder() -> ActionResponseResult.ErrorDetailBuilder {
        return classBuilder() as ActionResponseResult.ErrorDetailBuilder
      }
      public override class func classBuilder() -> MessageBuilder {
        return ActionResponseResult.ErrorDetailBuilder()
      }
      public override func classBuilder() -> MessageBuilder {
        return ActionResponseResult.ErrorDetail.builder()
      }
      public func toBuilder() -> ActionResponseResult.ErrorDetailBuilder {
        return ActionResponseResult.ErrorDetail.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:ActionResponseResult.ErrorDetail) -> ActionResponseResult.ErrorDetailBuilder {
        return ActionResponseResult.ErrorDetail.builder().mergeFrom(prototype)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        if hasError {
          output += "\(indent) error: \(error) \n"
        }
        if hasKey {
          output += "\(indent) key: \(key) \n"
        }
        if hasDetail {
          output += "\(indent) detail: \(detail) \n"
        }
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              if hasError {
                 hashCode = (hashCode &* 31) &+ error.hashValue
              }
              if hasKey {
                 hashCode = (hashCode &* 31) &+ key.hashValue
              }
              if hasDetail {
                 hashCode = (hashCode &* 31) &+ detail.hashValue
              }
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "ActionResponseResult.ErrorDetail"
      }
      override public func className() -> String {
          return "ActionResponseResult.ErrorDetail"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return ActionResponseResult.ErrorDetail.self
      }


      //Meta information declaration end

    }

    final public class ErrorDetailBuilder : GeneratedMessageBuilder {
      private var builderResult:ActionResponseResult.ErrorDetail

      required override public init () {
         builderResult = ActionResponseResult.ErrorDetail()
         super.init()
      }
      public var hasError:Bool {
           get {
                return builderResult.hasError
           }
      }
      public var error:String {
           get {
                return builderResult.error
           }
           set (value) {
               builderResult.hasError = true
               builderResult.error = value
           }
      }
      public func clearError() -> ActionResponseResult.ErrorDetailBuilder{
           builderResult.hasError = false
           builderResult.error = ""
           return self
      }
      public var hasKey:Bool {
           get {
                return builderResult.hasKey
           }
      }
      public var key:String {
           get {
                return builderResult.key
           }
           set (value) {
               builderResult.hasKey = true
               builderResult.key = value
           }
      }
      public func clearKey() -> ActionResponseResult.ErrorDetailBuilder{
           builderResult.hasKey = false
           builderResult.key = ""
           return self
      }
      public var hasDetail:Bool {
           get {
                return builderResult.hasDetail
           }
      }
      public var detail:String {
           get {
                return builderResult.detail
           }
           set (value) {
               builderResult.hasDetail = true
               builderResult.detail = value
           }
      }
      public func clearDetail() -> ActionResponseResult.ErrorDetailBuilder{
           builderResult.hasDetail = false
           builderResult.detail = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      public override func clear() -> ActionResponseResult.ErrorDetailBuilder {
        builderResult = ActionResponseResult.ErrorDetail()
        return self
      }
      public override func clone() -> ActionResponseResult.ErrorDetailBuilder {
        return ActionResponseResult.ErrorDetail.builderWithPrototype(builderResult)
      }
      public override func build() -> ActionResponseResult.ErrorDetail {
           checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> ActionResponseResult.ErrorDetail {
        var returnMe:ActionResponseResult.ErrorDetail = builderResult
        return returnMe
      }
      public func mergeFrom(other:ActionResponseResult.ErrorDetail) -> ActionResponseResult.ErrorDetailBuilder {
        if (other == ActionResponseResult.ErrorDetail()) {
         return self
        }
        if other.hasError {
             error = other.error
        }
        if other.hasKey {
             key = other.key
        }
        if other.hasDetail {
             detail = other.detail
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) ->ActionResponseResult.ErrorDetailBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ActionResponseResult.ErrorDetailBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          case 10 :
            error = input.readString()

          case 18 :
            key = input.readString()

          case 26 :
            detail = input.readString()

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end

  public subscript(key: String) -> Any? {
         switch key {
         case "success": return success
         default: return nil
         }
  }

  public private(set) var hasSuccess:Bool = false
  public private(set) var success:Bool = false

  public private(set) var errors:Array<String> = Array<String>()
  public private(set) var error_details:Array<ActionResponseResult.ErrorDetail>  = Array<ActionResponseResult.ErrorDetail>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !extensionsAreInitialized() {
     return false
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasSuccess {
      output.writeBool(1, value:success)
    }
    if !errors.isEmpty {
      for oneValueerrors in errors {
        output.writeString(2, value:oneValueerrors)
      }
    }
    for oneElementerror_details in error_details {
        output.writeMessage(3, value:oneElementerror_details)
    }
    writeExtensionsToCodedOutputStream(output, startInclusive:Int32(100), endExclusive:Int32(536870912))
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasSuccess {
      size += WireFormat.computeBoolSize(1, value:success)
    }
    var dataSizeErrors:Int32 = 0
    for oneValueerrors in errors {
        dataSizeErrors += WireFormat.computeStringSizeNoTag(oneValueerrors)
    }
    size += dataSizeErrors
    size += 1 * Int32(errors.count)
    for oneElementerror_details in error_details {
        size += WireFormat.computeMessageSize(3, value:oneElementerror_details)
    }
    size += extensionsSerializedSize()
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  public class func parseFromData(data:[Byte]) -> ActionResponseResult {
    return ActionResponseResult.builder().mergeFromData(data).build()
  }
  public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> ActionResponseResult {
    return ActionResponseResult.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) -> ActionResponseResult {
    return ActionResponseResult.builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ActionResponseResult {
    return ActionResponseResult.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) -> ActionResponseResult {
    return ActionResponseResult.builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ActionResponseResult {
    return ActionResponseResult.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func builder() -> ActionResponseResultBuilder {
    return ActionResponseResult.classBuilder() as ActionResponseResultBuilder
  }
  public func builder() -> ActionResponseResultBuilder {
    return classBuilder() as ActionResponseResultBuilder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ActionResponseResultBuilder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ActionResponseResult.builder()
  }
  public func toBuilder() -> ActionResponseResultBuilder {
    return ActionResponseResult.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ActionResponseResult) -> ActionResponseResultBuilder {
    return ActionResponseResult.builder().mergeFrom(prototype)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasSuccess {
      output += "\(indent) success: \(success) \n"
    }
    var errorsElementIndex:Int = 0
    for oneValueerrors in errors  {
        output += "\(indent) errors[\(errorsElementIndex)]: \(oneValueerrors)\n"
        errorsElementIndex++
    }
    var error_detailsElementIndex:Int = 0
    for oneElementerror_details in error_details {
        output += "\(indent) error_details[\(error_detailsElementIndex)] {\n"
        oneElementerror_details.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        error_detailsElementIndex++
    }
    writeExtensionDescription(&output, startInclusive:Int32(100), endExclusive:Int32(536870912), indent:indent)
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasSuccess {
             hashCode = (hashCode &* 31) &+ success.hashValue
          }
          for oneValueerrors in errors {
              hashCode = (hashCode &* 31) &+ oneValueerrors.hashValue
          }
          for oneElementerror_details in error_details {
              hashCode = (hashCode &* 31) &+ oneElementerror_details.hashValue
          }
          hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(100), endExclusive:Int32(536870912)))
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ActionResponseResult"
  }
  override public func className() -> String {
      return "ActionResponseResult"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ActionResponseResult.self
  }


  //Meta information declaration end

}

final public class ActionResponseResultBuilder : ExtendableMessageBuilder {
  private var builderResult:ActionResponseResult

  required override public init () {
     builderResult = ActionResponseResult()
     super.init()
  }
  public var hasSuccess:Bool {
       get {
            return builderResult.hasSuccess
       }
  }
  public var success:Bool {
       get {
            return builderResult.success
       }
       set (value) {
           builderResult.hasSuccess = true
           builderResult.success = value
       }
  }
  public func clearSuccess() -> ActionResponseResultBuilder{
       builderResult.hasSuccess = false
       builderResult.success = false
       return self
  }
  public var errors:Array<String> {
       get {
           return builderResult.errors
       }
       set (array) {
           builderResult.errors = array
       }
  }
  public func clearErrors() -> ActionResponseResultBuilder {
     builderResult.errors.removeAll(keepCapacity: false)
     return self
  }
  public var error_details:Array<ActionResponseResult.ErrorDetail> {
       get {
           return builderResult.error_details
       }
       set (value) {
           builderResult.error_details = value
       }
  }
  public func clearErrorDetails() -> ActionResponseResultBuilder {
    builderResult.error_details.removeAll(keepCapacity: false)
    return self
  }
  override public var internalGetResult:ExtendableMessage {
       get {
           return builderResult
       }
  }
  public override func clear() -> ActionResponseResultBuilder {
    builderResult = ActionResponseResult()
    return self
  }
  public override func clone() -> ActionResponseResultBuilder {
    return ActionResponseResult.builderWithPrototype(builderResult)
  }
  public override func build() -> ActionResponseResult {
       checkInitialized()
       return buildPartial()
  }
  public func buildPartial() -> ActionResponseResult {
    var returnMe:ActionResponseResult = builderResult
    return returnMe
  }
  public func mergeFrom(other:ActionResponseResult) -> ActionResponseResultBuilder {
    if (other == ActionResponseResult()) {
     return self
    }
    if other.hasSuccess {
         success = other.success
    }
    if !other.errors.isEmpty {
        builderResult.errors += other.errors
    }
    if !other.error_details.isEmpty  {
       builderResult.error_details += other.error_details
    }
    mergeExtensionFields(other)
    mergeUnknownFields(other.unknownFields)
    return self
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream) ->ActionResponseResultBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ActionResponseResultBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 8 :
        success = input.readBool()

      case 18 :
        errors += [input.readString()]

      case 26 :
        var subBuilder = ActionResponseResult.ErrorDetail.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        error_details += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class ActionResponse : GeneratedMessage {
  public subscript(key: String) -> Any? {
         switch key {
         case "control": return control
         case "result": return result
         default: return nil
         }
  }

  public private(set) var hasControl:Bool = false
  public private(set) var control:ActionControl = ActionControl()
  public private(set) var hasResult:Bool = false
  public private(set) var result:ActionResponseResult = ActionResponseResult()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasControl {
      return false
    }
    if !control.isInitialized() {
      return false
    }
    if hasResult {
     if !result.isInitialized() {
       return false
     }
    }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasControl {
      output.writeMessage(1, value:control)
    }
    if hasResult {
      output.writeMessage(2, value:result)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasControl {
      size += WireFormat.computeMessageSize(1, value:control)
    }
    if hasResult {
      size += WireFormat.computeMessageSize(2, value:result)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  public class func parseFromData(data:[Byte]) -> ActionResponse {
    return ActionResponse.builder().mergeFromData(data).build()
  }
  public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> ActionResponse {
    return ActionResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) -> ActionResponse {
    return ActionResponse.builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ActionResponse {
    return ActionResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) -> ActionResponse {
    return ActionResponse.builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ActionResponse {
    return ActionResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func builder() -> ActionResponseBuilder {
    return ActionResponse.classBuilder() as ActionResponseBuilder
  }
  public func builder() -> ActionResponseBuilder {
    return classBuilder() as ActionResponseBuilder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ActionResponseBuilder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ActionResponse.builder()
  }
  public func toBuilder() -> ActionResponseBuilder {
    return ActionResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ActionResponse) -> ActionResponseBuilder {
    return ActionResponse.builder().mergeFrom(prototype)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasControl {
      output += "\(indent) control {\n"
      control.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    if hasResult {
      output += "\(indent) result {\n"
      result.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasControl {
            hashCode = (hashCode &* 31) &+ control.hashValue
          }
          if hasResult {
            hashCode = (hashCode &* 31) &+ result.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ActionResponse"
  }
  override public func className() -> String {
      return "ActionResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ActionResponse.self
  }


  //Meta information declaration end

}

final public class ActionResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:ActionResponse

  required override public init () {
     builderResult = ActionResponse()
     super.init()
  }
  public var hasControl:Bool {
       get {
           return builderResult.hasControl
       }
  }
  public var control:ActionControl {
       get {
           return builderResult.control
       }
       set (value) {
           builderResult.hasControl = true
           builderResult.control = value
       }
  }
  public func setControlBuilder(builderForValue:ActionControlBuilder) -> ActionResponseBuilder {
    control = builderForValue.build()
    return self
  }
  public func mergeControl(value:ActionControl) -> ActionResponseBuilder {
    if (builderResult.hasControl) {
      builderResult.control = ActionControl.builderWithPrototype(builderResult.control).mergeFrom(value).buildPartial()
    } else {
      builderResult.control = value
    }
    builderResult.hasControl = true
    return self
  }
  public func clearControl() -> ActionResponseBuilder {
    builderResult.hasControl = false
    builderResult.control = ActionControl()
    return self
  }
  public var hasResult:Bool {
       get {
           return builderResult.hasResult
       }
  }
  public var result:ActionResponseResult {
       get {
           return builderResult.result
       }
       set (value) {
           builderResult.hasResult = true
           builderResult.result = value
       }
  }
  public func setResultBuilder(builderForValue:ActionResponseResultBuilder) -> ActionResponseBuilder {
    result = builderForValue.build()
    return self
  }
  public func mergeResult(value:ActionResponseResult) -> ActionResponseBuilder {
    if (builderResult.hasResult) {
      builderResult.result = ActionResponseResult.builderWithPrototype(builderResult.result).mergeFrom(value).buildPartial()
    } else {
      builderResult.result = value
    }
    builderResult.hasResult = true
    return self
  }
  public func clearResult() -> ActionResponseBuilder {
    builderResult.hasResult = false
    builderResult.result = ActionResponseResult()
    return self
  }
  override public var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  public override func clear() -> ActionResponseBuilder {
    builderResult = ActionResponse()
    return self
  }
  public override func clone() -> ActionResponseBuilder {
    return ActionResponse.builderWithPrototype(builderResult)
  }
  public override func build() -> ActionResponse {
       checkInitialized()
       return buildPartial()
  }
  public func buildPartial() -> ActionResponse {
    var returnMe:ActionResponse = builderResult
    return returnMe
  }
  public func mergeFrom(other:ActionResponse) -> ActionResponseBuilder {
    if (other == ActionResponse()) {
     return self
    }
    if (other.hasControl) {
        mergeControl(other.control)
    }
    if (other.hasResult) {
        mergeResult(other.result)
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream) ->ActionResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ActionResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:ActionControlBuilder = ActionControl.builder()
        if hasControl {
          subBuilder.mergeFrom(control)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        control = subBuilder.buildPartial()

      case 18 :
        var subBuilder:ActionResponseResultBuilder = ActionResponseResult.builder()
        if hasResult {
          subBuilder.mergeFrom(result)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        result = subBuilder.buildPartial()

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class ServiceRequest : GeneratedMessage {
  public subscript(key: String) -> Any? {
         switch key {
         case "control": return control
         default: return nil
         }
  }

  public private(set) var hasControl:Bool = false
  public private(set) var control:Control = Control()
  public private(set) var actions:Array<ActionRequest>  = Array<ActionRequest>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasControl {
      return false
    }
    if !control.isInitialized() {
      return false
    }
    var isInitactions:Bool = true
    for oneElementactions in actions {
        if (!oneElementactions.isInitialized()) {
            isInitactions = false
            break 
        }
    }
    if !isInitactions {
     return isInitactions
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasControl {
      output.writeMessage(1, value:control)
    }
    for oneElementactions in actions {
        output.writeMessage(2, value:oneElementactions)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasControl {
      size += WireFormat.computeMessageSize(1, value:control)
    }
    for oneElementactions in actions {
        size += WireFormat.computeMessageSize(2, value:oneElementactions)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  public class func parseFromData(data:[Byte]) -> ServiceRequest {
    return ServiceRequest.builder().mergeFromData(data).build()
  }
  public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> ServiceRequest {
    return ServiceRequest.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) -> ServiceRequest {
    return ServiceRequest.builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ServiceRequest {
    return ServiceRequest.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) -> ServiceRequest {
    return ServiceRequest.builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ServiceRequest {
    return ServiceRequest.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func builder() -> ServiceRequestBuilder {
    return ServiceRequest.classBuilder() as ServiceRequestBuilder
  }
  public func builder() -> ServiceRequestBuilder {
    return classBuilder() as ServiceRequestBuilder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ServiceRequestBuilder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ServiceRequest.builder()
  }
  public func toBuilder() -> ServiceRequestBuilder {
    return ServiceRequest.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ServiceRequest) -> ServiceRequestBuilder {
    return ServiceRequest.builder().mergeFrom(prototype)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasControl {
      output += "\(indent) control {\n"
      control.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    var actionsElementIndex:Int = 0
    for oneElementactions in actions {
        output += "\(indent) actions[\(actionsElementIndex)] {\n"
        oneElementactions.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        actionsElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasControl {
            hashCode = (hashCode &* 31) &+ control.hashValue
          }
          for oneElementactions in actions {
              hashCode = (hashCode &* 31) &+ oneElementactions.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ServiceRequest"
  }
  override public func className() -> String {
      return "ServiceRequest"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ServiceRequest.self
  }


  //Meta information declaration end

}

final public class ServiceRequestBuilder : GeneratedMessageBuilder {
  private var builderResult:ServiceRequest

  required override public init () {
     builderResult = ServiceRequest()
     super.init()
  }
  public var hasControl:Bool {
       get {
           return builderResult.hasControl
       }
  }
  public var control:Control {
       get {
           return builderResult.control
       }
       set (value) {
           builderResult.hasControl = true
           builderResult.control = value
       }
  }
  public func setControlBuilder(builderForValue:ControlBuilder) -> ServiceRequestBuilder {
    control = builderForValue.build()
    return self
  }
  public func mergeControl(value:Control) -> ServiceRequestBuilder {
    if (builderResult.hasControl) {
      builderResult.control = Control.builderWithPrototype(builderResult.control).mergeFrom(value).buildPartial()
    } else {
      builderResult.control = value
    }
    builderResult.hasControl = true
    return self
  }
  public func clearControl() -> ServiceRequestBuilder {
    builderResult.hasControl = false
    builderResult.control = Control()
    return self
  }
  public var actions:Array<ActionRequest> {
       get {
           return builderResult.actions
       }
       set (value) {
           builderResult.actions = value
       }
  }
  public func clearActions() -> ServiceRequestBuilder {
    builderResult.actions.removeAll(keepCapacity: false)
    return self
  }
  override public var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  public override func clear() -> ServiceRequestBuilder {
    builderResult = ServiceRequest()
    return self
  }
  public override func clone() -> ServiceRequestBuilder {
    return ServiceRequest.builderWithPrototype(builderResult)
  }
  public override func build() -> ServiceRequest {
       checkInitialized()
       return buildPartial()
  }
  public func buildPartial() -> ServiceRequest {
    var returnMe:ServiceRequest = builderResult
    return returnMe
  }
  public func mergeFrom(other:ServiceRequest) -> ServiceRequestBuilder {
    if (other == ServiceRequest()) {
     return self
    }
    if (other.hasControl) {
        mergeControl(other.control)
    }
    if !other.actions.isEmpty  {
       builderResult.actions += other.actions
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream) ->ServiceRequestBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ServiceRequestBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:ControlBuilder = Control.builder()
        if hasControl {
          subBuilder.mergeFrom(control)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        control = subBuilder.buildPartial()

      case 18 :
        var subBuilder = ActionRequest.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        actions += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

final public class ServiceResponse : GeneratedMessage {
  public subscript(key: String) -> Any? {
         switch key {
         case "control": return control
         default: return nil
         }
  }

  public private(set) var hasControl:Bool = false
  public private(set) var control:Control = Control()
  public private(set) var actions:Array<ActionResponse>  = Array<ActionResponse>()
  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
    if !hasControl {
      return false
    }
    if !control.isInitialized() {
      return false
    }
    var isInitactions:Bool = true
    for oneElementactions in actions {
        if (!oneElementactions.isInitialized()) {
            isInitactions = false
            break 
        }
    }
    if !isInitactions {
     return isInitactions
     }
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    if hasControl {
      output.writeMessage(1, value:control)
    }
    for oneElementactions in actions {
        output.writeMessage(2, value:oneElementactions)
    }
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    if hasControl {
      size += WireFormat.computeMessageSize(1, value:control)
    }
    for oneElementactions in actions {
        size += WireFormat.computeMessageSize(2, value:oneElementactions)
    }
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  public class func parseFromData(data:[Byte]) -> ServiceResponse {
    return ServiceResponse.builder().mergeFromData(data).build()
  }
  public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> ServiceResponse {
    return ServiceResponse.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) -> ServiceResponse {
    return ServiceResponse.builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->ServiceResponse {
    return ServiceResponse.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) -> ServiceResponse {
    return ServiceResponse.builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ServiceResponse {
    return ServiceResponse.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func builder() -> ServiceResponseBuilder {
    return ServiceResponse.classBuilder() as ServiceResponseBuilder
  }
  public func builder() -> ServiceResponseBuilder {
    return classBuilder() as ServiceResponseBuilder
  }
  public override class func classBuilder() -> MessageBuilder {
    return ServiceResponseBuilder()
  }
  public override func classBuilder() -> MessageBuilder {
    return ServiceResponse.builder()
  }
  public func toBuilder() -> ServiceResponseBuilder {
    return ServiceResponse.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:ServiceResponse) -> ServiceResponseBuilder {
    return ServiceResponse.builder().mergeFrom(prototype)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    if hasControl {
      output += "\(indent) control {\n"
      control.writeDescriptionTo(&output, indent:"\(indent)  ")
      output += "\(indent) }\n"
    }
    var actionsElementIndex:Int = 0
    for oneElementactions in actions {
        output += "\(indent) actions[\(actionsElementIndex)] {\n"
        oneElementactions.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent)}\n"
        actionsElementIndex++
    }
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          if hasControl {
            hashCode = (hashCode &* 31) &+ control.hashValue
          }
          for oneElementactions in actions {
              hashCode = (hashCode &* 31) &+ oneElementactions.hashValue
          }
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "ServiceResponse"
  }
  override public func className() -> String {
      return "ServiceResponse"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return ServiceResponse.self
  }


  //Meta information declaration end

}

final public class ServiceResponseBuilder : GeneratedMessageBuilder {
  private var builderResult:ServiceResponse

  required override public init () {
     builderResult = ServiceResponse()
     super.init()
  }
  public var hasControl:Bool {
       get {
           return builderResult.hasControl
       }
  }
  public var control:Control {
       get {
           return builderResult.control
       }
       set (value) {
           builderResult.hasControl = true
           builderResult.control = value
       }
  }
  public func setControlBuilder(builderForValue:ControlBuilder) -> ServiceResponseBuilder {
    control = builderForValue.build()
    return self
  }
  public func mergeControl(value:Control) -> ServiceResponseBuilder {
    if (builderResult.hasControl) {
      builderResult.control = Control.builderWithPrototype(builderResult.control).mergeFrom(value).buildPartial()
    } else {
      builderResult.control = value
    }
    builderResult.hasControl = true
    return self
  }
  public func clearControl() -> ServiceResponseBuilder {
    builderResult.hasControl = false
    builderResult.control = Control()
    return self
  }
  public var actions:Array<ActionResponse> {
       get {
           return builderResult.actions
       }
       set (value) {
           builderResult.actions = value
       }
  }
  public func clearActions() -> ServiceResponseBuilder {
    builderResult.actions.removeAll(keepCapacity: false)
    return self
  }
  override public var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  public override func clear() -> ServiceResponseBuilder {
    builderResult = ServiceResponse()
    return self
  }
  public override func clone() -> ServiceResponseBuilder {
    return ServiceResponse.builderWithPrototype(builderResult)
  }
  public override func build() -> ServiceResponse {
       checkInitialized()
       return buildPartial()
  }
  public func buildPartial() -> ServiceResponse {
    var returnMe:ServiceResponse = builderResult
    return returnMe
  }
  public func mergeFrom(other:ServiceResponse) -> ServiceResponseBuilder {
    if (other == ServiceResponse()) {
     return self
    }
    if (other.hasControl) {
        mergeControl(other.control)
    }
    if !other.actions.isEmpty  {
       builderResult.actions += other.actions
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream) ->ServiceResponseBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> ServiceResponseBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      case 10 :
        var subBuilder:ControlBuilder = Control.builder()
        if hasControl {
          subBuilder.mergeFrom(control)
        }
        input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
        control = subBuilder.buildPartial()

      case 18 :
        var subBuilder = ActionResponse.builder()
        input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
        actions += [subBuilder.buildPartial()]

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

//Class extensions: NSData


public extension Control {
    class func parseFromNSData(data:NSData) -> Control {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Control.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> Control {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return Control.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
public extension ActionControl {
    class func parseFromNSData(data:NSData) -> ActionControl {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ActionControl.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> ActionControl {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ActionControl.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
public extension ActionRequest {
    class func parseFromNSData(data:NSData) -> ActionRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ActionRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> ActionRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ActionRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
public extension ActionRequestParams {
    class func parseFromNSData(data:NSData) -> ActionRequestParams {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ActionRequestParams.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> ActionRequestParams {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ActionRequestParams.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
public extension ActionResponseResult.ErrorDetail {
    class func parseFromNSData(data:NSData) -> ActionResponseResult.ErrorDetail {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ActionResponseResult.ErrorDetail.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> ActionResponseResult.ErrorDetail {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ActionResponseResult.ErrorDetail.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
public extension ActionResponseResult {
    class func parseFromNSData(data:NSData) -> ActionResponseResult {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ActionResponseResult.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> ActionResponseResult {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ActionResponseResult.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
public extension ActionResponse {
    class func parseFromNSData(data:NSData) -> ActionResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ActionResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> ActionResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ActionResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
public extension ServiceRequest {
    class func parseFromNSData(data:NSData) -> ServiceRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ServiceRequest.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> ServiceRequest {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ServiceRequest.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
public extension ServiceResponse {
    class func parseFromNSData(data:NSData) -> ServiceResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ServiceResponse.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> ServiceResponse {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return ServiceResponse.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}

// @@protoc_insertion_point(global_scope)
