// Generated by the protocol buffer compiler.  DO NOT EDIT!
// Source file containers.proto

import Foundation

public extension Services.Notification{ public struct Containers { }}

public func == (lhs: Services.Notification.Containers.NotificationTokenV1, rhs: Services.Notification.Containers.NotificationTokenV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasUserId == rhs.hasUserId) && (!lhs.hasUserId || lhs.userId == rhs.userId)
  fieldCheck = fieldCheck && (lhs.hasDeviceId == rhs.hasDeviceId) && (!lhs.hasDeviceId || lhs.deviceId == rhs.deviceId)
  fieldCheck = fieldCheck && (lhs.hasProviderToken == rhs.hasProviderToken) && (!lhs.hasProviderToken || lhs.providerToken == rhs.providerToken)
  fieldCheck = fieldCheck && (lhs.hasProvider == rhs.hasProvider) && (!lhs.hasProvider || lhs.provider == rhs.provider)
  fieldCheck = fieldCheck && (lhs.hasProviderPlatform == rhs.hasProviderPlatform) && (!lhs.hasProviderPlatform || lhs.providerPlatform == rhs.providerPlatform)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Services.Notification.Containers.NotificationPreferenceV1, rhs: Services.Notification.Containers.NotificationPreferenceV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasProfileId == rhs.hasProfileId) && (!lhs.hasProfileId || lhs.profileId == rhs.profileId)
  fieldCheck = fieldCheck && (lhs.hasNotificationTypeId == rhs.hasNotificationTypeId) && (!lhs.hasNotificationTypeId || lhs.notificationTypeId == rhs.notificationTypeId)
  fieldCheck = fieldCheck && (lhs.hasSubscribed == rhs.hasSubscribed) && (!lhs.hasSubscribed || lhs.subscribed == rhs.subscribed)
  fieldCheck = fieldCheck && (lhs.hasNotificationType == rhs.hasNotificationType) && (!lhs.hasNotificationType || lhs.notificationType == rhs.notificationType)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Services.Notification.Containers.NotificationTypeV1, rhs: Services.Notification.Containers.NotificationTypeV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasId == rhs.hasId) && (!lhs.hasId || lhs.id == rhs.id)
  fieldCheck = fieldCheck && (lhs.hasDescription == rhs.hasDescription) && (!lhs.hasDescription || lhs.description_ == rhs.description_)
  fieldCheck = fieldCheck && (lhs.hasOptIn == rhs.hasOptIn) && (!lhs.hasOptIn || lhs.optIn == rhs.optIn)
  fieldCheck = fieldCheck && (lhs.hasMobilePush == rhs.hasMobilePush) && (!lhs.hasMobilePush || lhs.mobilePush == rhs.mobilePush)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Services.Notification.Containers.NotificationV1, rhs: Services.Notification.Containers.NotificationV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasNotificationTypeId == rhs.hasNotificationTypeId) && (!lhs.hasNotificationTypeId || lhs.notificationTypeId == rhs.notificationTypeId)
  fieldCheck = fieldCheck && (lhs.hasGroupMembershipRequest == rhs.hasGroupMembershipRequest) && (!lhs.hasGroupMembershipRequest || lhs.groupMembershipRequest == rhs.groupMembershipRequest)
  fieldCheck = fieldCheck && (lhs.hasGroupMembershipRequestResponse == rhs.hasGroupMembershipRequestResponse) && (!lhs.hasGroupMembershipRequestResponse || lhs.groupMembershipRequestResponse == rhs.groupMembershipRequestResponse)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Services.Notification.Containers.GroupMembershipRequestNotificationV1, rhs: Services.Notification.Containers.GroupMembershipRequestNotificationV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasRequesterProfileId == rhs.hasRequesterProfileId) && (!lhs.hasRequesterProfileId || lhs.requesterProfileId == rhs.requesterProfileId)
  fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
  fieldCheck = fieldCheck && (lhs.hasProvider == rhs.hasProvider) && (!lhs.hasProvider || lhs.provider == rhs.provider)
  fieldCheck = fieldCheck && (lhs.hasRequestId == rhs.hasRequestId) && (!lhs.hasRequestId || lhs.requestId == rhs.requestId)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public func == (lhs: Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1, rhs: Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasGroupManagerProfileId == rhs.hasGroupManagerProfileId) && (!lhs.hasGroupManagerProfileId || lhs.groupManagerProfileId == rhs.groupManagerProfileId)
  fieldCheck = fieldCheck && (lhs.hasApproved == rhs.hasApproved) && (!lhs.hasApproved || lhs.approved == rhs.approved)
  fieldCheck = fieldCheck && (lhs.hasGroupId == rhs.hasGroupId) && (!lhs.hasGroupId || lhs.groupId == rhs.groupId)
  fieldCheck = fieldCheck && (lhs.hasProvider == rhs.hasProvider) && (!lhs.hasProvider || lhs.provider == rhs.provider)
  fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
  return fieldCheck
}

public extension Services.Notification.Containers {
  public struct ContainersRoot {
    public static var sharedInstance : ContainersRoot {
     struct Static {
         static let instance : ContainersRoot = ContainersRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
      Services.Group.Containers.ContainersRoot.sharedInstance.registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }



  //Enum type declaration start 

  public enum NotificationChannelV1:Int32 {
    case MobilePush = 0

  }

  //Enum type declaration end 

  final public class NotificationTokenV1 : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum ProviderV1:Int32 {
        case Sns = 0

      }

      //Enum type declaration end 



      //Enum type declaration start 

      public enum ProviderPlatformV1:Int32 {
        case Apns = 0
        case Gcm = 1

      }

      //Enum type declaration end 

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasUserId:Bool = false
    public private(set) var userId:String = ""

    public private(set) var hasDeviceId:Bool = false
    public private(set) var deviceId:String = ""

    public private(set) var hasProviderToken:Bool = false
    public private(set) var providerToken:String = ""

    public private(set) var provider:Services.Notification.Containers.NotificationTokenV1.ProviderV1 = Services.Notification.Containers.NotificationTokenV1.ProviderV1.Sns
    public private(set) var hasProvider:Bool = false
    public private(set) var providerPlatform:Services.Notification.Containers.NotificationTokenV1.ProviderPlatformV1 = Services.Notification.Containers.NotificationTokenV1.ProviderPlatformV1.Apns
    public private(set) var hasProviderPlatform:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasUserId {
        try output.writeString(2, value:userId)
      }
      if hasDeviceId {
        try output.writeString(3, value:deviceId)
      }
      if hasProviderToken {
        try output.writeString(4, value:providerToken)
      }
      if hasProvider {
        try output.writeEnum(5, value:provider.rawValue)
      }
      if hasProviderPlatform {
        try output.writeEnum(6, value:providerPlatform.rawValue)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasUserId {
        serialize_size += userId.computeStringSize(2)
      }
      if hasDeviceId {
        serialize_size += deviceId.computeStringSize(3)
      }
      if hasProviderToken {
        serialize_size += providerToken.computeStringSize(4)
      }
      if (hasProvider) {
        serialize_size += provider.rawValue.computeEnumSize(5)
      }
      if (hasProviderPlatform) {
        serialize_size += providerPlatform.rawValue.computeEnumSize(6)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Services.Notification.Containers.NotificationTokenV1> {
      var mergedArray = Array<Services.Notification.Containers.NotificationTokenV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Services.Notification.Containers.NotificationTokenV1? {
      return try Services.Notification.Containers.NotificationTokenV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Services.Notification.Containers.NotificationTokenV1 {
      return try Services.Notification.Containers.NotificationTokenV1.Builder().mergeFromData(data, extensionRegistry:Services.Notification.Containers.ContainersRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationTokenV1 {
      return try Services.Notification.Containers.NotificationTokenV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Services.Notification.Containers.NotificationTokenV1 {
      return try Services.Notification.Containers.NotificationTokenV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationTokenV1 {
      return try Services.Notification.Containers.NotificationTokenV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Services.Notification.Containers.NotificationTokenV1 {
      return try Services.Notification.Containers.NotificationTokenV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationTokenV1 {
      return try Services.Notification.Containers.NotificationTokenV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Services.Notification.Containers.NotificationTokenV1.Builder {
      return Services.Notification.Containers.NotificationTokenV1.classBuilder() as! Services.Notification.Containers.NotificationTokenV1.Builder
    }
    public func getBuilder() -> Services.Notification.Containers.NotificationTokenV1.Builder {
      return classBuilder() as! Services.Notification.Containers.NotificationTokenV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Services.Notification.Containers.NotificationTokenV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Services.Notification.Containers.NotificationTokenV1.Builder()
    }
    public func toBuilder() throws -> Services.Notification.Containers.NotificationTokenV1.Builder {
      return try Services.Notification.Containers.NotificationTokenV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Services.Notification.Containers.NotificationTokenV1) throws -> Services.Notification.Containers.NotificationTokenV1.Builder {
      return try Services.Notification.Containers.NotificationTokenV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasUserId {
        output += "\(indent) userId: \(userId) \n"
      }
      if hasDeviceId {
        output += "\(indent) deviceId: \(deviceId) \n"
      }
      if hasProviderToken {
        output += "\(indent) providerToken: \(providerToken) \n"
      }
      if (hasProvider) {
        output += "\(indent) provider: \(provider.rawValue)\n"
      }
      if (hasProviderPlatform) {
        output += "\(indent) providerPlatform: \(providerPlatform.rawValue)\n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasUserId {
               hashCode = (hashCode &* 31) &+ userId.hashValue
            }
            if hasDeviceId {
               hashCode = (hashCode &* 31) &+ deviceId.hashValue
            }
            if hasProviderToken {
               hashCode = (hashCode &* 31) &+ providerToken.hashValue
            }
            if hasProvider {
               hashCode = (hashCode &* 31) &+ Int(provider.rawValue)
            }
            if hasProviderPlatform {
               hashCode = (hashCode &* 31) &+ Int(providerPlatform.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Services.Notification.Containers.NotificationTokenV1"
    }
    override public func className() -> String {
        return "Services.Notification.Containers.NotificationTokenV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Services.Notification.Containers.NotificationTokenV1.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Services.Notification.Containers.NotificationTokenV1 = Services.Notification.Containers.NotificationTokenV1()
      public func getMessage() -> Services.Notification.Containers.NotificationTokenV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Services.Notification.Containers.NotificationTokenV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Services.Notification.Containers.NotificationTokenV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
      public var hasUserId:Bool {
           get {
                return builderResult.hasUserId
           }
      }
      public var userId:String {
           get {
                return builderResult.userId
           }
           set (value) {
               builderResult.hasUserId = true
               builderResult.userId = value
           }
      }
      public func setUserId(value:String) -> Services.Notification.Containers.NotificationTokenV1.Builder {
        self.userId = value
        return self
      }
      public func clearUserId() -> Services.Notification.Containers.NotificationTokenV1.Builder{
           builderResult.hasUserId = false
           builderResult.userId = ""
           return self
      }
      public var hasDeviceId:Bool {
           get {
                return builderResult.hasDeviceId
           }
      }
      public var deviceId:String {
           get {
                return builderResult.deviceId
           }
           set (value) {
               builderResult.hasDeviceId = true
               builderResult.deviceId = value
           }
      }
      public func setDeviceId(value:String) -> Services.Notification.Containers.NotificationTokenV1.Builder {
        self.deviceId = value
        return self
      }
      public func clearDeviceId() -> Services.Notification.Containers.NotificationTokenV1.Builder{
           builderResult.hasDeviceId = false
           builderResult.deviceId = ""
           return self
      }
      public var hasProviderToken:Bool {
           get {
                return builderResult.hasProviderToken
           }
      }
      public var providerToken:String {
           get {
                return builderResult.providerToken
           }
           set (value) {
               builderResult.hasProviderToken = true
               builderResult.providerToken = value
           }
      }
      public func setProviderToken(value:String) -> Services.Notification.Containers.NotificationTokenV1.Builder {
        self.providerToken = value
        return self
      }
      public func clearProviderToken() -> Services.Notification.Containers.NotificationTokenV1.Builder{
           builderResult.hasProviderToken = false
           builderResult.providerToken = ""
           return self
      }
        public var hasProvider:Bool{
            get {
                return builderResult.hasProvider
            }
        }
        public var provider:Services.Notification.Containers.NotificationTokenV1.ProviderV1 {
            get {
                return builderResult.provider
            }
            set (value) {
                builderResult.hasProvider = true
                builderResult.provider = value
            }
        }
        public func setProvider(value:Services.Notification.Containers.NotificationTokenV1.ProviderV1) -> Services.Notification.Containers.NotificationTokenV1.Builder {
          self.provider = value
          return self
        }
        public func clearProvider() -> Services.Notification.Containers.NotificationTokenV1.Builder {
           builderResult.hasProvider = false
           builderResult.provider = .Sns
           return self
        }
        public var hasProviderPlatform:Bool{
            get {
                return builderResult.hasProviderPlatform
            }
        }
        public var providerPlatform:Services.Notification.Containers.NotificationTokenV1.ProviderPlatformV1 {
            get {
                return builderResult.providerPlatform
            }
            set (value) {
                builderResult.hasProviderPlatform = true
                builderResult.providerPlatform = value
            }
        }
        public func setProviderPlatform(value:Services.Notification.Containers.NotificationTokenV1.ProviderPlatformV1) -> Services.Notification.Containers.NotificationTokenV1.Builder {
          self.providerPlatform = value
          return self
        }
        public func clearProviderPlatform() -> Services.Notification.Containers.NotificationTokenV1.Builder {
           builderResult.hasProviderPlatform = false
           builderResult.providerPlatform = .Apns
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      public override func clear() -> Services.Notification.Containers.NotificationTokenV1.Builder {
        builderResult = Services.Notification.Containers.NotificationTokenV1()
        return self
      }
      public override func clone() throws -> Services.Notification.Containers.NotificationTokenV1.Builder {
        return try Services.Notification.Containers.NotificationTokenV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Services.Notification.Containers.NotificationTokenV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Services.Notification.Containers.NotificationTokenV1 {
        let returnMe:Services.Notification.Containers.NotificationTokenV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Services.Notification.Containers.NotificationTokenV1) throws -> Services.Notification.Containers.NotificationTokenV1.Builder {
        if other == Services.Notification.Containers.NotificationTokenV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if other.hasUserId {
             userId = other.userId
        }
        if other.hasDeviceId {
             deviceId = other.deviceId
        }
        if other.hasProviderToken {
             providerToken = other.providerToken
        }
        if other.hasProvider {
             provider = other.provider
        }
        if other.hasProviderPlatform {
             providerPlatform = other.providerPlatform
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Services.Notification.Containers.NotificationTokenV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationTokenV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 18 :
            userId = try input.readString()

          case 26 :
            deviceId = try input.readString()

          case 34 :
            providerToken = try input.readString()

          case 40 :
            let valueIntprovider = try input.readEnum()
            if let enumsprovider = Services.Notification.Containers.NotificationTokenV1.ProviderV1(rawValue:valueIntprovider){
                 provider = enumsprovider
            } else {
                 try unknownFieldsBuilder.mergeVarintField(5, value:Int64(valueIntprovider))
            }

          case 48 :
            let valueIntproviderPlatform = try input.readEnum()
            if let enumsproviderPlatform = Services.Notification.Containers.NotificationTokenV1.ProviderPlatformV1(rawValue:valueIntproviderPlatform){
                 providerPlatform = enumsproviderPlatform
            } else {
                 try unknownFieldsBuilder.mergeVarintField(6, value:Int64(valueIntproviderPlatform))
            }

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final public class NotificationPreferenceV1 : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasId:Bool = false
    public private(set) var id:String = ""

    public private(set) var hasProfileId:Bool = false
    public private(set) var profileId:String = ""

    public private(set) var notificationTypeId:Services.Notification.Containers.NotificationTypeV1.TypeIdV1 = Services.Notification.Containers.NotificationTypeV1.TypeIdV1.GoogleGroups
    public private(set) var hasNotificationTypeId:Bool = false
    public private(set) var hasSubscribed:Bool = false
    public private(set) var subscribed:Bool = false

    public private(set) var hasNotificationType:Bool = false
    public private(set) var notificationType:Services.Notification.Containers.NotificationTypeV1!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasId {
        try output.writeString(2, value:id)
      }
      if hasProfileId {
        try output.writeString(3, value:profileId)
      }
      if hasNotificationTypeId {
        try output.writeEnum(4, value:notificationTypeId.rawValue)
      }
      if hasSubscribed {
        try output.writeBool(5, value:subscribed)
      }
      if hasNotificationType {
        try output.writeMessage(6, value:notificationType)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasId {
        serialize_size += id.computeStringSize(2)
      }
      if hasProfileId {
        serialize_size += profileId.computeStringSize(3)
      }
      if (hasNotificationTypeId) {
        serialize_size += notificationTypeId.rawValue.computeEnumSize(4)
      }
      if hasSubscribed {
        serialize_size += subscribed.computeBoolSize(5)
      }
      if hasNotificationType {
          if let varSizenotificationType = notificationType?.computeMessageSize(6) {
              serialize_size += varSizenotificationType
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Services.Notification.Containers.NotificationPreferenceV1> {
      var mergedArray = Array<Services.Notification.Containers.NotificationPreferenceV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Services.Notification.Containers.NotificationPreferenceV1? {
      return try Services.Notification.Containers.NotificationPreferenceV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Services.Notification.Containers.NotificationPreferenceV1 {
      return try Services.Notification.Containers.NotificationPreferenceV1.Builder().mergeFromData(data, extensionRegistry:Services.Notification.Containers.ContainersRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationPreferenceV1 {
      return try Services.Notification.Containers.NotificationPreferenceV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Services.Notification.Containers.NotificationPreferenceV1 {
      return try Services.Notification.Containers.NotificationPreferenceV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationPreferenceV1 {
      return try Services.Notification.Containers.NotificationPreferenceV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Services.Notification.Containers.NotificationPreferenceV1 {
      return try Services.Notification.Containers.NotificationPreferenceV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationPreferenceV1 {
      return try Services.Notification.Containers.NotificationPreferenceV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
      return Services.Notification.Containers.NotificationPreferenceV1.classBuilder() as! Services.Notification.Containers.NotificationPreferenceV1.Builder
    }
    public func getBuilder() -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
      return classBuilder() as! Services.Notification.Containers.NotificationPreferenceV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Services.Notification.Containers.NotificationPreferenceV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Services.Notification.Containers.NotificationPreferenceV1.Builder()
    }
    public func toBuilder() throws -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
      return try Services.Notification.Containers.NotificationPreferenceV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Services.Notification.Containers.NotificationPreferenceV1) throws -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
      return try Services.Notification.Containers.NotificationPreferenceV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasId {
        output += "\(indent) id: \(id) \n"
      }
      if hasProfileId {
        output += "\(indent) profileId: \(profileId) \n"
      }
      if (hasNotificationTypeId) {
        output += "\(indent) notificationTypeId: \(notificationTypeId.rawValue)\n"
      }
      if hasSubscribed {
        output += "\(indent) subscribed: \(subscribed) \n"
      }
      if hasNotificationType {
        output += "\(indent) notificationType {\n"
        try notificationType?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasId {
               hashCode = (hashCode &* 31) &+ id.hashValue
            }
            if hasProfileId {
               hashCode = (hashCode &* 31) &+ profileId.hashValue
            }
            if hasNotificationTypeId {
               hashCode = (hashCode &* 31) &+ Int(notificationTypeId.rawValue)
            }
            if hasSubscribed {
               hashCode = (hashCode &* 31) &+ subscribed.hashValue
            }
            if hasNotificationType {
                if let hashValuenotificationType = notificationType?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuenotificationType
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Services.Notification.Containers.NotificationPreferenceV1"
    }
    override public func className() -> String {
        return "Services.Notification.Containers.NotificationPreferenceV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Services.Notification.Containers.NotificationPreferenceV1.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Services.Notification.Containers.NotificationPreferenceV1 = Services.Notification.Containers.NotificationPreferenceV1()
      public func getMessage() -> Services.Notification.Containers.NotificationPreferenceV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Services.Notification.Containers.NotificationPreferenceV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
      public var hasId:Bool {
           get {
                return builderResult.hasId
           }
      }
      public var id:String {
           get {
                return builderResult.id
           }
           set (value) {
               builderResult.hasId = true
               builderResult.id = value
           }
      }
      public func setId(value:String) -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
        self.id = value
        return self
      }
      public func clearId() -> Services.Notification.Containers.NotificationPreferenceV1.Builder{
           builderResult.hasId = false
           builderResult.id = ""
           return self
      }
      public var hasProfileId:Bool {
           get {
                return builderResult.hasProfileId
           }
      }
      public var profileId:String {
           get {
                return builderResult.profileId
           }
           set (value) {
               builderResult.hasProfileId = true
               builderResult.profileId = value
           }
      }
      public func setProfileId(value:String) -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
        self.profileId = value
        return self
      }
      public func clearProfileId() -> Services.Notification.Containers.NotificationPreferenceV1.Builder{
           builderResult.hasProfileId = false
           builderResult.profileId = ""
           return self
      }
        public var hasNotificationTypeId:Bool{
            get {
                return builderResult.hasNotificationTypeId
            }
        }
        public var notificationTypeId:Services.Notification.Containers.NotificationTypeV1.TypeIdV1 {
            get {
                return builderResult.notificationTypeId
            }
            set (value) {
                builderResult.hasNotificationTypeId = true
                builderResult.notificationTypeId = value
            }
        }
        public func setNotificationTypeId(value:Services.Notification.Containers.NotificationTypeV1.TypeIdV1) -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
          self.notificationTypeId = value
          return self
        }
        public func clearNotificationTypeId() -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
           builderResult.hasNotificationTypeId = false
           builderResult.notificationTypeId = .GoogleGroups
           return self
        }
      public var hasSubscribed:Bool {
           get {
                return builderResult.hasSubscribed
           }
      }
      public var subscribed:Bool {
           get {
                return builderResult.subscribed
           }
           set (value) {
               builderResult.hasSubscribed = true
               builderResult.subscribed = value
           }
      }
      public func setSubscribed(value:Bool) -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
        self.subscribed = value
        return self
      }
      public func clearSubscribed() -> Services.Notification.Containers.NotificationPreferenceV1.Builder{
           builderResult.hasSubscribed = false
           builderResult.subscribed = false
           return self
      }
      public var hasNotificationType:Bool {
           get {
               return builderResult.hasNotificationType
           }
      }
      public var notificationType:Services.Notification.Containers.NotificationTypeV1! {
           get {
               if notificationTypeBuilder_ != nil {
                  builderResult.notificationType = notificationTypeBuilder_.getMessage()
               }
               return builderResult.notificationType
           }
           set (value) {
               builderResult.hasNotificationType = true
               builderResult.notificationType = value
           }
      }
      private var notificationTypeBuilder_:Services.Notification.Containers.NotificationTypeV1.Builder! {
           didSet {
              builderResult.hasNotificationType = true
           }
      }
      public func getNotificationTypeBuilder() -> Services.Notification.Containers.NotificationTypeV1.Builder {
        if notificationTypeBuilder_ == nil {
           notificationTypeBuilder_ = Services.Notification.Containers.NotificationTypeV1.Builder()
           builderResult.notificationType = notificationTypeBuilder_.getMessage()
           if notificationType != nil {
              try! notificationTypeBuilder_.mergeFrom(notificationType)
           }
        }
        return notificationTypeBuilder_
      }
      public func setNotificationType(value:Services.Notification.Containers.NotificationTypeV1!) -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
        self.notificationType = value
        return self
      }
      public func mergeNotificationType(value:Services.Notification.Containers.NotificationTypeV1) throws -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
        if builderResult.hasNotificationType {
          builderResult.notificationType = try Services.Notification.Containers.NotificationTypeV1.builderWithPrototype(builderResult.notificationType).mergeFrom(value).buildPartial()
        } else {
          builderResult.notificationType = value
        }
        builderResult.hasNotificationType = true
        return self
      }
      public func clearNotificationType() -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
        notificationTypeBuilder_ = nil
        builderResult.hasNotificationType = false
        builderResult.notificationType = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      public override func clear() -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
        builderResult = Services.Notification.Containers.NotificationPreferenceV1()
        return self
      }
      public override func clone() throws -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
        return try Services.Notification.Containers.NotificationPreferenceV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Services.Notification.Containers.NotificationPreferenceV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Services.Notification.Containers.NotificationPreferenceV1 {
        let returnMe:Services.Notification.Containers.NotificationPreferenceV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Services.Notification.Containers.NotificationPreferenceV1) throws -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
        if other == Services.Notification.Containers.NotificationPreferenceV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if other.hasId {
             id = other.id
        }
        if other.hasProfileId {
             profileId = other.profileId
        }
        if other.hasNotificationTypeId {
             notificationTypeId = other.notificationTypeId
        }
        if other.hasSubscribed {
             subscribed = other.subscribed
        }
        if (other.hasNotificationType) {
            try mergeNotificationType(other.notificationType)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationPreferenceV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 18 :
            id = try input.readString()

          case 26 :
            profileId = try input.readString()

          case 32 :
            let valueIntnotificationTypeId = try input.readEnum()
            if let enumsnotificationTypeId = Services.Notification.Containers.NotificationTypeV1.TypeIdV1(rawValue:valueIntnotificationTypeId){
                 notificationTypeId = enumsnotificationTypeId
            } else {
                 try unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueIntnotificationTypeId))
            }

          case 40 :
            subscribed = try input.readBool()

          case 50 :
            let subBuilder:Services.Notification.Containers.NotificationTypeV1.Builder = Services.Notification.Containers.NotificationTypeV1.Builder()
            if hasNotificationType {
              try subBuilder.mergeFrom(notificationType)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            notificationType = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final public class NotificationTypeV1 : GeneratedMessage, GeneratedMessageProtocol {


      //Enum type declaration start 

      public enum TypeIdV1:Int32 {
        case GoogleGroups = 0

      }

      //Enum type declaration end 

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var id:Services.Notification.Containers.NotificationTypeV1.TypeIdV1 = Services.Notification.Containers.NotificationTypeV1.TypeIdV1.GoogleGroups
    public private(set) var hasId:Bool = false
    public private(set) var hasDescription:Bool = false
    public private(set) var description_:String = ""

    public private(set) var hasOptIn:Bool = false
    public private(set) var optIn:Bool = false

    public private(set) var hasMobilePush:Bool = false
    public private(set) var mobilePush:Bool = false

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasId {
        try output.writeEnum(2, value:id.rawValue)
      }
      if hasDescription {
        try output.writeString(3, value:description_)
      }
      if hasOptIn {
        try output.writeBool(4, value:optIn)
      }
      if hasMobilePush {
        try output.writeBool(5, value:mobilePush)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if (hasId) {
        serialize_size += id.rawValue.computeEnumSize(2)
      }
      if hasDescription {
        serialize_size += description_.computeStringSize(3)
      }
      if hasOptIn {
        serialize_size += optIn.computeBoolSize(4)
      }
      if hasMobilePush {
        serialize_size += mobilePush.computeBoolSize(5)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Services.Notification.Containers.NotificationTypeV1> {
      var mergedArray = Array<Services.Notification.Containers.NotificationTypeV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Services.Notification.Containers.NotificationTypeV1? {
      return try Services.Notification.Containers.NotificationTypeV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Services.Notification.Containers.NotificationTypeV1 {
      return try Services.Notification.Containers.NotificationTypeV1.Builder().mergeFromData(data, extensionRegistry:Services.Notification.Containers.ContainersRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationTypeV1 {
      return try Services.Notification.Containers.NotificationTypeV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Services.Notification.Containers.NotificationTypeV1 {
      return try Services.Notification.Containers.NotificationTypeV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationTypeV1 {
      return try Services.Notification.Containers.NotificationTypeV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Services.Notification.Containers.NotificationTypeV1 {
      return try Services.Notification.Containers.NotificationTypeV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationTypeV1 {
      return try Services.Notification.Containers.NotificationTypeV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Services.Notification.Containers.NotificationTypeV1.Builder {
      return Services.Notification.Containers.NotificationTypeV1.classBuilder() as! Services.Notification.Containers.NotificationTypeV1.Builder
    }
    public func getBuilder() -> Services.Notification.Containers.NotificationTypeV1.Builder {
      return classBuilder() as! Services.Notification.Containers.NotificationTypeV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Services.Notification.Containers.NotificationTypeV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Services.Notification.Containers.NotificationTypeV1.Builder()
    }
    public func toBuilder() throws -> Services.Notification.Containers.NotificationTypeV1.Builder {
      return try Services.Notification.Containers.NotificationTypeV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Services.Notification.Containers.NotificationTypeV1) throws -> Services.Notification.Containers.NotificationTypeV1.Builder {
      return try Services.Notification.Containers.NotificationTypeV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if (hasId) {
        output += "\(indent) id: \(id.rawValue)\n"
      }
      if hasDescription {
        output += "\(indent) description_: \(description_) \n"
      }
      if hasOptIn {
        output += "\(indent) optIn: \(optIn) \n"
      }
      if hasMobilePush {
        output += "\(indent) mobilePush: \(mobilePush) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasId {
               hashCode = (hashCode &* 31) &+ Int(id.rawValue)
            }
            if hasDescription {
               hashCode = (hashCode &* 31) &+ description_.hashValue
            }
            if hasOptIn {
               hashCode = (hashCode &* 31) &+ optIn.hashValue
            }
            if hasMobilePush {
               hashCode = (hashCode &* 31) &+ mobilePush.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Services.Notification.Containers.NotificationTypeV1"
    }
    override public func className() -> String {
        return "Services.Notification.Containers.NotificationTypeV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Services.Notification.Containers.NotificationTypeV1.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Services.Notification.Containers.NotificationTypeV1 = Services.Notification.Containers.NotificationTypeV1()
      public func getMessage() -> Services.Notification.Containers.NotificationTypeV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Services.Notification.Containers.NotificationTypeV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Services.Notification.Containers.NotificationTypeV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
        public var hasId:Bool{
            get {
                return builderResult.hasId
            }
        }
        public var id:Services.Notification.Containers.NotificationTypeV1.TypeIdV1 {
            get {
                return builderResult.id
            }
            set (value) {
                builderResult.hasId = true
                builderResult.id = value
            }
        }
        public func setId(value:Services.Notification.Containers.NotificationTypeV1.TypeIdV1) -> Services.Notification.Containers.NotificationTypeV1.Builder {
          self.id = value
          return self
        }
        public func clearId() -> Services.Notification.Containers.NotificationTypeV1.Builder {
           builderResult.hasId = false
           builderResult.id = .GoogleGroups
           return self
        }
      public var hasDescription:Bool {
           get {
                return builderResult.hasDescription
           }
      }
      public var description_:String {
           get {
                return builderResult.description_
           }
           set (value) {
               builderResult.hasDescription = true
               builderResult.description_ = value
           }
      }
      public func setDescription(value:String) -> Services.Notification.Containers.NotificationTypeV1.Builder {
        self.description_ = value
        return self
      }
      public func clearDescription() -> Services.Notification.Containers.NotificationTypeV1.Builder{
           builderResult.hasDescription = false
           builderResult.description_ = ""
           return self
      }
      public var hasOptIn:Bool {
           get {
                return builderResult.hasOptIn
           }
      }
      public var optIn:Bool {
           get {
                return builderResult.optIn
           }
           set (value) {
               builderResult.hasOptIn = true
               builderResult.optIn = value
           }
      }
      public func setOptIn(value:Bool) -> Services.Notification.Containers.NotificationTypeV1.Builder {
        self.optIn = value
        return self
      }
      public func clearOptIn() -> Services.Notification.Containers.NotificationTypeV1.Builder{
           builderResult.hasOptIn = false
           builderResult.optIn = false
           return self
      }
      public var hasMobilePush:Bool {
           get {
                return builderResult.hasMobilePush
           }
      }
      public var mobilePush:Bool {
           get {
                return builderResult.mobilePush
           }
           set (value) {
               builderResult.hasMobilePush = true
               builderResult.mobilePush = value
           }
      }
      public func setMobilePush(value:Bool) -> Services.Notification.Containers.NotificationTypeV1.Builder {
        self.mobilePush = value
        return self
      }
      public func clearMobilePush() -> Services.Notification.Containers.NotificationTypeV1.Builder{
           builderResult.hasMobilePush = false
           builderResult.mobilePush = false
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      public override func clear() -> Services.Notification.Containers.NotificationTypeV1.Builder {
        builderResult = Services.Notification.Containers.NotificationTypeV1()
        return self
      }
      public override func clone() throws -> Services.Notification.Containers.NotificationTypeV1.Builder {
        return try Services.Notification.Containers.NotificationTypeV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Services.Notification.Containers.NotificationTypeV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Services.Notification.Containers.NotificationTypeV1 {
        let returnMe:Services.Notification.Containers.NotificationTypeV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Services.Notification.Containers.NotificationTypeV1) throws -> Services.Notification.Containers.NotificationTypeV1.Builder {
        if other == Services.Notification.Containers.NotificationTypeV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if other.hasId {
             id = other.id
        }
        if other.hasDescription {
             description_ = other.description_
        }
        if other.hasOptIn {
             optIn = other.optIn
        }
        if other.hasMobilePush {
             mobilePush = other.mobilePush
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Services.Notification.Containers.NotificationTypeV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationTypeV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 16 :
            let valueIntid = try input.readEnum()
            if let enumsid = Services.Notification.Containers.NotificationTypeV1.TypeIdV1(rawValue:valueIntid){
                 id = enumsid
            } else {
                 try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntid))
            }

          case 26 :
            description_ = try input.readString()

          case 32 :
            optIn = try input.readBool()

          case 40 :
            mobilePush = try input.readBool()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final public class NotificationV1 : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var notificationTypeId:Services.Notification.Containers.NotificationTypeV1.TypeIdV1 = Services.Notification.Containers.NotificationTypeV1.TypeIdV1.GoogleGroups
    public private(set) var hasNotificationTypeId:Bool = false
    public private(set) var hasGroupMembershipRequest:Bool = false
    public private(set) var groupMembershipRequest:Services.Notification.Containers.GroupMembershipRequestNotificationV1!
    public private(set) var hasGroupMembershipRequestResponse:Bool = false
    public private(set) var groupMembershipRequestResponse:Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasNotificationTypeId {
        try output.writeEnum(2, value:notificationTypeId.rawValue)
      }
      if hasGroupMembershipRequest {
        try output.writeMessage(3, value:groupMembershipRequest)
      }
      if hasGroupMembershipRequestResponse {
        try output.writeMessage(4, value:groupMembershipRequestResponse)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if (hasNotificationTypeId) {
        serialize_size += notificationTypeId.rawValue.computeEnumSize(2)
      }
      if hasGroupMembershipRequest {
          if let varSizegroupMembershipRequest = groupMembershipRequest?.computeMessageSize(3) {
              serialize_size += varSizegroupMembershipRequest
          }
      }
      if hasGroupMembershipRequestResponse {
          if let varSizegroupMembershipRequestResponse = groupMembershipRequestResponse?.computeMessageSize(4) {
              serialize_size += varSizegroupMembershipRequestResponse
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Services.Notification.Containers.NotificationV1> {
      var mergedArray = Array<Services.Notification.Containers.NotificationV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Services.Notification.Containers.NotificationV1? {
      return try Services.Notification.Containers.NotificationV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Services.Notification.Containers.NotificationV1 {
      return try Services.Notification.Containers.NotificationV1.Builder().mergeFromData(data, extensionRegistry:Services.Notification.Containers.ContainersRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationV1 {
      return try Services.Notification.Containers.NotificationV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Services.Notification.Containers.NotificationV1 {
      return try Services.Notification.Containers.NotificationV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationV1 {
      return try Services.Notification.Containers.NotificationV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Services.Notification.Containers.NotificationV1 {
      return try Services.Notification.Containers.NotificationV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationV1 {
      return try Services.Notification.Containers.NotificationV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Services.Notification.Containers.NotificationV1.Builder {
      return Services.Notification.Containers.NotificationV1.classBuilder() as! Services.Notification.Containers.NotificationV1.Builder
    }
    public func getBuilder() -> Services.Notification.Containers.NotificationV1.Builder {
      return classBuilder() as! Services.Notification.Containers.NotificationV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Services.Notification.Containers.NotificationV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Services.Notification.Containers.NotificationV1.Builder()
    }
    public func toBuilder() throws -> Services.Notification.Containers.NotificationV1.Builder {
      return try Services.Notification.Containers.NotificationV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Services.Notification.Containers.NotificationV1) throws -> Services.Notification.Containers.NotificationV1.Builder {
      return try Services.Notification.Containers.NotificationV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if (hasNotificationTypeId) {
        output += "\(indent) notificationTypeId: \(notificationTypeId.rawValue)\n"
      }
      if hasGroupMembershipRequest {
        output += "\(indent) groupMembershipRequest {\n"
        try groupMembershipRequest?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasGroupMembershipRequestResponse {
        output += "\(indent) groupMembershipRequestResponse {\n"
        try groupMembershipRequestResponse?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasNotificationTypeId {
               hashCode = (hashCode &* 31) &+ Int(notificationTypeId.rawValue)
            }
            if hasGroupMembershipRequest {
                if let hashValuegroupMembershipRequest = groupMembershipRequest?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegroupMembershipRequest
                }
            }
            if hasGroupMembershipRequestResponse {
                if let hashValuegroupMembershipRequestResponse = groupMembershipRequestResponse?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuegroupMembershipRequestResponse
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Services.Notification.Containers.NotificationV1"
    }
    override public func className() -> String {
        return "Services.Notification.Containers.NotificationV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Services.Notification.Containers.NotificationV1.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Services.Notification.Containers.NotificationV1 = Services.Notification.Containers.NotificationV1()
      public func getMessage() -> Services.Notification.Containers.NotificationV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Services.Notification.Containers.NotificationV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Services.Notification.Containers.NotificationV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
        public var hasNotificationTypeId:Bool{
            get {
                return builderResult.hasNotificationTypeId
            }
        }
        public var notificationTypeId:Services.Notification.Containers.NotificationTypeV1.TypeIdV1 {
            get {
                return builderResult.notificationTypeId
            }
            set (value) {
                builderResult.hasNotificationTypeId = true
                builderResult.notificationTypeId = value
            }
        }
        public func setNotificationTypeId(value:Services.Notification.Containers.NotificationTypeV1.TypeIdV1) -> Services.Notification.Containers.NotificationV1.Builder {
          self.notificationTypeId = value
          return self
        }
        public func clearNotificationTypeId() -> Services.Notification.Containers.NotificationV1.Builder {
           builderResult.hasNotificationTypeId = false
           builderResult.notificationTypeId = .GoogleGroups
           return self
        }
      public var hasGroupMembershipRequest:Bool {
           get {
               return builderResult.hasGroupMembershipRequest
           }
      }
      public var groupMembershipRequest:Services.Notification.Containers.GroupMembershipRequestNotificationV1! {
           get {
               if groupMembershipRequestBuilder_ != nil {
                  builderResult.groupMembershipRequest = groupMembershipRequestBuilder_.getMessage()
               }
               return builderResult.groupMembershipRequest
           }
           set (value) {
               builderResult.hasGroupMembershipRequest = true
               builderResult.groupMembershipRequest = value
           }
      }
      private var groupMembershipRequestBuilder_:Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder! {
           didSet {
              builderResult.hasGroupMembershipRequest = true
           }
      }
      public func getGroupMembershipRequestBuilder() -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
        if groupMembershipRequestBuilder_ == nil {
           groupMembershipRequestBuilder_ = Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder()
           builderResult.groupMembershipRequest = groupMembershipRequestBuilder_.getMessage()
           if groupMembershipRequest != nil {
              try! groupMembershipRequestBuilder_.mergeFrom(groupMembershipRequest)
           }
        }
        return groupMembershipRequestBuilder_
      }
      public func setGroupMembershipRequest(value:Services.Notification.Containers.GroupMembershipRequestNotificationV1!) -> Services.Notification.Containers.NotificationV1.Builder {
        self.groupMembershipRequest = value
        return self
      }
      public func mergeGroupMembershipRequest(value:Services.Notification.Containers.GroupMembershipRequestNotificationV1) throws -> Services.Notification.Containers.NotificationV1.Builder {
        if builderResult.hasGroupMembershipRequest {
          builderResult.groupMembershipRequest = try Services.Notification.Containers.GroupMembershipRequestNotificationV1.builderWithPrototype(builderResult.groupMembershipRequest).mergeFrom(value).buildPartial()
        } else {
          builderResult.groupMembershipRequest = value
        }
        builderResult.hasGroupMembershipRequest = true
        return self
      }
      public func clearGroupMembershipRequest() -> Services.Notification.Containers.NotificationV1.Builder {
        groupMembershipRequestBuilder_ = nil
        builderResult.hasGroupMembershipRequest = false
        builderResult.groupMembershipRequest = nil
        return self
      }
      public var hasGroupMembershipRequestResponse:Bool {
           get {
               return builderResult.hasGroupMembershipRequestResponse
           }
      }
      public var groupMembershipRequestResponse:Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1! {
           get {
               if groupMembershipRequestResponseBuilder_ != nil {
                  builderResult.groupMembershipRequestResponse = groupMembershipRequestResponseBuilder_.getMessage()
               }
               return builderResult.groupMembershipRequestResponse
           }
           set (value) {
               builderResult.hasGroupMembershipRequestResponse = true
               builderResult.groupMembershipRequestResponse = value
           }
      }
      private var groupMembershipRequestResponseBuilder_:Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder! {
           didSet {
              builderResult.hasGroupMembershipRequestResponse = true
           }
      }
      public func getGroupMembershipRequestResponseBuilder() -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
        if groupMembershipRequestResponseBuilder_ == nil {
           groupMembershipRequestResponseBuilder_ = Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder()
           builderResult.groupMembershipRequestResponse = groupMembershipRequestResponseBuilder_.getMessage()
           if groupMembershipRequestResponse != nil {
              try! groupMembershipRequestResponseBuilder_.mergeFrom(groupMembershipRequestResponse)
           }
        }
        return groupMembershipRequestResponseBuilder_
      }
      public func setGroupMembershipRequestResponse(value:Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1!) -> Services.Notification.Containers.NotificationV1.Builder {
        self.groupMembershipRequestResponse = value
        return self
      }
      public func mergeGroupMembershipRequestResponse(value:Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1) throws -> Services.Notification.Containers.NotificationV1.Builder {
        if builderResult.hasGroupMembershipRequestResponse {
          builderResult.groupMembershipRequestResponse = try Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.builderWithPrototype(builderResult.groupMembershipRequestResponse).mergeFrom(value).buildPartial()
        } else {
          builderResult.groupMembershipRequestResponse = value
        }
        builderResult.hasGroupMembershipRequestResponse = true
        return self
      }
      public func clearGroupMembershipRequestResponse() -> Services.Notification.Containers.NotificationV1.Builder {
        groupMembershipRequestResponseBuilder_ = nil
        builderResult.hasGroupMembershipRequestResponse = false
        builderResult.groupMembershipRequestResponse = nil
        return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      public override func clear() -> Services.Notification.Containers.NotificationV1.Builder {
        builderResult = Services.Notification.Containers.NotificationV1()
        return self
      }
      public override func clone() throws -> Services.Notification.Containers.NotificationV1.Builder {
        return try Services.Notification.Containers.NotificationV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Services.Notification.Containers.NotificationV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Services.Notification.Containers.NotificationV1 {
        let returnMe:Services.Notification.Containers.NotificationV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Services.Notification.Containers.NotificationV1) throws -> Services.Notification.Containers.NotificationV1.Builder {
        if other == Services.Notification.Containers.NotificationV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if other.hasNotificationTypeId {
             notificationTypeId = other.notificationTypeId
        }
        if (other.hasGroupMembershipRequest) {
            try mergeGroupMembershipRequest(other.groupMembershipRequest)
        }
        if (other.hasGroupMembershipRequestResponse) {
            try mergeGroupMembershipRequestResponse(other.groupMembershipRequestResponse)
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Services.Notification.Containers.NotificationV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.NotificationV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 16 :
            let valueIntnotificationTypeId = try input.readEnum()
            if let enumsnotificationTypeId = Services.Notification.Containers.NotificationTypeV1.TypeIdV1(rawValue:valueIntnotificationTypeId){
                 notificationTypeId = enumsnotificationTypeId
            } else {
                 try unknownFieldsBuilder.mergeVarintField(2, value:Int64(valueIntnotificationTypeId))
            }

          case 26 :
            let subBuilder:Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder = Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder()
            if hasGroupMembershipRequest {
              try subBuilder.mergeFrom(groupMembershipRequest)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            groupMembershipRequest = subBuilder.buildPartial()

          case 34 :
            let subBuilder:Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder = Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder()
            if hasGroupMembershipRequestResponse {
              try subBuilder.mergeFrom(groupMembershipRequestResponse)
            }
            try input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
            groupMembershipRequestResponse = subBuilder.buildPartial()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final public class GroupMembershipRequestNotificationV1 : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasRequesterProfileId:Bool = false
    public private(set) var requesterProfileId:String = ""

    public private(set) var hasGroupId:Bool = false
    public private(set) var groupId:String = ""

    public private(set) var provider:Services.Group.Containers.GroupProviderV1 = Services.Group.Containers.GroupProviderV1.Google
    public private(set) var hasProvider:Bool = false
    public private(set) var hasRequestId:Bool = false
    public private(set) var requestId:String = ""

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasRequesterProfileId {
        try output.writeString(2, value:requesterProfileId)
      }
      if hasGroupId {
        try output.writeString(3, value:groupId)
      }
      if hasProvider {
        try output.writeEnum(4, value:provider.rawValue)
      }
      if hasRequestId {
        try output.writeString(5, value:requestId)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasRequesterProfileId {
        serialize_size += requesterProfileId.computeStringSize(2)
      }
      if hasGroupId {
        serialize_size += groupId.computeStringSize(3)
      }
      if (hasProvider) {
        serialize_size += provider.rawValue.computeEnumSize(4)
      }
      if hasRequestId {
        serialize_size += requestId.computeStringSize(5)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Services.Notification.Containers.GroupMembershipRequestNotificationV1> {
      var mergedArray = Array<Services.Notification.Containers.GroupMembershipRequestNotificationV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1? {
      return try Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1 {
      return try Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder().mergeFromData(data, extensionRegistry:Services.Notification.Containers.ContainersRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1 {
      return try Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1 {
      return try Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1 {
      return try Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1 {
      return try Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1 {
      return try Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
      return Services.Notification.Containers.GroupMembershipRequestNotificationV1.classBuilder() as! Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder
    }
    public func getBuilder() -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
      return classBuilder() as! Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder()
    }
    public func toBuilder() throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
      return try Services.Notification.Containers.GroupMembershipRequestNotificationV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Services.Notification.Containers.GroupMembershipRequestNotificationV1) throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
      return try Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasRequesterProfileId {
        output += "\(indent) requesterProfileId: \(requesterProfileId) \n"
      }
      if hasGroupId {
        output += "\(indent) groupId: \(groupId) \n"
      }
      if (hasProvider) {
        output += "\(indent) provider: \(provider.rawValue)\n"
      }
      if hasRequestId {
        output += "\(indent) requestId: \(requestId) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasRequesterProfileId {
               hashCode = (hashCode &* 31) &+ requesterProfileId.hashValue
            }
            if hasGroupId {
               hashCode = (hashCode &* 31) &+ groupId.hashValue
            }
            if hasProvider {
               hashCode = (hashCode &* 31) &+ Int(provider.rawValue)
            }
            if hasRequestId {
               hashCode = (hashCode &* 31) &+ requestId.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Services.Notification.Containers.GroupMembershipRequestNotificationV1"
    }
    override public func className() -> String {
        return "Services.Notification.Containers.GroupMembershipRequestNotificationV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Services.Notification.Containers.GroupMembershipRequestNotificationV1.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Services.Notification.Containers.GroupMembershipRequestNotificationV1 = Services.Notification.Containers.GroupMembershipRequestNotificationV1()
      public func getMessage() -> Services.Notification.Containers.GroupMembershipRequestNotificationV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
      public var hasRequesterProfileId:Bool {
           get {
                return builderResult.hasRequesterProfileId
           }
      }
      public var requesterProfileId:String {
           get {
                return builderResult.requesterProfileId
           }
           set (value) {
               builderResult.hasRequesterProfileId = true
               builderResult.requesterProfileId = value
           }
      }
      public func setRequesterProfileId(value:String) -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
        self.requesterProfileId = value
        return self
      }
      public func clearRequesterProfileId() -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder{
           builderResult.hasRequesterProfileId = false
           builderResult.requesterProfileId = ""
           return self
      }
      public var hasGroupId:Bool {
           get {
                return builderResult.hasGroupId
           }
      }
      public var groupId:String {
           get {
                return builderResult.groupId
           }
           set (value) {
               builderResult.hasGroupId = true
               builderResult.groupId = value
           }
      }
      public func setGroupId(value:String) -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
        self.groupId = value
        return self
      }
      public func clearGroupId() -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder{
           builderResult.hasGroupId = false
           builderResult.groupId = ""
           return self
      }
        public var hasProvider:Bool{
            get {
                return builderResult.hasProvider
            }
        }
        public var provider:Services.Group.Containers.GroupProviderV1 {
            get {
                return builderResult.provider
            }
            set (value) {
                builderResult.hasProvider = true
                builderResult.provider = value
            }
        }
        public func setProvider(value:Services.Group.Containers.GroupProviderV1) -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
          self.provider = value
          return self
        }
        public func clearProvider() -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
           builderResult.hasProvider = false
           builderResult.provider = .Google
           return self
        }
      public var hasRequestId:Bool {
           get {
                return builderResult.hasRequestId
           }
      }
      public var requestId:String {
           get {
                return builderResult.requestId
           }
           set (value) {
               builderResult.hasRequestId = true
               builderResult.requestId = value
           }
      }
      public func setRequestId(value:String) -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
        self.requestId = value
        return self
      }
      public func clearRequestId() -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder{
           builderResult.hasRequestId = false
           builderResult.requestId = ""
           return self
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      public override func clear() -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
        builderResult = Services.Notification.Containers.GroupMembershipRequestNotificationV1()
        return self
      }
      public override func clone() throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
        return try Services.Notification.Containers.GroupMembershipRequestNotificationV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Services.Notification.Containers.GroupMembershipRequestNotificationV1 {
        let returnMe:Services.Notification.Containers.GroupMembershipRequestNotificationV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Services.Notification.Containers.GroupMembershipRequestNotificationV1) throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
        if other == Services.Notification.Containers.GroupMembershipRequestNotificationV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if other.hasRequesterProfileId {
             requesterProfileId = other.requesterProfileId
        }
        if other.hasGroupId {
             groupId = other.groupId
        }
        if other.hasProvider {
             provider = other.provider
        }
        if other.hasRequestId {
             requestId = other.requestId
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.GroupMembershipRequestNotificationV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 18 :
            requesterProfileId = try input.readString()

          case 26 :
            groupId = try input.readString()

          case 32 :
            let valueIntprovider = try input.readEnum()
            if let enumsprovider = Services.Group.Containers.GroupProviderV1(rawValue:valueIntprovider){
                 provider = enumsprovider
            } else {
                 try unknownFieldsBuilder.mergeVarintField(4, value:Int64(valueIntprovider))
            }

          case 42 :
            requestId = try input.readString()

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

  final public class GroupMembershipRequestResponseNotificationV1 : GeneratedMessage, GeneratedMessageProtocol {
    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasGroupManagerProfileId:Bool = false
    public private(set) var groupManagerProfileId:String = ""

    public private(set) var hasApproved:Bool = false
    public private(set) var approved:Bool = false

    public private(set) var hasGroupId:Bool = false
    public private(set) var groupId:String = ""

    public private(set) var provider:Services.Group.Containers.GroupProviderV1 = Services.Group.Containers.GroupProviderV1.Google
    public private(set) var hasProvider:Bool = false
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) throws {
      if hasVersion {
        try output.writeUInt32(1, value:version)
      }
      if hasGroupManagerProfileId {
        try output.writeString(2, value:groupManagerProfileId)
      }
      if hasApproved {
        try output.writeBool(3, value:approved)
      }
      if hasGroupId {
        try output.writeString(4, value:groupId)
      }
      if hasProvider {
        try output.writeEnum(5, value:provider.rawValue)
      }
      try unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasGroupManagerProfileId {
        serialize_size += groupManagerProfileId.computeStringSize(2)
      }
      if hasApproved {
        serialize_size += approved.computeBoolSize(3)
      }
      if hasGroupId {
        serialize_size += groupId.computeStringSize(4)
      }
      if (hasProvider) {
        serialize_size += provider.rawValue.computeEnumSize(5)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseArrayDelimitedFromInputStream(input:NSInputStream) throws -> Array<Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1> {
      var mergedArray = Array<Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1>()
      while let value = try parseFromDelimitedFromInputStream(input) {
        mergedArray += [value]
      }
      return mergedArray
    }
    public class func parseFromDelimitedFromInputStream(input:NSInputStream) throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1? {
      return try Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder().mergeDelimitedFromInputStream(input)?.build()
    }
    public class func parseFromData(data:NSData) throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1 {
      return try Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder().mergeFromData(data, extensionRegistry:Services.Notification.Containers.ContainersRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1 {
      return try Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1 {
      return try Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1 {
      return try Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1 {
      return try Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1 {
      return try Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func getBuilder() -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
      return Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.classBuilder() as! Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder
    }
    public func getBuilder() -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
      return classBuilder() as! Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder()
    }
    public func toBuilder() throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
      return try Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1) throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
      return try Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) throws {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasGroupManagerProfileId {
        output += "\(indent) groupManagerProfileId: \(groupManagerProfileId) \n"
      }
      if hasApproved {
        output += "\(indent) approved: \(approved) \n"
      }
      if hasGroupId {
        output += "\(indent) groupId: \(groupId) \n"
      }
      if (hasProvider) {
        output += "\(indent) provider: \(provider.rawValue)\n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasGroupManagerProfileId {
               hashCode = (hashCode &* 31) &+ groupManagerProfileId.hashValue
            }
            if hasApproved {
               hashCode = (hashCode &* 31) &+ approved.hashValue
            }
            if hasGroupId {
               hashCode = (hashCode &* 31) &+ groupId.hashValue
            }
            if hasProvider {
               hashCode = (hashCode &* 31) &+ Int(provider.rawValue)
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1"
    }
    override public func className() -> String {
        return "Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.self
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
      private var builderResult:Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1 = Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1()
      public func getMessage() -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1 {
          return builderResult
      }

      required override public init () {
         super.init()
      }
      public var hasVersion:Bool {
           get {
                return builderResult.hasVersion
           }
      }
      public var version:UInt32 {
           get {
                return builderResult.version
           }
           set (value) {
               builderResult.hasVersion = true
               builderResult.version = value
           }
      }
      public func setVersion(value:UInt32) -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
        self.version = value
        return self
      }
      public func clearVersion() -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder{
           builderResult.hasVersion = false
           builderResult.version = UInt32(1)
           return self
      }
      public var hasGroupManagerProfileId:Bool {
           get {
                return builderResult.hasGroupManagerProfileId
           }
      }
      public var groupManagerProfileId:String {
           get {
                return builderResult.groupManagerProfileId
           }
           set (value) {
               builderResult.hasGroupManagerProfileId = true
               builderResult.groupManagerProfileId = value
           }
      }
      public func setGroupManagerProfileId(value:String) -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
        self.groupManagerProfileId = value
        return self
      }
      public func clearGroupManagerProfileId() -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder{
           builderResult.hasGroupManagerProfileId = false
           builderResult.groupManagerProfileId = ""
           return self
      }
      public var hasApproved:Bool {
           get {
                return builderResult.hasApproved
           }
      }
      public var approved:Bool {
           get {
                return builderResult.approved
           }
           set (value) {
               builderResult.hasApproved = true
               builderResult.approved = value
           }
      }
      public func setApproved(value:Bool) -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
        self.approved = value
        return self
      }
      public func clearApproved() -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder{
           builderResult.hasApproved = false
           builderResult.approved = false
           return self
      }
      public var hasGroupId:Bool {
           get {
                return builderResult.hasGroupId
           }
      }
      public var groupId:String {
           get {
                return builderResult.groupId
           }
           set (value) {
               builderResult.hasGroupId = true
               builderResult.groupId = value
           }
      }
      public func setGroupId(value:String) -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
        self.groupId = value
        return self
      }
      public func clearGroupId() -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder{
           builderResult.hasGroupId = false
           builderResult.groupId = ""
           return self
      }
        public var hasProvider:Bool{
            get {
                return builderResult.hasProvider
            }
        }
        public var provider:Services.Group.Containers.GroupProviderV1 {
            get {
                return builderResult.provider
            }
            set (value) {
                builderResult.hasProvider = true
                builderResult.provider = value
            }
        }
        public func setProvider(value:Services.Group.Containers.GroupProviderV1) -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
          self.provider = value
          return self
        }
        public func clearProvider() -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
           builderResult.hasProvider = false
           builderResult.provider = .Google
           return self
        }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      public override func clear() -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
        builderResult = Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1()
        return self
      }
      public override func clone() throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
        return try Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.builderWithPrototype(builderResult)
      }
      public override func build() throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1 {
           try checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1 {
        let returnMe:Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1 = builderResult
        return returnMe
      }
      public func mergeFrom(other:Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1) throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
        if other == Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1() {
         return self
        }
        if other.hasVersion {
             version = other.version
        }
        if other.hasGroupManagerProfileId {
             groupManagerProfileId = other.groupManagerProfileId
        }
        if other.hasApproved {
             approved = other.approved
        }
        if other.hasGroupId {
             groupId = other.groupId
        }
        if other.hasProvider {
             provider = other.provider
        }
        try mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
           return try mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Services.Notification.Containers.GroupMembershipRequestResponseNotificationV1.Builder {
        let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          let tag = try input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = try unknownFieldsBuilder.build()
            return self

          case 8 :
            version = try input.readUInt32()

          case 18 :
            groupManagerProfileId = try input.readString()

          case 24 :
            approved = try input.readBool()

          case 34 :
            groupId = try input.readString()

          case 40 :
            let valueIntprovider = try input.readEnum()
            if let enumsprovider = Services.Group.Containers.GroupProviderV1(rawValue:valueIntprovider){
                 provider = enumsprovider
            } else {
                 try unknownFieldsBuilder.mergeVarintField(5, value:Int64(valueIntprovider))
            }

          default:
            if (!(try parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag))) {
               unknownFields = try unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }

  }

}

// @@protoc_insertion_point(global_scope)
