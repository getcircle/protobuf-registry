// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation
import ProtocolBuffers

public struct UserServiceActionsRoot {
  public static var sharedInstance : UserServiceActionsRoot {
   struct Static {
       static let instance : UserServiceActionsRoot = UserServiceActionsRoot()
   }
   return Static.instance
  }
  public var extensionRegistry:ExtensionRegistry

  init() {
    extensionRegistry = ExtensionRegistry()
    registerAllExtensions(extensionRegistry)
    IdentityRoot.sharedInstance.registerAllExtensions(extensionRegistry)
    UserRoot.sharedInstance.registerAllExtensions(extensionRegistry)
  }
  public func registerAllExtensions(registry:ExtensionRegistry) {
  }
}

public func == (lhs: UserService.CreateUser, rhs: UserService.CreateUser) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: UserService.ValidUser, rhs: UserService.ValidUser) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: UserService.AuthenticateUser, rhs: UserService.AuthenticateUser) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: UserService, rhs: UserService) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

final public class UserService : GeneratedMessage {


  //Nested type declaration start

    final public class CreateUser : GeneratedMessage {


      //Nested type declaration start

        final public class Request : GeneratedMessage {
          public private(set) var hasPassword:Bool = false
          public private(set) var password:String = ""

          public private(set) var hasIdentity:Bool = false
          public private(set) var identity:Identity = Identity()
          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) {
            if hasPassword {
              output.writeString(1, value:password)
            }
            if hasIdentity {
              output.writeMessage(2, value:identity)
            }
            unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var size:Int32 = memoizedSerializedSize
            if size != -1 {
             return size
            }

            size = 0
            if hasPassword {
              size += WireFormat.computeStringSize(1, value:password)
            }
            if hasIdentity {
              size += WireFormat.computeMessageSize(2, value:identity)
            }
            size += unknownFields.serializedSize()
            memoizedSerializedSize = size
            return size
          }
          public class func parseFromData(data:[Byte]) -> UserService.CreateUser.Request {
            return UserService.CreateUser.Request.builder().mergeFromData(data).build()
          }
          public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> UserService.CreateUser.Request {
            return UserService.CreateUser.Request.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromInputStream(input:NSInputStream) -> UserService.CreateUser.Request {
            return UserService.CreateUser.Request.builder().mergeFromInputStream(input).build()
          }
          public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->UserService.CreateUser.Request {
            return UserService.CreateUser.Request.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream) -> UserService.CreateUser.Request {
            return UserService.CreateUser.Request.builder().mergeFromCodedInputStream(input).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.CreateUser.Request {
            return UserService.CreateUser.Request.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func builder() -> UserService.CreateUser.RequestBuilder {
            return UserService.CreateUser.Request.classBuilder() as UserService.CreateUser.RequestBuilder
          }
          public func builder() -> UserService.CreateUser.RequestBuilder {
            return classBuilder() as UserService.CreateUser.RequestBuilder
          }
          public override class func classBuilder() -> MessageBuilder {
            return UserService.CreateUser.RequestBuilder()
          }
          public override func classBuilder() -> MessageBuilder {
            return UserService.CreateUser.Request.builder()
          }
          public func toBuilder() -> UserService.CreateUser.RequestBuilder {
            return UserService.CreateUser.Request.builderWithPrototype(self)
          }
          public class func builderWithPrototype(prototype:UserService.CreateUser.Request) -> UserService.CreateUser.RequestBuilder {
            return UserService.CreateUser.Request.builder().mergeFrom(prototype)
          }
          override public func writeDescriptionTo(inout output:String, indent:String) {
            if hasPassword {
              output += "\(indent) password: \(password) \n"
            }
            if hasIdentity {
              output += "\(indent) identity {\n"
              identity.writeDescriptionTo(&output, indent:"\(indent)  ")
              output += "\(indent) }\n"
            }
            unknownFields.writeDescriptionTo(&output, indent:indent)
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasPassword {
                     hashCode = (hashCode &* 31) &+ password.hashValue
                  }
                  if hasIdentity {
                    hashCode = (hashCode &* 31) &+ identity.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "UserService.CreateUser.Request"
          }
          override public func className() -> String {
              return "UserService.CreateUser.Request"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return UserService.CreateUser.Request.self
          }


          //Meta information declaration end

        }

        final public class RequestBuilder : GeneratedMessageBuilder {
          private var builderResult:UserService.CreateUser.Request

          required override public init () {
             builderResult = UserService.CreateUser.Request()
             super.init()
          }
          public var hasPassword:Bool {
               get {
                    return builderResult.hasPassword
               }
          }
          public var password:String {
               get {
                    return builderResult.password
               }
               set (value) {
                   builderResult.hasPassword = true
                   builderResult.password = value
               }
          }
          public func clearPassword() -> UserService.CreateUser.RequestBuilder{
               builderResult.hasPassword = false
               builderResult.password = ""
               return self
          }
          public var hasIdentity:Bool {
               get {
                   return builderResult.hasIdentity
               }
          }
          public var identity:Identity {
               get {
                   return builderResult.identity
               }
               set (value) {
                   builderResult.hasIdentity = true
                   builderResult.identity = value
               }
          }
          public func setIdentityBuilder(builderForValue:IdentityBuilder) -> UserService.CreateUser.RequestBuilder {
            identity = builderForValue.build()
            return self
          }
          public func mergeIdentity(value:Identity) -> UserService.CreateUser.RequestBuilder {
            if (builderResult.hasIdentity) {
              builderResult.identity = Identity.builderWithPrototype(builderResult.identity).mergeFrom(value).buildPartial()
            } else {
              builderResult.identity = value
            }
            builderResult.hasIdentity = true
            return self
          }
          public func clearIdentity() -> UserService.CreateUser.RequestBuilder {
            builderResult.hasIdentity = false
            builderResult.identity = Identity()
            return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          public override func clear() -> UserService.CreateUser.RequestBuilder {
            builderResult = UserService.CreateUser.Request()
            return self
          }
          public override func clone() -> UserService.CreateUser.RequestBuilder {
            return UserService.CreateUser.Request.builderWithPrototype(builderResult)
          }
          public override func build() -> UserService.CreateUser.Request {
               checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> UserService.CreateUser.Request {
            var returnMe:UserService.CreateUser.Request = builderResult
            return returnMe
          }
          public func mergeFrom(other:UserService.CreateUser.Request) -> UserService.CreateUser.RequestBuilder {
            if (other == UserService.CreateUser.Request()) {
             return self
            }
            if other.hasPassword {
                 password = other.password
            }
            if (other.hasIdentity) {
                mergeIdentity(other.identity)
            }
            mergeUnknownFields(other.unknownFields)
            return self
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream) ->UserService.CreateUser.RequestBuilder {
               return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.CreateUser.RequestBuilder {
            var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              var tag = input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = unknownFieldsBuilder.build()
                return self

              case 10 :
                password = input.readString()

              case 18 :
                var subBuilder:IdentityBuilder = Identity.builder()
                if hasIdentity {
                  subBuilder.mergeFrom(identity)
                }
                input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                identity = subBuilder.buildPartial()

              default:
                if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                   unknownFields = unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }



      //Nested type declaration end



      //Nested type declaration start

        final public class Response : GeneratedMessage {
          public private(set) var hasUser:Bool = false
          public private(set) var user:User = User()
          public private(set) var identities:Array<Identity>  = Array<Identity>()
          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) {
            if hasUser {
              output.writeMessage(1, value:user)
            }
            for oneElementidentities in identities {
                output.writeMessage(2, value:oneElementidentities)
            }
            unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var size:Int32 = memoizedSerializedSize
            if size != -1 {
             return size
            }

            size = 0
            if hasUser {
              size += WireFormat.computeMessageSize(1, value:user)
            }
            for oneElementidentities in identities {
                size += WireFormat.computeMessageSize(2, value:oneElementidentities)
            }
            size += unknownFields.serializedSize()
            memoizedSerializedSize = size
            return size
          }
          public class func parseFromData(data:[Byte]) -> UserService.CreateUser.Response {
            return UserService.CreateUser.Response.builder().mergeFromData(data).build()
          }
          public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> UserService.CreateUser.Response {
            return UserService.CreateUser.Response.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromInputStream(input:NSInputStream) -> UserService.CreateUser.Response {
            return UserService.CreateUser.Response.builder().mergeFromInputStream(input).build()
          }
          public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->UserService.CreateUser.Response {
            return UserService.CreateUser.Response.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream) -> UserService.CreateUser.Response {
            return UserService.CreateUser.Response.builder().mergeFromCodedInputStream(input).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.CreateUser.Response {
            return UserService.CreateUser.Response.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func builder() -> UserService.CreateUser.ResponseBuilder {
            return UserService.CreateUser.Response.classBuilder() as UserService.CreateUser.ResponseBuilder
          }
          public func builder() -> UserService.CreateUser.ResponseBuilder {
            return classBuilder() as UserService.CreateUser.ResponseBuilder
          }
          public override class func classBuilder() -> MessageBuilder {
            return UserService.CreateUser.ResponseBuilder()
          }
          public override func classBuilder() -> MessageBuilder {
            return UserService.CreateUser.Response.builder()
          }
          public func toBuilder() -> UserService.CreateUser.ResponseBuilder {
            return UserService.CreateUser.Response.builderWithPrototype(self)
          }
          public class func builderWithPrototype(prototype:UserService.CreateUser.Response) -> UserService.CreateUser.ResponseBuilder {
            return UserService.CreateUser.Response.builder().mergeFrom(prototype)
          }
          override public func writeDescriptionTo(inout output:String, indent:String) {
            if hasUser {
              output += "\(indent) user {\n"
              user.writeDescriptionTo(&output, indent:"\(indent)  ")
              output += "\(indent) }\n"
            }
            var identitiesElementIndex:Int = 0
            for oneElementidentities in identities {
                output += "\(indent) identities[\(identitiesElementIndex)] {\n"
                oneElementidentities.writeDescriptionTo(&output, indent:"\(indent)  ")
                output += "\(indent)}\n"
                identitiesElementIndex++
            }
            unknownFields.writeDescriptionTo(&output, indent:indent)
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasUser {
                    hashCode = (hashCode &* 31) &+ user.hashValue
                  }
                  for oneElementidentities in identities {
                      hashCode = (hashCode &* 31) &+ oneElementidentities.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "UserService.CreateUser.Response"
          }
          override public func className() -> String {
              return "UserService.CreateUser.Response"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return UserService.CreateUser.Response.self
          }


          //Meta information declaration end

        }

        final public class ResponseBuilder : GeneratedMessageBuilder {
          private var builderResult:UserService.CreateUser.Response

          required override public init () {
             builderResult = UserService.CreateUser.Response()
             super.init()
          }
          public var hasUser:Bool {
               get {
                   return builderResult.hasUser
               }
          }
          public var user:User {
               get {
                   return builderResult.user
               }
               set (value) {
                   builderResult.hasUser = true
                   builderResult.user = value
               }
          }
          public func setUserBuilder(builderForValue:UserBuilder) -> UserService.CreateUser.ResponseBuilder {
            user = builderForValue.build()
            return self
          }
          public func mergeUser(value:User) -> UserService.CreateUser.ResponseBuilder {
            if (builderResult.hasUser) {
              builderResult.user = User.builderWithPrototype(builderResult.user).mergeFrom(value).buildPartial()
            } else {
              builderResult.user = value
            }
            builderResult.hasUser = true
            return self
          }
          public func clearUser() -> UserService.CreateUser.ResponseBuilder {
            builderResult.hasUser = false
            builderResult.user = User()
            return self
          }
          public var identities:Array<Identity> {
               get {
                   return builderResult.identities
               }
               set (value) {
                   builderResult.identities = value
               }
          }
          public func clearIdentities() -> UserService.CreateUser.ResponseBuilder {
            builderResult.identities.removeAll(keepCapacity: false)
            return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          public override func clear() -> UserService.CreateUser.ResponseBuilder {
            builderResult = UserService.CreateUser.Response()
            return self
          }
          public override func clone() -> UserService.CreateUser.ResponseBuilder {
            return UserService.CreateUser.Response.builderWithPrototype(builderResult)
          }
          public override func build() -> UserService.CreateUser.Response {
               checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> UserService.CreateUser.Response {
            var returnMe:UserService.CreateUser.Response = builderResult
            return returnMe
          }
          public func mergeFrom(other:UserService.CreateUser.Response) -> UserService.CreateUser.ResponseBuilder {
            if (other == UserService.CreateUser.Response()) {
             return self
            }
            if (other.hasUser) {
                mergeUser(other.user)
            }
            if !other.identities.isEmpty  {
               builderResult.identities += other.identities
            }
            mergeUnknownFields(other.unknownFields)
            return self
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream) ->UserService.CreateUser.ResponseBuilder {
               return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.CreateUser.ResponseBuilder {
            var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              var tag = input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = unknownFieldsBuilder.build()
                return self

              case 10 :
                var subBuilder:UserBuilder = User.builder()
                if hasUser {
                  subBuilder.mergeFrom(user)
                }
                input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                user = subBuilder.buildPartial()

              case 18 :
                var subBuilder = Identity.builder()
                input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
                identities += [subBuilder.buildPartial()]

              default:
                if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                   unknownFields = unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }



      //Nested type declaration end

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      public class func parseFromData(data:[Byte]) -> UserService.CreateUser {
        return UserService.CreateUser.builder().mergeFromData(data).build()
      }
      public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> UserService.CreateUser {
        return UserService.CreateUser.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) -> UserService.CreateUser {
        return UserService.CreateUser.builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->UserService.CreateUser {
        return UserService.CreateUser.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) -> UserService.CreateUser {
        return UserService.CreateUser.builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.CreateUser {
        return UserService.CreateUser.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func builder() -> UserService.CreateUserBuilder {
        return UserService.CreateUser.classBuilder() as UserService.CreateUserBuilder
      }
      public func builder() -> UserService.CreateUserBuilder {
        return classBuilder() as UserService.CreateUserBuilder
      }
      public override class func classBuilder() -> MessageBuilder {
        return UserService.CreateUserBuilder()
      }
      public override func classBuilder() -> MessageBuilder {
        return UserService.CreateUser.builder()
      }
      public func toBuilder() -> UserService.CreateUserBuilder {
        return UserService.CreateUser.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:UserService.CreateUser) -> UserService.CreateUserBuilder {
        return UserService.CreateUser.builder().mergeFrom(prototype)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "UserService.CreateUser"
      }
      override public func className() -> String {
          return "UserService.CreateUser"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return UserService.CreateUser.self
      }


      //Meta information declaration end

    }

    final public class CreateUserBuilder : GeneratedMessageBuilder {
      private var builderResult:UserService.CreateUser

      required override public init () {
         builderResult = UserService.CreateUser()
         super.init()
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      public override func clear() -> UserService.CreateUserBuilder {
        builderResult = UserService.CreateUser()
        return self
      }
      public override func clone() -> UserService.CreateUserBuilder {
        return UserService.CreateUser.builderWithPrototype(builderResult)
      }
      public override func build() -> UserService.CreateUser {
           checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> UserService.CreateUser {
        var returnMe:UserService.CreateUser = builderResult
        return returnMe
      }
      public func mergeFrom(other:UserService.CreateUser) -> UserService.CreateUserBuilder {
        if (other == UserService.CreateUser()) {
         return self
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) ->UserService.CreateUserBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.CreateUserBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



  //Nested type declaration start

    final public class ValidUser : GeneratedMessage {


      //Nested type declaration start

        final public class Request : GeneratedMessage {
          public private(set) var hasUserId:Bool = false
          public private(set) var user_id:String = ""

          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) {
            if hasUserId {
              output.writeString(1, value:user_id)
            }
            unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var size:Int32 = memoizedSerializedSize
            if size != -1 {
             return size
            }

            size = 0
            if hasUserId {
              size += WireFormat.computeStringSize(1, value:user_id)
            }
            size += unknownFields.serializedSize()
            memoizedSerializedSize = size
            return size
          }
          public class func parseFromData(data:[Byte]) -> UserService.ValidUser.Request {
            return UserService.ValidUser.Request.builder().mergeFromData(data).build()
          }
          public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> UserService.ValidUser.Request {
            return UserService.ValidUser.Request.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromInputStream(input:NSInputStream) -> UserService.ValidUser.Request {
            return UserService.ValidUser.Request.builder().mergeFromInputStream(input).build()
          }
          public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->UserService.ValidUser.Request {
            return UserService.ValidUser.Request.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream) -> UserService.ValidUser.Request {
            return UserService.ValidUser.Request.builder().mergeFromCodedInputStream(input).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.ValidUser.Request {
            return UserService.ValidUser.Request.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func builder() -> UserService.ValidUser.RequestBuilder {
            return UserService.ValidUser.Request.classBuilder() as UserService.ValidUser.RequestBuilder
          }
          public func builder() -> UserService.ValidUser.RequestBuilder {
            return classBuilder() as UserService.ValidUser.RequestBuilder
          }
          public override class func classBuilder() -> MessageBuilder {
            return UserService.ValidUser.RequestBuilder()
          }
          public override func classBuilder() -> MessageBuilder {
            return UserService.ValidUser.Request.builder()
          }
          public func toBuilder() -> UserService.ValidUser.RequestBuilder {
            return UserService.ValidUser.Request.builderWithPrototype(self)
          }
          public class func builderWithPrototype(prototype:UserService.ValidUser.Request) -> UserService.ValidUser.RequestBuilder {
            return UserService.ValidUser.Request.builder().mergeFrom(prototype)
          }
          override public func writeDescriptionTo(inout output:String, indent:String) {
            if hasUserId {
              output += "\(indent) user_id: \(user_id) \n"
            }
            unknownFields.writeDescriptionTo(&output, indent:indent)
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasUserId {
                     hashCode = (hashCode &* 31) &+ user_id.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "UserService.ValidUser.Request"
          }
          override public func className() -> String {
              return "UserService.ValidUser.Request"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return UserService.ValidUser.Request.self
          }


          //Meta information declaration end

        }

        final public class RequestBuilder : GeneratedMessageBuilder {
          private var builderResult:UserService.ValidUser.Request

          required override public init () {
             builderResult = UserService.ValidUser.Request()
             super.init()
          }
          public var hasUserId:Bool {
               get {
                    return builderResult.hasUserId
               }
          }
          public var user_id:String {
               get {
                    return builderResult.user_id
               }
               set (value) {
                   builderResult.hasUserId = true
                   builderResult.user_id = value
               }
          }
          public func clearUserId() -> UserService.ValidUser.RequestBuilder{
               builderResult.hasUserId = false
               builderResult.user_id = ""
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          public override func clear() -> UserService.ValidUser.RequestBuilder {
            builderResult = UserService.ValidUser.Request()
            return self
          }
          public override func clone() -> UserService.ValidUser.RequestBuilder {
            return UserService.ValidUser.Request.builderWithPrototype(builderResult)
          }
          public override func build() -> UserService.ValidUser.Request {
               checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> UserService.ValidUser.Request {
            var returnMe:UserService.ValidUser.Request = builderResult
            return returnMe
          }
          public func mergeFrom(other:UserService.ValidUser.Request) -> UserService.ValidUser.RequestBuilder {
            if (other == UserService.ValidUser.Request()) {
             return self
            }
            if other.hasUserId {
                 user_id = other.user_id
            }
            mergeUnknownFields(other.unknownFields)
            return self
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream) ->UserService.ValidUser.RequestBuilder {
               return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.ValidUser.RequestBuilder {
            var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              var tag = input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = unknownFieldsBuilder.build()
                return self

              case 10 :
                user_id = input.readString()

              default:
                if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                   unknownFields = unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }



      //Nested type declaration end



      //Nested type declaration start

        final public class Response : GeneratedMessage {
          public private(set) var hasExists:Bool = false
          public private(set) var exists:Bool = false

          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) {
            if hasExists {
              output.writeBool(1, value:exists)
            }
            unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var size:Int32 = memoizedSerializedSize
            if size != -1 {
             return size
            }

            size = 0
            if hasExists {
              size += WireFormat.computeBoolSize(1, value:exists)
            }
            size += unknownFields.serializedSize()
            memoizedSerializedSize = size
            return size
          }
          public class func parseFromData(data:[Byte]) -> UserService.ValidUser.Response {
            return UserService.ValidUser.Response.builder().mergeFromData(data).build()
          }
          public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> UserService.ValidUser.Response {
            return UserService.ValidUser.Response.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromInputStream(input:NSInputStream) -> UserService.ValidUser.Response {
            return UserService.ValidUser.Response.builder().mergeFromInputStream(input).build()
          }
          public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->UserService.ValidUser.Response {
            return UserService.ValidUser.Response.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream) -> UserService.ValidUser.Response {
            return UserService.ValidUser.Response.builder().mergeFromCodedInputStream(input).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.ValidUser.Response {
            return UserService.ValidUser.Response.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func builder() -> UserService.ValidUser.ResponseBuilder {
            return UserService.ValidUser.Response.classBuilder() as UserService.ValidUser.ResponseBuilder
          }
          public func builder() -> UserService.ValidUser.ResponseBuilder {
            return classBuilder() as UserService.ValidUser.ResponseBuilder
          }
          public override class func classBuilder() -> MessageBuilder {
            return UserService.ValidUser.ResponseBuilder()
          }
          public override func classBuilder() -> MessageBuilder {
            return UserService.ValidUser.Response.builder()
          }
          public func toBuilder() -> UserService.ValidUser.ResponseBuilder {
            return UserService.ValidUser.Response.builderWithPrototype(self)
          }
          public class func builderWithPrototype(prototype:UserService.ValidUser.Response) -> UserService.ValidUser.ResponseBuilder {
            return UserService.ValidUser.Response.builder().mergeFrom(prototype)
          }
          override public func writeDescriptionTo(inout output:String, indent:String) {
            if hasExists {
              output += "\(indent) exists: \(exists) \n"
            }
            unknownFields.writeDescriptionTo(&output, indent:indent)
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasExists {
                     hashCode = (hashCode &* 31) &+ exists.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "UserService.ValidUser.Response"
          }
          override public func className() -> String {
              return "UserService.ValidUser.Response"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return UserService.ValidUser.Response.self
          }


          //Meta information declaration end

        }

        final public class ResponseBuilder : GeneratedMessageBuilder {
          private var builderResult:UserService.ValidUser.Response

          required override public init () {
             builderResult = UserService.ValidUser.Response()
             super.init()
          }
          public var hasExists:Bool {
               get {
                    return builderResult.hasExists
               }
          }
          public var exists:Bool {
               get {
                    return builderResult.exists
               }
               set (value) {
                   builderResult.hasExists = true
                   builderResult.exists = value
               }
          }
          public func clearExists() -> UserService.ValidUser.ResponseBuilder{
               builderResult.hasExists = false
               builderResult.exists = false
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          public override func clear() -> UserService.ValidUser.ResponseBuilder {
            builderResult = UserService.ValidUser.Response()
            return self
          }
          public override func clone() -> UserService.ValidUser.ResponseBuilder {
            return UserService.ValidUser.Response.builderWithPrototype(builderResult)
          }
          public override func build() -> UserService.ValidUser.Response {
               checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> UserService.ValidUser.Response {
            var returnMe:UserService.ValidUser.Response = builderResult
            return returnMe
          }
          public func mergeFrom(other:UserService.ValidUser.Response) -> UserService.ValidUser.ResponseBuilder {
            if (other == UserService.ValidUser.Response()) {
             return self
            }
            if other.hasExists {
                 exists = other.exists
            }
            mergeUnknownFields(other.unknownFields)
            return self
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream) ->UserService.ValidUser.ResponseBuilder {
               return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.ValidUser.ResponseBuilder {
            var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              var tag = input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = unknownFieldsBuilder.build()
                return self

              case 8 :
                exists = input.readBool()

              default:
                if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                   unknownFields = unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }



      //Nested type declaration end

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      public class func parseFromData(data:[Byte]) -> UserService.ValidUser {
        return UserService.ValidUser.builder().mergeFromData(data).build()
      }
      public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> UserService.ValidUser {
        return UserService.ValidUser.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) -> UserService.ValidUser {
        return UserService.ValidUser.builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->UserService.ValidUser {
        return UserService.ValidUser.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) -> UserService.ValidUser {
        return UserService.ValidUser.builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.ValidUser {
        return UserService.ValidUser.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func builder() -> UserService.ValidUserBuilder {
        return UserService.ValidUser.classBuilder() as UserService.ValidUserBuilder
      }
      public func builder() -> UserService.ValidUserBuilder {
        return classBuilder() as UserService.ValidUserBuilder
      }
      public override class func classBuilder() -> MessageBuilder {
        return UserService.ValidUserBuilder()
      }
      public override func classBuilder() -> MessageBuilder {
        return UserService.ValidUser.builder()
      }
      public func toBuilder() -> UserService.ValidUserBuilder {
        return UserService.ValidUser.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:UserService.ValidUser) -> UserService.ValidUserBuilder {
        return UserService.ValidUser.builder().mergeFrom(prototype)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "UserService.ValidUser"
      }
      override public func className() -> String {
          return "UserService.ValidUser"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return UserService.ValidUser.self
      }


      //Meta information declaration end

    }

    final public class ValidUserBuilder : GeneratedMessageBuilder {
      private var builderResult:UserService.ValidUser

      required override public init () {
         builderResult = UserService.ValidUser()
         super.init()
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      public override func clear() -> UserService.ValidUserBuilder {
        builderResult = UserService.ValidUser()
        return self
      }
      public override func clone() -> UserService.ValidUserBuilder {
        return UserService.ValidUser.builderWithPrototype(builderResult)
      }
      public override func build() -> UserService.ValidUser {
           checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> UserService.ValidUser {
        var returnMe:UserService.ValidUser = builderResult
        return returnMe
      }
      public func mergeFrom(other:UserService.ValidUser) -> UserService.ValidUserBuilder {
        if (other == UserService.ValidUser()) {
         return self
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) ->UserService.ValidUserBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.ValidUserBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end



  //Nested type declaration start

    final public class AuthenticateUser : GeneratedMessage {


      //Nested type declaration start

        final public class Request : GeneratedMessage {


          //Nested type declaration start

            final public class Credentials : GeneratedMessage {
              public private(set) var hasKey:Bool = false
              public private(set) var key:String = ""

              public private(set) var hasSecret:Bool = false
              public private(set) var secret:String = ""

              required public init() {
                   super.init()
              }
              override public func isInitialized() -> Bool {
               return true
              }
              override public func writeToCodedOutputStream(output:CodedOutputStream) {
                if hasKey {
                  output.writeString(1, value:key)
                }
                if hasSecret {
                  output.writeString(2, value:secret)
                }
                unknownFields.writeToCodedOutputStream(output)
              }
              override public func serializedSize() -> Int32 {
                var size:Int32 = memoizedSerializedSize
                if size != -1 {
                 return size
                }

                size = 0
                if hasKey {
                  size += WireFormat.computeStringSize(1, value:key)
                }
                if hasSecret {
                  size += WireFormat.computeStringSize(2, value:secret)
                }
                size += unknownFields.serializedSize()
                memoizedSerializedSize = size
                return size
              }
              public class func parseFromData(data:[Byte]) -> UserService.AuthenticateUser.Request.Credentials {
                return UserService.AuthenticateUser.Request.Credentials.builder().mergeFromData(data).build()
              }
              public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> UserService.AuthenticateUser.Request.Credentials {
                return UserService.AuthenticateUser.Request.Credentials.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
              }
              public class func parseFromInputStream(input:NSInputStream) -> UserService.AuthenticateUser.Request.Credentials {
                return UserService.AuthenticateUser.Request.Credentials.builder().mergeFromInputStream(input).build()
              }
              public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->UserService.AuthenticateUser.Request.Credentials {
                return UserService.AuthenticateUser.Request.Credentials.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
              }
              public class func parseFromCodedInputStream(input:CodedInputStream) -> UserService.AuthenticateUser.Request.Credentials {
                return UserService.AuthenticateUser.Request.Credentials.builder().mergeFromCodedInputStream(input).build()
              }
              public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.AuthenticateUser.Request.Credentials {
                return UserService.AuthenticateUser.Request.Credentials.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
              }
              public class func builder() -> UserService.AuthenticateUser.Request.CredentialsBuilder {
                return UserService.AuthenticateUser.Request.Credentials.classBuilder() as UserService.AuthenticateUser.Request.CredentialsBuilder
              }
              public func builder() -> UserService.AuthenticateUser.Request.CredentialsBuilder {
                return classBuilder() as UserService.AuthenticateUser.Request.CredentialsBuilder
              }
              public override class func classBuilder() -> MessageBuilder {
                return UserService.AuthenticateUser.Request.CredentialsBuilder()
              }
              public override func classBuilder() -> MessageBuilder {
                return UserService.AuthenticateUser.Request.Credentials.builder()
              }
              public func toBuilder() -> UserService.AuthenticateUser.Request.CredentialsBuilder {
                return UserService.AuthenticateUser.Request.Credentials.builderWithPrototype(self)
              }
              public class func builderWithPrototype(prototype:UserService.AuthenticateUser.Request.Credentials) -> UserService.AuthenticateUser.Request.CredentialsBuilder {
                return UserService.AuthenticateUser.Request.Credentials.builder().mergeFrom(prototype)
              }
              override public func writeDescriptionTo(inout output:String, indent:String) {
                if hasKey {
                  output += "\(indent) key: \(key) \n"
                }
                if hasSecret {
                  output += "\(indent) secret: \(secret) \n"
                }
                unknownFields.writeDescriptionTo(&output, indent:indent)
              }
              override public var hashValue:Int {
                  get {
                      var hashCode:Int = 7
                      if hasKey {
                         hashCode = (hashCode &* 31) &+ key.hashValue
                      }
                      if hasSecret {
                         hashCode = (hashCode &* 31) &+ secret.hashValue
                      }
                      hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                      return hashCode
                  }
              }


              //Meta information declaration start

              override public class func className() -> String {
                  return "UserService.AuthenticateUser.Request.Credentials"
              }
              override public func className() -> String {
                  return "UserService.AuthenticateUser.Request.Credentials"
              }
              override public func classMetaType() -> GeneratedMessage.Type {
                  return UserService.AuthenticateUser.Request.Credentials.self
              }


              //Meta information declaration end

            }

            final public class CredentialsBuilder : GeneratedMessageBuilder {
              private var builderResult:UserService.AuthenticateUser.Request.Credentials

              required override public init () {
                 builderResult = UserService.AuthenticateUser.Request.Credentials()
                 super.init()
              }
              public var hasKey:Bool {
                   get {
                        return builderResult.hasKey
                   }
              }
              public var key:String {
                   get {
                        return builderResult.key
                   }
                   set (value) {
                       builderResult.hasKey = true
                       builderResult.key = value
                   }
              }
              public func clearKey() -> UserService.AuthenticateUser.Request.CredentialsBuilder{
                   builderResult.hasKey = false
                   builderResult.key = ""
                   return self
              }
              public var hasSecret:Bool {
                   get {
                        return builderResult.hasSecret
                   }
              }
              public var secret:String {
                   get {
                        return builderResult.secret
                   }
                   set (value) {
                       builderResult.hasSecret = true
                       builderResult.secret = value
                   }
              }
              public func clearSecret() -> UserService.AuthenticateUser.Request.CredentialsBuilder{
                   builderResult.hasSecret = false
                   builderResult.secret = ""
                   return self
              }
              override public var internalGetResult:GeneratedMessage {
                   get {
                      return builderResult
                   }
              }
              public override func clear() -> UserService.AuthenticateUser.Request.CredentialsBuilder {
                builderResult = UserService.AuthenticateUser.Request.Credentials()
                return self
              }
              public override func clone() -> UserService.AuthenticateUser.Request.CredentialsBuilder {
                return UserService.AuthenticateUser.Request.Credentials.builderWithPrototype(builderResult)
              }
              public override func build() -> UserService.AuthenticateUser.Request.Credentials {
                   checkInitialized()
                   return buildPartial()
              }
              public func buildPartial() -> UserService.AuthenticateUser.Request.Credentials {
                var returnMe:UserService.AuthenticateUser.Request.Credentials = builderResult
                return returnMe
              }
              public func mergeFrom(other:UserService.AuthenticateUser.Request.Credentials) -> UserService.AuthenticateUser.Request.CredentialsBuilder {
                if (other == UserService.AuthenticateUser.Request.Credentials()) {
                 return self
                }
                if other.hasKey {
                     key = other.key
                }
                if other.hasSecret {
                     secret = other.secret
                }
                mergeUnknownFields(other.unknownFields)
                return self
              }
              public override func mergeFromCodedInputStream(input:CodedInputStream) ->UserService.AuthenticateUser.Request.CredentialsBuilder {
                   return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
              }
              public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.AuthenticateUser.Request.CredentialsBuilder {
                var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
                while (true) {
                  var tag = input.readTag()
                  switch tag {
                  case 0: 
                    self.unknownFields = unknownFieldsBuilder.build()
                    return self

                  case 10 :
                    key = input.readString()

                  case 18 :
                    secret = input.readString()

                  default:
                    if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                       unknownFields = unknownFieldsBuilder.build()
                       return self
                    }
                  }
                }
              }
            }



          //Nested type declaration end



            //Enum type declaration start 

            public enum AuthBackend:Int32 {
              case Internal = 0

              public static func IsValidValue(value:Int32) ->Bool {
                  if let check = AuthBackend(rawValue:value) {
                      return true
                  }
                  return false
              }
            }



            //Enum type declaration end 

          public private(set) var backend:UserService.AuthenticateUser.Request.AuthBackend = UserService.AuthenticateUser.Request.AuthBackend.Internal
          public private(set) var hasBackend:Bool = false
          public private(set) var hasCredentials:Bool = false
          public private(set) var credentials:UserService.AuthenticateUser.Request.Credentials = UserService.AuthenticateUser.Request.Credentials()
          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) {
            if hasBackend {
              output.writeEnum(1, value:backend.rawValue)
            }
            if hasCredentials {
              output.writeMessage(2, value:credentials)
            }
            unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var size:Int32 = memoizedSerializedSize
            if size != -1 {
             return size
            }

            size = 0
            if (hasBackend) {
              size += WireFormat.computeEnumSize(1, value:backend.rawValue)
            }
            if hasCredentials {
              size += WireFormat.computeMessageSize(2, value:credentials)
            }
            size += unknownFields.serializedSize()
            memoizedSerializedSize = size
            return size
          }
          public class func parseFromData(data:[Byte]) -> UserService.AuthenticateUser.Request {
            return UserService.AuthenticateUser.Request.builder().mergeFromData(data).build()
          }
          public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> UserService.AuthenticateUser.Request {
            return UserService.AuthenticateUser.Request.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromInputStream(input:NSInputStream) -> UserService.AuthenticateUser.Request {
            return UserService.AuthenticateUser.Request.builder().mergeFromInputStream(input).build()
          }
          public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->UserService.AuthenticateUser.Request {
            return UserService.AuthenticateUser.Request.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream) -> UserService.AuthenticateUser.Request {
            return UserService.AuthenticateUser.Request.builder().mergeFromCodedInputStream(input).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.AuthenticateUser.Request {
            return UserService.AuthenticateUser.Request.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func builder() -> UserService.AuthenticateUser.RequestBuilder {
            return UserService.AuthenticateUser.Request.classBuilder() as UserService.AuthenticateUser.RequestBuilder
          }
          public func builder() -> UserService.AuthenticateUser.RequestBuilder {
            return classBuilder() as UserService.AuthenticateUser.RequestBuilder
          }
          public override class func classBuilder() -> MessageBuilder {
            return UserService.AuthenticateUser.RequestBuilder()
          }
          public override func classBuilder() -> MessageBuilder {
            return UserService.AuthenticateUser.Request.builder()
          }
          public func toBuilder() -> UserService.AuthenticateUser.RequestBuilder {
            return UserService.AuthenticateUser.Request.builderWithPrototype(self)
          }
          public class func builderWithPrototype(prototype:UserService.AuthenticateUser.Request) -> UserService.AuthenticateUser.RequestBuilder {
            return UserService.AuthenticateUser.Request.builder().mergeFrom(prototype)
          }
          override public func writeDescriptionTo(inout output:String, indent:String) {
            if (hasBackend) {
              output += "\(indent) backend: \(backend.rawValue)\n"
            }
            if hasCredentials {
              output += "\(indent) credentials {\n"
              credentials.writeDescriptionTo(&output, indent:"\(indent)  ")
              output += "\(indent) }\n"
            }
            unknownFields.writeDescriptionTo(&output, indent:indent)
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasBackend {
                     hashCode = (hashCode &* 31) &+ Int(backend.rawValue)
                  }
                  if hasCredentials {
                    hashCode = (hashCode &* 31) &+ credentials.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "UserService.AuthenticateUser.Request"
          }
          override public func className() -> String {
              return "UserService.AuthenticateUser.Request"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return UserService.AuthenticateUser.Request.self
          }


          //Meta information declaration end

        }

        final public class RequestBuilder : GeneratedMessageBuilder {
          private var builderResult:UserService.AuthenticateUser.Request

          required override public init () {
             builderResult = UserService.AuthenticateUser.Request()
             super.init()
          }
            public var hasBackend:Bool{
                get {
                    return builderResult.hasBackend
                }
            }
            public var backend:UserService.AuthenticateUser.Request.AuthBackend {
                get {
                    return builderResult.backend
                }
                set (value) {
                    builderResult.hasBackend = true
                    builderResult.backend = value
                }
            }
            public func clearBackend() -> UserService.AuthenticateUser.RequestBuilder {
               builderResult.hasBackend = false
               builderResult.backend = .Internal
               return self
            }
          public var hasCredentials:Bool {
               get {
                   return builderResult.hasCredentials
               }
          }
          public var credentials:UserService.AuthenticateUser.Request.Credentials {
               get {
                   return builderResult.credentials
               }
               set (value) {
                   builderResult.hasCredentials = true
                   builderResult.credentials = value
               }
          }
          public func setCredentialsBuilder(builderForValue:UserService.AuthenticateUser.Request.CredentialsBuilder) -> UserService.AuthenticateUser.RequestBuilder {
            credentials = builderForValue.build()
            return self
          }
          public func mergeCredentials(value:UserService.AuthenticateUser.Request.Credentials) -> UserService.AuthenticateUser.RequestBuilder {
            if (builderResult.hasCredentials) {
              builderResult.credentials = UserService.AuthenticateUser.Request.Credentials.builderWithPrototype(builderResult.credentials).mergeFrom(value).buildPartial()
            } else {
              builderResult.credentials = value
            }
            builderResult.hasCredentials = true
            return self
          }
          public func clearCredentials() -> UserService.AuthenticateUser.RequestBuilder {
            builderResult.hasCredentials = false
            builderResult.credentials = UserService.AuthenticateUser.Request.Credentials()
            return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          public override func clear() -> UserService.AuthenticateUser.RequestBuilder {
            builderResult = UserService.AuthenticateUser.Request()
            return self
          }
          public override func clone() -> UserService.AuthenticateUser.RequestBuilder {
            return UserService.AuthenticateUser.Request.builderWithPrototype(builderResult)
          }
          public override func build() -> UserService.AuthenticateUser.Request {
               checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> UserService.AuthenticateUser.Request {
            var returnMe:UserService.AuthenticateUser.Request = builderResult
            return returnMe
          }
          public func mergeFrom(other:UserService.AuthenticateUser.Request) -> UserService.AuthenticateUser.RequestBuilder {
            if (other == UserService.AuthenticateUser.Request()) {
             return self
            }
            if other.hasBackend {
                 backend = other.backend
            }
            if (other.hasCredentials) {
                mergeCredentials(other.credentials)
            }
            mergeUnknownFields(other.unknownFields)
            return self
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream) ->UserService.AuthenticateUser.RequestBuilder {
               return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.AuthenticateUser.RequestBuilder {
            var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              var tag = input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = unknownFieldsBuilder.build()
                return self

              case 8 :
                let valueIntbackend = input.readEnum()
                if let enumsbackend = UserService.AuthenticateUser.Request.AuthBackend(rawValue:valueIntbackend){
                     backend = enumsbackend
                } else {
                     unknownFieldsBuilder.mergeVarintField(1, value:Int64(valueIntbackend))
                }

              case 18 :
                var subBuilder:UserService.AuthenticateUser.Request.CredentialsBuilder = UserService.AuthenticateUser.Request.Credentials.builder()
                if hasCredentials {
                  subBuilder.mergeFrom(credentials)
                }
                input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                credentials = subBuilder.buildPartial()

              default:
                if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                   unknownFields = unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }



      //Nested type declaration end



      //Nested type declaration start

        final public class Response : GeneratedMessage {
          public private(set) var hasUser:Bool = false
          public private(set) var user:User = User()
          public private(set) var hasAuthenticated:Bool = false
          public private(set) var authenticated:Bool = false

          public private(set) var hasToken:Bool = false
          public private(set) var token:String = ""

          required public init() {
               super.init()
          }
          override public func isInitialized() -> Bool {
           return true
          }
          override public func writeToCodedOutputStream(output:CodedOutputStream) {
            if hasUser {
              output.writeMessage(1, value:user)
            }
            if hasAuthenticated {
              output.writeBool(2, value:authenticated)
            }
            if hasToken {
              output.writeString(3, value:token)
            }
            unknownFields.writeToCodedOutputStream(output)
          }
          override public func serializedSize() -> Int32 {
            var size:Int32 = memoizedSerializedSize
            if size != -1 {
             return size
            }

            size = 0
            if hasUser {
              size += WireFormat.computeMessageSize(1, value:user)
            }
            if hasAuthenticated {
              size += WireFormat.computeBoolSize(2, value:authenticated)
            }
            if hasToken {
              size += WireFormat.computeStringSize(3, value:token)
            }
            size += unknownFields.serializedSize()
            memoizedSerializedSize = size
            return size
          }
          public class func parseFromData(data:[Byte]) -> UserService.AuthenticateUser.Response {
            return UserService.AuthenticateUser.Response.builder().mergeFromData(data).build()
          }
          public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> UserService.AuthenticateUser.Response {
            return UserService.AuthenticateUser.Response.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromInputStream(input:NSInputStream) -> UserService.AuthenticateUser.Response {
            return UserService.AuthenticateUser.Response.builder().mergeFromInputStream(input).build()
          }
          public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->UserService.AuthenticateUser.Response {
            return UserService.AuthenticateUser.Response.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream) -> UserService.AuthenticateUser.Response {
            return UserService.AuthenticateUser.Response.builder().mergeFromCodedInputStream(input).build()
          }
          public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.AuthenticateUser.Response {
            return UserService.AuthenticateUser.Response.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
          }
          public class func builder() -> UserService.AuthenticateUser.ResponseBuilder {
            return UserService.AuthenticateUser.Response.classBuilder() as UserService.AuthenticateUser.ResponseBuilder
          }
          public func builder() -> UserService.AuthenticateUser.ResponseBuilder {
            return classBuilder() as UserService.AuthenticateUser.ResponseBuilder
          }
          public override class func classBuilder() -> MessageBuilder {
            return UserService.AuthenticateUser.ResponseBuilder()
          }
          public override func classBuilder() -> MessageBuilder {
            return UserService.AuthenticateUser.Response.builder()
          }
          public func toBuilder() -> UserService.AuthenticateUser.ResponseBuilder {
            return UserService.AuthenticateUser.Response.builderWithPrototype(self)
          }
          public class func builderWithPrototype(prototype:UserService.AuthenticateUser.Response) -> UserService.AuthenticateUser.ResponseBuilder {
            return UserService.AuthenticateUser.Response.builder().mergeFrom(prototype)
          }
          override public func writeDescriptionTo(inout output:String, indent:String) {
            if hasUser {
              output += "\(indent) user {\n"
              user.writeDescriptionTo(&output, indent:"\(indent)  ")
              output += "\(indent) }\n"
            }
            if hasAuthenticated {
              output += "\(indent) authenticated: \(authenticated) \n"
            }
            if hasToken {
              output += "\(indent) token: \(token) \n"
            }
            unknownFields.writeDescriptionTo(&output, indent:indent)
          }
          override public var hashValue:Int {
              get {
                  var hashCode:Int = 7
                  if hasUser {
                    hashCode = (hashCode &* 31) &+ user.hashValue
                  }
                  if hasAuthenticated {
                     hashCode = (hashCode &* 31) &+ authenticated.hashValue
                  }
                  if hasToken {
                     hashCode = (hashCode &* 31) &+ token.hashValue
                  }
                  hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                  return hashCode
              }
          }


          //Meta information declaration start

          override public class func className() -> String {
              return "UserService.AuthenticateUser.Response"
          }
          override public func className() -> String {
              return "UserService.AuthenticateUser.Response"
          }
          override public func classMetaType() -> GeneratedMessage.Type {
              return UserService.AuthenticateUser.Response.self
          }


          //Meta information declaration end

        }

        final public class ResponseBuilder : GeneratedMessageBuilder {
          private var builderResult:UserService.AuthenticateUser.Response

          required override public init () {
             builderResult = UserService.AuthenticateUser.Response()
             super.init()
          }
          public var hasUser:Bool {
               get {
                   return builderResult.hasUser
               }
          }
          public var user:User {
               get {
                   return builderResult.user
               }
               set (value) {
                   builderResult.hasUser = true
                   builderResult.user = value
               }
          }
          public func setUserBuilder(builderForValue:UserBuilder) -> UserService.AuthenticateUser.ResponseBuilder {
            user = builderForValue.build()
            return self
          }
          public func mergeUser(value:User) -> UserService.AuthenticateUser.ResponseBuilder {
            if (builderResult.hasUser) {
              builderResult.user = User.builderWithPrototype(builderResult.user).mergeFrom(value).buildPartial()
            } else {
              builderResult.user = value
            }
            builderResult.hasUser = true
            return self
          }
          public func clearUser() -> UserService.AuthenticateUser.ResponseBuilder {
            builderResult.hasUser = false
            builderResult.user = User()
            return self
          }
          public var hasAuthenticated:Bool {
               get {
                    return builderResult.hasAuthenticated
               }
          }
          public var authenticated:Bool {
               get {
                    return builderResult.authenticated
               }
               set (value) {
                   builderResult.hasAuthenticated = true
                   builderResult.authenticated = value
               }
          }
          public func clearAuthenticated() -> UserService.AuthenticateUser.ResponseBuilder{
               builderResult.hasAuthenticated = false
               builderResult.authenticated = false
               return self
          }
          public var hasToken:Bool {
               get {
                    return builderResult.hasToken
               }
          }
          public var token:String {
               get {
                    return builderResult.token
               }
               set (value) {
                   builderResult.hasToken = true
                   builderResult.token = value
               }
          }
          public func clearToken() -> UserService.AuthenticateUser.ResponseBuilder{
               builderResult.hasToken = false
               builderResult.token = ""
               return self
          }
          override public var internalGetResult:GeneratedMessage {
               get {
                  return builderResult
               }
          }
          public override func clear() -> UserService.AuthenticateUser.ResponseBuilder {
            builderResult = UserService.AuthenticateUser.Response()
            return self
          }
          public override func clone() -> UserService.AuthenticateUser.ResponseBuilder {
            return UserService.AuthenticateUser.Response.builderWithPrototype(builderResult)
          }
          public override func build() -> UserService.AuthenticateUser.Response {
               checkInitialized()
               return buildPartial()
          }
          public func buildPartial() -> UserService.AuthenticateUser.Response {
            var returnMe:UserService.AuthenticateUser.Response = builderResult
            return returnMe
          }
          public func mergeFrom(other:UserService.AuthenticateUser.Response) -> UserService.AuthenticateUser.ResponseBuilder {
            if (other == UserService.AuthenticateUser.Response()) {
             return self
            }
            if (other.hasUser) {
                mergeUser(other.user)
            }
            if other.hasAuthenticated {
                 authenticated = other.authenticated
            }
            if other.hasToken {
                 token = other.token
            }
            mergeUnknownFields(other.unknownFields)
            return self
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream) ->UserService.AuthenticateUser.ResponseBuilder {
               return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
          }
          public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.AuthenticateUser.ResponseBuilder {
            var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
            while (true) {
              var tag = input.readTag()
              switch tag {
              case 0: 
                self.unknownFields = unknownFieldsBuilder.build()
                return self

              case 10 :
                var subBuilder:UserBuilder = User.builder()
                if hasUser {
                  subBuilder.mergeFrom(user)
                }
                input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
                user = subBuilder.buildPartial()

              case 16 :
                authenticated = input.readBool()

              case 26 :
                token = input.readString()

              default:
                if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                   unknownFields = unknownFieldsBuilder.build()
                   return self
                }
              }
            }
          }
        }



      //Nested type declaration end

      required public init() {
           super.init()
      }
      override public func isInitialized() -> Bool {
       return true
      }
      override public func writeToCodedOutputStream(output:CodedOutputStream) {
        unknownFields.writeToCodedOutputStream(output)
      }
      override public func serializedSize() -> Int32 {
        var size:Int32 = memoizedSerializedSize
        if size != -1 {
         return size
        }

        size = 0
        size += unknownFields.serializedSize()
        memoizedSerializedSize = size
        return size
      }
      public class func parseFromData(data:[Byte]) -> UserService.AuthenticateUser {
        return UserService.AuthenticateUser.builder().mergeFromData(data).build()
      }
      public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> UserService.AuthenticateUser {
        return UserService.AuthenticateUser.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromInputStream(input:NSInputStream) -> UserService.AuthenticateUser {
        return UserService.AuthenticateUser.builder().mergeFromInputStream(input).build()
      }
      public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->UserService.AuthenticateUser {
        return UserService.AuthenticateUser.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream) -> UserService.AuthenticateUser {
        return UserService.AuthenticateUser.builder().mergeFromCodedInputStream(input).build()
      }
      public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.AuthenticateUser {
        return UserService.AuthenticateUser.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
      }
      public class func builder() -> UserService.AuthenticateUserBuilder {
        return UserService.AuthenticateUser.classBuilder() as UserService.AuthenticateUserBuilder
      }
      public func builder() -> UserService.AuthenticateUserBuilder {
        return classBuilder() as UserService.AuthenticateUserBuilder
      }
      public override class func classBuilder() -> MessageBuilder {
        return UserService.AuthenticateUserBuilder()
      }
      public override func classBuilder() -> MessageBuilder {
        return UserService.AuthenticateUser.builder()
      }
      public func toBuilder() -> UserService.AuthenticateUserBuilder {
        return UserService.AuthenticateUser.builderWithPrototype(self)
      }
      public class func builderWithPrototype(prototype:UserService.AuthenticateUser) -> UserService.AuthenticateUserBuilder {
        return UserService.AuthenticateUser.builder().mergeFrom(prototype)
      }
      override public func writeDescriptionTo(inout output:String, indent:String) {
        unknownFields.writeDescriptionTo(&output, indent:indent)
      }
      override public var hashValue:Int {
          get {
              var hashCode:Int = 7
              hashCode = (hashCode &* 31) &+  unknownFields.hashValue
              return hashCode
          }
      }


      //Meta information declaration start

      override public class func className() -> String {
          return "UserService.AuthenticateUser"
      }
      override public func className() -> String {
          return "UserService.AuthenticateUser"
      }
      override public func classMetaType() -> GeneratedMessage.Type {
          return UserService.AuthenticateUser.self
      }


      //Meta information declaration end

    }

    final public class AuthenticateUserBuilder : GeneratedMessageBuilder {
      private var builderResult:UserService.AuthenticateUser

      required override public init () {
         builderResult = UserService.AuthenticateUser()
         super.init()
      }
      override public var internalGetResult:GeneratedMessage {
           get {
              return builderResult
           }
      }
      public override func clear() -> UserService.AuthenticateUserBuilder {
        builderResult = UserService.AuthenticateUser()
        return self
      }
      public override func clone() -> UserService.AuthenticateUserBuilder {
        return UserService.AuthenticateUser.builderWithPrototype(builderResult)
      }
      public override func build() -> UserService.AuthenticateUser {
           checkInitialized()
           return buildPartial()
      }
      public func buildPartial() -> UserService.AuthenticateUser {
        var returnMe:UserService.AuthenticateUser = builderResult
        return returnMe
      }
      public func mergeFrom(other:UserService.AuthenticateUser) -> UserService.AuthenticateUserBuilder {
        if (other == UserService.AuthenticateUser()) {
         return self
        }
        mergeUnknownFields(other.unknownFields)
        return self
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream) ->UserService.AuthenticateUserBuilder {
           return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
      }
      public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService.AuthenticateUserBuilder {
        var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
        while (true) {
          var tag = input.readTag()
          switch tag {
          case 0: 
            self.unknownFields = unknownFieldsBuilder.build()
            return self

          default:
            if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
               unknownFields = unknownFieldsBuilder.build()
               return self
            }
          }
        }
      }
    }



  //Nested type declaration end

  required public init() {
       super.init()
  }
  override public func isInitialized() -> Bool {
   return true
  }
  override public func writeToCodedOutputStream(output:CodedOutputStream) {
    unknownFields.writeToCodedOutputStream(output)
  }
  override public func serializedSize() -> Int32 {
    var size:Int32 = memoizedSerializedSize
    if size != -1 {
     return size
    }

    size = 0
    size += unknownFields.serializedSize()
    memoizedSerializedSize = size
    return size
  }
  public class func parseFromData(data:[Byte]) -> UserService {
    return UserService.builder().mergeFromData(data).build()
  }
  public class func parseFromData(data:[Byte], extensionRegistry:ExtensionRegistry) -> UserService {
    return UserService.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromInputStream(input:NSInputStream) -> UserService {
    return UserService.builder().mergeFromInputStream(input).build()
  }
  public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->UserService {
    return UserService.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream) -> UserService {
    return UserService.builder().mergeFromCodedInputStream(input).build()
  }
  public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserService {
    return UserService.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
  }
  public class func builder() -> UserServiceBuilder {
    return UserService.classBuilder() as UserServiceBuilder
  }
  public func builder() -> UserServiceBuilder {
    return classBuilder() as UserServiceBuilder
  }
  public override class func classBuilder() -> MessageBuilder {
    return UserServiceBuilder()
  }
  public override func classBuilder() -> MessageBuilder {
    return UserService.builder()
  }
  public func toBuilder() -> UserServiceBuilder {
    return UserService.builderWithPrototype(self)
  }
  public class func builderWithPrototype(prototype:UserService) -> UserServiceBuilder {
    return UserService.builder().mergeFrom(prototype)
  }
  override public func writeDescriptionTo(inout output:String, indent:String) {
    unknownFields.writeDescriptionTo(&output, indent:indent)
  }
  override public var hashValue:Int {
      get {
          var hashCode:Int = 7
          hashCode = (hashCode &* 31) &+  unknownFields.hashValue
          return hashCode
      }
  }


  //Meta information declaration start

  override public class func className() -> String {
      return "UserService"
  }
  override public func className() -> String {
      return "UserService"
  }
  override public func classMetaType() -> GeneratedMessage.Type {
      return UserService.self
  }


  //Meta information declaration end

}

final public class UserServiceBuilder : GeneratedMessageBuilder {
  private var builderResult:UserService

  required override public init () {
     builderResult = UserService()
     super.init()
  }
  override public var internalGetResult:GeneratedMessage {
       get {
          return builderResult
       }
  }
  public override func clear() -> UserServiceBuilder {
    builderResult = UserService()
    return self
  }
  public override func clone() -> UserServiceBuilder {
    return UserService.builderWithPrototype(builderResult)
  }
  public override func build() -> UserService {
       checkInitialized()
       return buildPartial()
  }
  public func buildPartial() -> UserService {
    var returnMe:UserService = builderResult
    return returnMe
  }
  public func mergeFrom(other:UserService) -> UserServiceBuilder {
    if (other == UserService()) {
     return self
    }
    mergeUnknownFields(other.unknownFields)
    return self
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream) ->UserServiceBuilder {
       return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
  }
  public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> UserServiceBuilder {
    var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
    while (true) {
      var tag = input.readTag()
      switch tag {
      case 0: 
        self.unknownFields = unknownFieldsBuilder.build()
        return self

      default:
        if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
           unknownFields = unknownFieldsBuilder.build()
           return self
        }
      }
    }
  }
}

//Class extensions: NSData


public extension UserService.CreateUser {
    class func parseFromNSData(data:NSData) -> UserService.CreateUser {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return UserService.CreateUser.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> UserService.CreateUser {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return UserService.CreateUser.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
public extension UserService.ValidUser {
    class func parseFromNSData(data:NSData) -> UserService.ValidUser {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return UserService.ValidUser.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> UserService.ValidUser {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return UserService.ValidUser.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
public extension UserService.AuthenticateUser {
    class func parseFromNSData(data:NSData) -> UserService.AuthenticateUser {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return UserService.AuthenticateUser.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> UserService.AuthenticateUser {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return UserService.AuthenticateUser.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}
public extension UserService {
    class func parseFromNSData(data:NSData) -> UserService {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return UserService.builder().mergeFromData(bytes).build()
    }
    class func parseFromNSData(data:NSData, extensionRegistry:ExtensionRegistry) -> UserService {
        var bytes = [Byte](count: data.length, repeatedValue: 0)
        data.getBytes(&bytes)
        return UserService.builder().mergeFromData(bytes, extensionRegistry:extensionRegistry).build()
    }
}

// @@protoc_insertion_point(global_scope)
