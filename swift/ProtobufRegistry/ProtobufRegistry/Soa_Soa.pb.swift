// Generated by the protocol buffer compiler.  DO NOT EDIT!

import Foundation
public struct Soa { }

public func == (lhs: Soa.ControlV1, rhs: Soa.ControlV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasToken == rhs.hasToken) && (!lhs.hasToken || lhs.token == rhs.token)
  fieldCheck = fieldCheck && (lhs.hasService == rhs.hasService) && (!lhs.hasService || lhs.service == rhs.service)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Soa.PaginatorV1, rhs: Soa.PaginatorV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasNextPage == rhs.hasNextPage) && (!lhs.hasNextPage || lhs.nextPage == rhs.nextPage)
  fieldCheck = fieldCheck && (lhs.hasPreviousPage == rhs.hasPreviousPage) && (!lhs.hasPreviousPage || lhs.previousPage == rhs.previousPage)
  fieldCheck = fieldCheck && (lhs.hasCount == rhs.hasCount) && (!lhs.hasCount || lhs.count == rhs.count)
  fieldCheck = fieldCheck && (lhs.hasPageSize == rhs.hasPageSize) && (!lhs.hasPageSize || lhs.pageSize == rhs.pageSize)
  fieldCheck = fieldCheck && (lhs.hasPage == rhs.hasPage) && (!lhs.hasPage || lhs.page == rhs.page)
  fieldCheck = fieldCheck && (lhs.hasTotalPages == rhs.hasTotalPages) && (!lhs.hasTotalPages || lhs.totalPages == rhs.totalPages)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Soa.ActionControlV1, rhs: Soa.ActionControlV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasService == rhs.hasService) && (!lhs.hasService || lhs.service == rhs.service)
  fieldCheck = fieldCheck && (lhs.hasAction == rhs.hasAction) && (!lhs.hasAction || lhs.action == rhs.action)
  fieldCheck = fieldCheck && (lhs.hasPaginator == rhs.hasPaginator) && (!lhs.hasPaginator || lhs.paginator == rhs.paginator)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Soa.ActionRequestV1, rhs: Soa.ActionRequestV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasControl == rhs.hasControl) && (!lhs.hasControl || lhs.control == rhs.control)
  fieldCheck = fieldCheck && (lhs.hasParams == rhs.hasParams) && (!lhs.hasParams || lhs.params == rhs.params)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Soa.ActionRequestParamsV1, rhs: Soa.ActionRequestParamsV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(100), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Soa.ActionResultV1.ErrorDetailV1, rhs: Soa.ActionResultV1.ErrorDetailV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasError == rhs.hasError) && (!lhs.hasError || lhs.error == rhs.error)
  fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
  fieldCheck = fieldCheck && (lhs.hasDetail == rhs.hasDetail) && (!lhs.hasDetail || lhs.detail == rhs.detail)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Soa.ActionResultV1, rhs: Soa.ActionResultV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasSuccess == rhs.hasSuccess) && (!lhs.hasSuccess || lhs.success == rhs.success)
  fieldCheck = fieldCheck && (lhs.errors == rhs.errors)
  fieldCheck = fieldCheck && (lhs.errorDetails == rhs.errorDetails)
  fieldCheck = fieldCheck && lhs.isEqualExtensionsInOther(rhs, startInclusive:Int32(100), endExclusive:Int32(536870912))
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Soa.ActionResponseV1, rhs: Soa.ActionResponseV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasControl == rhs.hasControl) && (!lhs.hasControl || lhs.control == rhs.control)
  fieldCheck = fieldCheck && (lhs.hasResult == rhs.hasResult) && (!lhs.hasResult || lhs.result == rhs.result)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Soa.ServiceRequestV1, rhs: Soa.ServiceRequestV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasControl == rhs.hasControl) && (!lhs.hasControl || lhs.control == rhs.control)
  fieldCheck = fieldCheck && (lhs.actions == rhs.actions)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public func == (lhs: Soa.ServiceResponseV1, rhs: Soa.ServiceResponseV1) -> Bool {
  if (lhs === rhs) {
    return true
  }
  var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
  fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
  fieldCheck = fieldCheck && (lhs.hasControl == rhs.hasControl) && (!lhs.hasControl || lhs.control == rhs.control)
  fieldCheck = fieldCheck && (lhs.actions == rhs.actions)
  return (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
}

public extension Soa {
  public struct SoaRoot {
    public static var sharedInstance : SoaRoot {
     struct Static {
         static let instance : SoaRoot = SoaRoot()
     }
     return Static.instance
    }
    public var extensionRegistry:ExtensionRegistry

    init() {
      extensionRegistry = ExtensionRegistry()
      registerAllExtensions(extensionRegistry)
    }
    public func registerAllExtensions(registry:ExtensionRegistry) {
    }
  }

  final public class ControlV1 : GeneratedMessage, GeneratedMessageProtocol {
    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           case "token": return token
           case "service": return service
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasToken:Bool = false
    public private(set) var token:String = ""

    public private(set) var hasService:Bool = false
    public private(set) var service:String = ""

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      if hasToken {
        output.writeString(2, value:token)
      }
      if hasService {
        output.writeString(3, value:service)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasToken {
        serialize_size += token.computeStringSize(2)
      }
      if hasService {
        serialize_size += service.computeStringSize(3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Soa.ControlV1 {
      return Soa.ControlV1.builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Soa.ControlV1 {
      return Soa.ControlV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Soa.ControlV1 {
      return Soa.ControlV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Soa.ControlV1 {
      return Soa.ControlV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Soa.ControlV1 {
      return Soa.ControlV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ControlV1 {
      return Soa.ControlV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Soa.ControlV1Builder {
      return Soa.ControlV1.classBuilder() as! Soa.ControlV1Builder
    }
    public func builder() -> Soa.ControlV1Builder {
      return classBuilder() as! Soa.ControlV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ControlV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ControlV1.builder()
    }
    public func toBuilder() -> Soa.ControlV1Builder {
      return Soa.ControlV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ControlV1) -> Soa.ControlV1Builder {
      return Soa.ControlV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasToken {
        output += "\(indent) token: \(token) \n"
      }
      if hasService {
        output += "\(indent) service: \(service) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasToken {
               hashCode = (hashCode &* 31) &+ token.hashValue
            }
            if hasService {
               hashCode = (hashCode &* 31) &+ service.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ControlV1"
    }
    override public func className() -> String {
        return "Soa.ControlV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ControlV1.self
    }
    //Meta information declaration end

  }

  final public class ControlV1Builder : GeneratedMessageBuilder {
    private var builderResult:Soa.ControlV1

    required override public init () {
       builderResult = Soa.ControlV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Soa.ControlV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Soa.ControlV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    public var hasToken:Bool {
         get {
              return builderResult.hasToken
         }
    }
    public var token:String {
         get {
              return builderResult.token
         }
         set (value) {
             builderResult.hasToken = true
             builderResult.token = value
         }
    }
    public func setToken(value:String)-> Soa.ControlV1Builder {
      self.token = value
      return self
    }
    public func clearToken() -> Soa.ControlV1Builder{
         builderResult.hasToken = false
         builderResult.token = ""
         return self
    }
    public var hasService:Bool {
         get {
              return builderResult.hasService
         }
    }
    public var service:String {
         get {
              return builderResult.service
         }
         set (value) {
             builderResult.hasService = true
             builderResult.service = value
         }
    }
    public func setService(value:String)-> Soa.ControlV1Builder {
      self.service = value
      return self
    }
    public func clearService() -> Soa.ControlV1Builder{
         builderResult.hasService = false
         builderResult.service = ""
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Soa.ControlV1Builder {
      builderResult = Soa.ControlV1()
      return self
    }
    public override func clone() -> Soa.ControlV1Builder {
      return Soa.ControlV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Soa.ControlV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Soa.ControlV1 {
      var returnMe:Soa.ControlV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Soa.ControlV1) -> Soa.ControlV1Builder {
      if (other == Soa.ControlV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      if other.hasToken {
           token = other.token
      }
      if other.hasService {
           service = other.service
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Soa.ControlV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ControlV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        case 18 :
          token = input.readString()

        case 26 :
          service = input.readString()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class PaginatorV1 : GeneratedMessage, GeneratedMessageProtocol {
    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           case "nextPage": return nextPage
           case "previousPage": return previousPage
           case "count": return count
           case "pageSize": return pageSize
           case "page": return page
           case "totalPages": return totalPages
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasNextPage:Bool = false
    public private(set) var nextPage:UInt32 = UInt32(0)

    public private(set) var hasPreviousPage:Bool = false
    public private(set) var previousPage:UInt32 = UInt32(0)

    public private(set) var hasCount:Bool = false
    public private(set) var count:UInt32 = UInt32(0)

    public private(set) var hasPageSize:Bool = false
    public private(set) var pageSize:UInt32 = UInt32(0)

    public private(set) var hasPage:Bool = false
    public private(set) var page:UInt32 = UInt32(1)

    public private(set) var hasTotalPages:Bool = false
    public private(set) var totalPages:UInt32 = UInt32(0)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      if hasNextPage {
        output.writeUInt32(2, value:nextPage)
      }
      if hasPreviousPage {
        output.writeUInt32(3, value:previousPage)
      }
      if hasCount {
        output.writeUInt32(4, value:count)
      }
      if hasPageSize {
        output.writeUInt32(5, value:pageSize)
      }
      if hasPage {
        output.writeUInt32(6, value:page)
      }
      if hasTotalPages {
        output.writeUInt32(7, value:totalPages)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasNextPage {
        serialize_size += nextPage.computeUInt32Size(2)
      }
      if hasPreviousPage {
        serialize_size += previousPage.computeUInt32Size(3)
      }
      if hasCount {
        serialize_size += count.computeUInt32Size(4)
      }
      if hasPageSize {
        serialize_size += pageSize.computeUInt32Size(5)
      }
      if hasPage {
        serialize_size += page.computeUInt32Size(6)
      }
      if hasTotalPages {
        serialize_size += totalPages.computeUInt32Size(7)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Soa.PaginatorV1 {
      return Soa.PaginatorV1.builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Soa.PaginatorV1 {
      return Soa.PaginatorV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Soa.PaginatorV1 {
      return Soa.PaginatorV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Soa.PaginatorV1 {
      return Soa.PaginatorV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Soa.PaginatorV1 {
      return Soa.PaginatorV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.PaginatorV1 {
      return Soa.PaginatorV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Soa.PaginatorV1Builder {
      return Soa.PaginatorV1.classBuilder() as! Soa.PaginatorV1Builder
    }
    public func builder() -> Soa.PaginatorV1Builder {
      return classBuilder() as! Soa.PaginatorV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.PaginatorV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.PaginatorV1.builder()
    }
    public func toBuilder() -> Soa.PaginatorV1Builder {
      return Soa.PaginatorV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.PaginatorV1) -> Soa.PaginatorV1Builder {
      return Soa.PaginatorV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasNextPage {
        output += "\(indent) nextPage: \(nextPage) \n"
      }
      if hasPreviousPage {
        output += "\(indent) previousPage: \(previousPage) \n"
      }
      if hasCount {
        output += "\(indent) count: \(count) \n"
      }
      if hasPageSize {
        output += "\(indent) pageSize: \(pageSize) \n"
      }
      if hasPage {
        output += "\(indent) page: \(page) \n"
      }
      if hasTotalPages {
        output += "\(indent) totalPages: \(totalPages) \n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasNextPage {
               hashCode = (hashCode &* 31) &+ nextPage.hashValue
            }
            if hasPreviousPage {
               hashCode = (hashCode &* 31) &+ previousPage.hashValue
            }
            if hasCount {
               hashCode = (hashCode &* 31) &+ count.hashValue
            }
            if hasPageSize {
               hashCode = (hashCode &* 31) &+ pageSize.hashValue
            }
            if hasPage {
               hashCode = (hashCode &* 31) &+ page.hashValue
            }
            if hasTotalPages {
               hashCode = (hashCode &* 31) &+ totalPages.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.PaginatorV1"
    }
    override public func className() -> String {
        return "Soa.PaginatorV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.PaginatorV1.self
    }
    //Meta information declaration end

  }

  final public class PaginatorV1Builder : GeneratedMessageBuilder {
    private var builderResult:Soa.PaginatorV1

    required override public init () {
       builderResult = Soa.PaginatorV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Soa.PaginatorV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Soa.PaginatorV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    public var hasNextPage:Bool {
         get {
              return builderResult.hasNextPage
         }
    }
    public var nextPage:UInt32 {
         get {
              return builderResult.nextPage
         }
         set (value) {
             builderResult.hasNextPage = true
             builderResult.nextPage = value
         }
    }
    public func setNextPage(value:UInt32)-> Soa.PaginatorV1Builder {
      self.nextPage = value
      return self
    }
    public func clearNextPage() -> Soa.PaginatorV1Builder{
         builderResult.hasNextPage = false
         builderResult.nextPage = UInt32(0)
         return self
    }
    public var hasPreviousPage:Bool {
         get {
              return builderResult.hasPreviousPage
         }
    }
    public var previousPage:UInt32 {
         get {
              return builderResult.previousPage
         }
         set (value) {
             builderResult.hasPreviousPage = true
             builderResult.previousPage = value
         }
    }
    public func setPreviousPage(value:UInt32)-> Soa.PaginatorV1Builder {
      self.previousPage = value
      return self
    }
    public func clearPreviousPage() -> Soa.PaginatorV1Builder{
         builderResult.hasPreviousPage = false
         builderResult.previousPage = UInt32(0)
         return self
    }
    public var hasCount:Bool {
         get {
              return builderResult.hasCount
         }
    }
    public var count:UInt32 {
         get {
              return builderResult.count
         }
         set (value) {
             builderResult.hasCount = true
             builderResult.count = value
         }
    }
    public func setCount(value:UInt32)-> Soa.PaginatorV1Builder {
      self.count = value
      return self
    }
    public func clearCount() -> Soa.PaginatorV1Builder{
         builderResult.hasCount = false
         builderResult.count = UInt32(0)
         return self
    }
    public var hasPageSize:Bool {
         get {
              return builderResult.hasPageSize
         }
    }
    public var pageSize:UInt32 {
         get {
              return builderResult.pageSize
         }
         set (value) {
             builderResult.hasPageSize = true
             builderResult.pageSize = value
         }
    }
    public func setPageSize(value:UInt32)-> Soa.PaginatorV1Builder {
      self.pageSize = value
      return self
    }
    public func clearPageSize() -> Soa.PaginatorV1Builder{
         builderResult.hasPageSize = false
         builderResult.pageSize = UInt32(0)
         return self
    }
    public var hasPage:Bool {
         get {
              return builderResult.hasPage
         }
    }
    public var page:UInt32 {
         get {
              return builderResult.page
         }
         set (value) {
             builderResult.hasPage = true
             builderResult.page = value
         }
    }
    public func setPage(value:UInt32)-> Soa.PaginatorV1Builder {
      self.page = value
      return self
    }
    public func clearPage() -> Soa.PaginatorV1Builder{
         builderResult.hasPage = false
         builderResult.page = UInt32(1)
         return self
    }
    public var hasTotalPages:Bool {
         get {
              return builderResult.hasTotalPages
         }
    }
    public var totalPages:UInt32 {
         get {
              return builderResult.totalPages
         }
         set (value) {
             builderResult.hasTotalPages = true
             builderResult.totalPages = value
         }
    }
    public func setTotalPages(value:UInt32)-> Soa.PaginatorV1Builder {
      self.totalPages = value
      return self
    }
    public func clearTotalPages() -> Soa.PaginatorV1Builder{
         builderResult.hasTotalPages = false
         builderResult.totalPages = UInt32(0)
         return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Soa.PaginatorV1Builder {
      builderResult = Soa.PaginatorV1()
      return self
    }
    public override func clone() -> Soa.PaginatorV1Builder {
      return Soa.PaginatorV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Soa.PaginatorV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Soa.PaginatorV1 {
      var returnMe:Soa.PaginatorV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Soa.PaginatorV1) -> Soa.PaginatorV1Builder {
      if (other == Soa.PaginatorV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      if other.hasNextPage {
           nextPage = other.nextPage
      }
      if other.hasPreviousPage {
           previousPage = other.previousPage
      }
      if other.hasCount {
           count = other.count
      }
      if other.hasPageSize {
           pageSize = other.pageSize
      }
      if other.hasPage {
           page = other.page
      }
      if other.hasTotalPages {
           totalPages = other.totalPages
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Soa.PaginatorV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.PaginatorV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        case 16 :
          nextPage = input.readUInt32()

        case 24 :
          previousPage = input.readUInt32()

        case 32 :
          count = input.readUInt32()

        case 40 :
          pageSize = input.readUInt32()

        case 48 :
          page = input.readUInt32()

        case 56 :
          totalPages = input.readUInt32()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class ActionControlV1 : GeneratedMessage, GeneratedMessageProtocol {
    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           case "service": return service
           case "action": return action
           case "paginator": return paginator
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasService:Bool = false
    public private(set) var service:String = ""

    public private(set) var hasAction:Bool = false
    public private(set) var action:String = ""

    public private(set) var hasPaginator:Bool = false
    public private(set) var paginator:Soa.PaginatorV1!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      if hasService {
        output.writeString(2, value:service)
      }
      if hasAction {
        output.writeString(3, value:action)
      }
      if hasPaginator {
        output.writeMessage(4, value:paginator)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasService {
        serialize_size += service.computeStringSize(2)
      }
      if hasAction {
        serialize_size += action.computeStringSize(3)
      }
      if hasPaginator {
          if let varSizepaginator = paginator?.computeMessageSize(4) {
              serialize_size += varSizepaginator
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Soa.ActionControlV1 {
      return Soa.ActionControlV1.builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Soa.ActionControlV1 {
      return Soa.ActionControlV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Soa.ActionControlV1 {
      return Soa.ActionControlV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Soa.ActionControlV1 {
      return Soa.ActionControlV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Soa.ActionControlV1 {
      return Soa.ActionControlV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ActionControlV1 {
      return Soa.ActionControlV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Soa.ActionControlV1Builder {
      return Soa.ActionControlV1.classBuilder() as! Soa.ActionControlV1Builder
    }
    public func builder() -> Soa.ActionControlV1Builder {
      return classBuilder() as! Soa.ActionControlV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ActionControlV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ActionControlV1.builder()
    }
    public func toBuilder() -> Soa.ActionControlV1Builder {
      return Soa.ActionControlV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ActionControlV1) -> Soa.ActionControlV1Builder {
      return Soa.ActionControlV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasService {
        output += "\(indent) service: \(service) \n"
      }
      if hasAction {
        output += "\(indent) action: \(action) \n"
      }
      if hasPaginator {
        output += "\(indent) paginator {\n"
        paginator?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasService {
               hashCode = (hashCode &* 31) &+ service.hashValue
            }
            if hasAction {
               hashCode = (hashCode &* 31) &+ action.hashValue
            }
            if hasPaginator {
                if let hashValuepaginator = paginator?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepaginator
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ActionControlV1"
    }
    override public func className() -> String {
        return "Soa.ActionControlV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ActionControlV1.self
    }
    //Meta information declaration end

  }

  final public class ActionControlV1Builder : GeneratedMessageBuilder {
    private var builderResult:Soa.ActionControlV1

    required override public init () {
       builderResult = Soa.ActionControlV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Soa.ActionControlV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Soa.ActionControlV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    public var hasService:Bool {
         get {
              return builderResult.hasService
         }
    }
    public var service:String {
         get {
              return builderResult.service
         }
         set (value) {
             builderResult.hasService = true
             builderResult.service = value
         }
    }
    public func setService(value:String)-> Soa.ActionControlV1Builder {
      self.service = value
      return self
    }
    public func clearService() -> Soa.ActionControlV1Builder{
         builderResult.hasService = false
         builderResult.service = ""
         return self
    }
    public var hasAction:Bool {
         get {
              return builderResult.hasAction
         }
    }
    public var action:String {
         get {
              return builderResult.action
         }
         set (value) {
             builderResult.hasAction = true
             builderResult.action = value
         }
    }
    public func setAction(value:String)-> Soa.ActionControlV1Builder {
      self.action = value
      return self
    }
    public func clearAction() -> Soa.ActionControlV1Builder{
         builderResult.hasAction = false
         builderResult.action = ""
         return self
    }
    public var hasPaginator:Bool {
         get {
             return builderResult.hasPaginator
         }
    }
    public var paginator:Soa.PaginatorV1! {
         get {
             return builderResult.paginator
         }
         set (value) {
             builderResult.hasPaginator = true
             builderResult.paginator = value
         }
    }
    public func setPaginator(value:Soa.PaginatorV1!)-> Soa.ActionControlV1Builder {
      self.paginator = value
      return self
    }
    public func mergePaginator(value:Soa.PaginatorV1) -> Soa.ActionControlV1Builder {
      if (builderResult.hasPaginator) {
        builderResult.paginator = Soa.PaginatorV1.builderWithPrototype(builderResult.paginator).mergeFrom(value).buildPartial()
      } else {
        builderResult.paginator = value
      }
      builderResult.hasPaginator = true
      return self
    }
    public func clearPaginator() -> Soa.ActionControlV1Builder {
      builderResult.hasPaginator = false
      builderResult.paginator = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Soa.ActionControlV1Builder {
      builderResult = Soa.ActionControlV1()
      return self
    }
    public override func clone() -> Soa.ActionControlV1Builder {
      return Soa.ActionControlV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Soa.ActionControlV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Soa.ActionControlV1 {
      var returnMe:Soa.ActionControlV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Soa.ActionControlV1) -> Soa.ActionControlV1Builder {
      if (other == Soa.ActionControlV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      if other.hasService {
           service = other.service
      }
      if other.hasAction {
           action = other.action
      }
      if (other.hasPaginator) {
          mergePaginator(other.paginator)
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Soa.ActionControlV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ActionControlV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        case 18 :
          service = input.readString()

        case 26 :
          action = input.readString()

        case 34 :
          var subBuilder:Soa.PaginatorV1Builder = Soa.PaginatorV1.builder()
          if hasPaginator {
            subBuilder.mergeFrom(paginator)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          paginator = subBuilder.buildPartial()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class ActionRequestV1 : GeneratedMessage, GeneratedMessageProtocol {
    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           case "control": return control
           case "params": return params
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasControl:Bool = false
    public private(set) var control:Soa.ActionControlV1!
    public private(set) var hasParams:Bool = false
    public private(set) var params:Soa.ActionRequestParamsV1!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasParams {
       if !params.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      if hasControl {
        output.writeMessage(2, value:control)
      }
      if hasParams {
        output.writeMessage(3, value:params)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasControl {
          if let varSizecontrol = control?.computeMessageSize(2) {
              serialize_size += varSizecontrol
          }
      }
      if hasParams {
          if let varSizeparams = params?.computeMessageSize(3) {
              serialize_size += varSizeparams
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Soa.ActionRequestV1 {
      return Soa.ActionRequestV1.builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Soa.ActionRequestV1 {
      return Soa.ActionRequestV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Soa.ActionRequestV1 {
      return Soa.ActionRequestV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Soa.ActionRequestV1 {
      return Soa.ActionRequestV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Soa.ActionRequestV1 {
      return Soa.ActionRequestV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ActionRequestV1 {
      return Soa.ActionRequestV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Soa.ActionRequestV1Builder {
      return Soa.ActionRequestV1.classBuilder() as! Soa.ActionRequestV1Builder
    }
    public func builder() -> Soa.ActionRequestV1Builder {
      return classBuilder() as! Soa.ActionRequestV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ActionRequestV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ActionRequestV1.builder()
    }
    public func toBuilder() -> Soa.ActionRequestV1Builder {
      return Soa.ActionRequestV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ActionRequestV1) -> Soa.ActionRequestV1Builder {
      return Soa.ActionRequestV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasControl {
        output += "\(indent) control {\n"
        control?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasParams {
        output += "\(indent) params {\n"
        params?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasControl {
                if let hashValuecontrol = control?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecontrol
                }
            }
            if hasParams {
                if let hashValueparams = params?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueparams
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ActionRequestV1"
    }
    override public func className() -> String {
        return "Soa.ActionRequestV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ActionRequestV1.self
    }
    //Meta information declaration end

  }

  final public class ActionRequestV1Builder : GeneratedMessageBuilder {
    private var builderResult:Soa.ActionRequestV1

    required override public init () {
       builderResult = Soa.ActionRequestV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Soa.ActionRequestV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Soa.ActionRequestV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    public var hasControl:Bool {
         get {
             return builderResult.hasControl
         }
    }
    public var control:Soa.ActionControlV1! {
         get {
             return builderResult.control
         }
         set (value) {
             builderResult.hasControl = true
             builderResult.control = value
         }
    }
    public func setControl(value:Soa.ActionControlV1!)-> Soa.ActionRequestV1Builder {
      self.control = value
      return self
    }
    public func mergeControl(value:Soa.ActionControlV1) -> Soa.ActionRequestV1Builder {
      if (builderResult.hasControl) {
        builderResult.control = Soa.ActionControlV1.builderWithPrototype(builderResult.control).mergeFrom(value).buildPartial()
      } else {
        builderResult.control = value
      }
      builderResult.hasControl = true
      return self
    }
    public func clearControl() -> Soa.ActionRequestV1Builder {
      builderResult.hasControl = false
      builderResult.control = nil
      return self
    }
    public var hasParams:Bool {
         get {
             return builderResult.hasParams
         }
    }
    public var params:Soa.ActionRequestParamsV1! {
         get {
             return builderResult.params
         }
         set (value) {
             builderResult.hasParams = true
             builderResult.params = value
         }
    }
    public func setParams(value:Soa.ActionRequestParamsV1!)-> Soa.ActionRequestV1Builder {
      self.params = value
      return self
    }
    public func mergeParams(value:Soa.ActionRequestParamsV1) -> Soa.ActionRequestV1Builder {
      if (builderResult.hasParams) {
        builderResult.params = Soa.ActionRequestParamsV1.builderWithPrototype(builderResult.params).mergeFrom(value).buildPartial()
      } else {
        builderResult.params = value
      }
      builderResult.hasParams = true
      return self
    }
    public func clearParams() -> Soa.ActionRequestV1Builder {
      builderResult.hasParams = false
      builderResult.params = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Soa.ActionRequestV1Builder {
      builderResult = Soa.ActionRequestV1()
      return self
    }
    public override func clone() -> Soa.ActionRequestV1Builder {
      return Soa.ActionRequestV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Soa.ActionRequestV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Soa.ActionRequestV1 {
      var returnMe:Soa.ActionRequestV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Soa.ActionRequestV1) -> Soa.ActionRequestV1Builder {
      if (other == Soa.ActionRequestV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      if (other.hasControl) {
          mergeControl(other.control)
      }
      if (other.hasParams) {
          mergeParams(other.params)
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Soa.ActionRequestV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ActionRequestV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        case 18 :
          var subBuilder:Soa.ActionControlV1Builder = Soa.ActionControlV1.builder()
          if hasControl {
            subBuilder.mergeFrom(control)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          control = subBuilder.buildPartial()

        case 26 :
          var subBuilder:Soa.ActionRequestParamsV1Builder = Soa.ActionRequestParamsV1.builder()
          if hasParams {
            subBuilder.mergeFrom(params)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          params = subBuilder.buildPartial()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class ActionRequestParamsV1 : ExtendableMessage, GeneratedMessageProtocol {
    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      writeExtensionsToCodedOutputStream(output, startInclusive:Int32(100), endExclusive:Int32(536870912))
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Soa.ActionRequestParamsV1 {
      return Soa.ActionRequestParamsV1.builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Soa.ActionRequestParamsV1 {
      return Soa.ActionRequestParamsV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Soa.ActionRequestParamsV1 {
      return Soa.ActionRequestParamsV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Soa.ActionRequestParamsV1 {
      return Soa.ActionRequestParamsV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Soa.ActionRequestParamsV1 {
      return Soa.ActionRequestParamsV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ActionRequestParamsV1 {
      return Soa.ActionRequestParamsV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Soa.ActionRequestParamsV1Builder {
      return Soa.ActionRequestParamsV1.classBuilder() as! Soa.ActionRequestParamsV1Builder
    }
    public func builder() -> Soa.ActionRequestParamsV1Builder {
      return classBuilder() as! Soa.ActionRequestParamsV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ActionRequestParamsV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ActionRequestParamsV1.builder()
    }
    public func toBuilder() -> Soa.ActionRequestParamsV1Builder {
      return Soa.ActionRequestParamsV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ActionRequestParamsV1) -> Soa.ActionRequestParamsV1Builder {
      return Soa.ActionRequestParamsV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      writeExtensionDescription(&output, startInclusive:Int32(100), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(100), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ActionRequestParamsV1"
    }
    override public func className() -> String {
        return "Soa.ActionRequestParamsV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ActionRequestParamsV1.self
    }
    //Meta information declaration end

  }

  final public class ActionRequestParamsV1Builder : ExtendableMessageBuilder {
    private var builderResult:Soa.ActionRequestParamsV1

    required override public init () {
       builderResult = Soa.ActionRequestParamsV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Soa.ActionRequestParamsV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Soa.ActionRequestParamsV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    override public var internalGetResult:ExtendableMessage {
         get {
             return builderResult
         }
    }
    public override func clear() -> Soa.ActionRequestParamsV1Builder {
      builderResult = Soa.ActionRequestParamsV1()
      return self
    }
    public override func clone() -> Soa.ActionRequestParamsV1Builder {
      return Soa.ActionRequestParamsV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Soa.ActionRequestParamsV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Soa.ActionRequestParamsV1 {
      var returnMe:Soa.ActionRequestParamsV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Soa.ActionRequestParamsV1) -> Soa.ActionRequestParamsV1Builder {
      if (other == Soa.ActionRequestParamsV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      mergeExtensionFields(other)
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Soa.ActionRequestParamsV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ActionRequestParamsV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class ActionResultV1 : ExtendableMessage, GeneratedMessageProtocol {


    //Nested type declaration start

      final public class ErrorDetailV1 : GeneratedMessage, GeneratedMessageProtocol {
        public subscript(key: String) -> Any? {
               switch key {
               case "version": return version
               case "error": return error
               case "key": return key
               case "detail": return detail
               default: return nil
               }
        }

        public private(set) var hasVersion:Bool = false
        public private(set) var version:UInt32 = UInt32(1)

        public private(set) var hasError:Bool = false
        public private(set) var error:String = ""

        public private(set) var hasKey:Bool = false
        public private(set) var key:String = ""

        public private(set) var hasDetail:Bool = false
        public private(set) var detail:String = ""

        required public init() {
             super.init()
        }
        override public func isInitialized() -> Bool {
         return true
        }
        override public func writeToCodedOutputStream(output:CodedOutputStream) {
          if hasVersion {
            output.writeUInt32(1, value:version)
          }
          if hasError {
            output.writeString(2, value:error)
          }
          if hasKey {
            output.writeString(3, value:key)
          }
          if hasDetail {
            output.writeString(4, value:detail)
          }
          unknownFields.writeToCodedOutputStream(output)
        }
        override public func serializedSize() -> Int32 {
          var serialize_size:Int32 = memoizedSerializedSize
          if serialize_size != -1 {
           return serialize_size
          }

          serialize_size = 0
          if hasVersion {
            serialize_size += version.computeUInt32Size(1)
          }
          if hasError {
            serialize_size += error.computeStringSize(2)
          }
          if hasKey {
            serialize_size += key.computeStringSize(3)
          }
          if hasDetail {
            serialize_size += detail.computeStringSize(4)
          }
          serialize_size += unknownFields.serializedSize()
          memoizedSerializedSize = serialize_size
          return serialize_size
        }
        public class func parseFromData(data:NSData) -> Soa.ActionResultV1.ErrorDetailV1 {
          return Soa.ActionResultV1.ErrorDetailV1.builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
        }
        public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Soa.ActionResultV1.ErrorDetailV1 {
          return Soa.ActionResultV1.ErrorDetailV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromInputStream(input:NSInputStream) -> Soa.ActionResultV1.ErrorDetailV1 {
          return Soa.ActionResultV1.ErrorDetailV1.builder().mergeFromInputStream(input).build()
        }
        public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Soa.ActionResultV1.ErrorDetailV1 {
          return Soa.ActionResultV1.ErrorDetailV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream) -> Soa.ActionResultV1.ErrorDetailV1 {
          return Soa.ActionResultV1.ErrorDetailV1.builder().mergeFromCodedInputStream(input).build()
        }
        public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ActionResultV1.ErrorDetailV1 {
          return Soa.ActionResultV1.ErrorDetailV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
        }
        public class func builder() -> Soa.ActionResultV1.ErrorDetailV1Builder {
          return Soa.ActionResultV1.ErrorDetailV1.classBuilder() as! Soa.ActionResultV1.ErrorDetailV1Builder
        }
        public func builder() -> Soa.ActionResultV1.ErrorDetailV1Builder {
          return classBuilder() as! Soa.ActionResultV1.ErrorDetailV1Builder
        }
        public override class func classBuilder() -> MessageBuilder {
          return Soa.ActionResultV1.ErrorDetailV1Builder()
        }
        public override func classBuilder() -> MessageBuilder {
          return Soa.ActionResultV1.ErrorDetailV1.builder()
        }
        public func toBuilder() -> Soa.ActionResultV1.ErrorDetailV1Builder {
          return Soa.ActionResultV1.ErrorDetailV1.builderWithPrototype(self)
        }
        public class func builderWithPrototype(prototype:Soa.ActionResultV1.ErrorDetailV1) -> Soa.ActionResultV1.ErrorDetailV1Builder {
          return Soa.ActionResultV1.ErrorDetailV1.builder().mergeFrom(prototype)
        }
        override public func writeDescriptionTo(inout output:String, indent:String) {
          if hasVersion {
            output += "\(indent) version: \(version) \n"
          }
          if hasError {
            output += "\(indent) error: \(error) \n"
          }
          if hasKey {
            output += "\(indent) key: \(key) \n"
          }
          if hasDetail {
            output += "\(indent) detail: \(detail) \n"
          }
          unknownFields.writeDescriptionTo(&output, indent:indent)
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasVersion {
                   hashCode = (hashCode &* 31) &+ version.hashValue
                }
                if hasError {
                   hashCode = (hashCode &* 31) &+ error.hashValue
                }
                if hasKey {
                   hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasDetail {
                   hashCode = (hashCode &* 31) &+ detail.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Soa.ActionResultV1.ErrorDetailV1"
        }
        override public func className() -> String {
            return "Soa.ActionResultV1.ErrorDetailV1"
        }
        override public func classMetaType() -> GeneratedMessage.Type {
            return Soa.ActionResultV1.ErrorDetailV1.self
        }
        //Meta information declaration end

      }

      final public class ErrorDetailV1Builder : GeneratedMessageBuilder {
        private var builderResult:Soa.ActionResultV1.ErrorDetailV1

        required override public init () {
           builderResult = Soa.ActionResultV1.ErrorDetailV1()
           super.init()
        }
        public var hasVersion:Bool {
             get {
                  return builderResult.hasVersion
             }
        }
        public var version:UInt32 {
             get {
                  return builderResult.version
             }
             set (value) {
                 builderResult.hasVersion = true
                 builderResult.version = value
             }
        }
        public func setVersion(value:UInt32)-> Soa.ActionResultV1.ErrorDetailV1Builder {
          self.version = value
          return self
        }
        public func clearVersion() -> Soa.ActionResultV1.ErrorDetailV1Builder{
             builderResult.hasVersion = false
             builderResult.version = UInt32(1)
             return self
        }
        public var hasError:Bool {
             get {
                  return builderResult.hasError
             }
        }
        public var error:String {
             get {
                  return builderResult.error
             }
             set (value) {
                 builderResult.hasError = true
                 builderResult.error = value
             }
        }
        public func setError(value:String)-> Soa.ActionResultV1.ErrorDetailV1Builder {
          self.error = value
          return self
        }
        public func clearError() -> Soa.ActionResultV1.ErrorDetailV1Builder{
             builderResult.hasError = false
             builderResult.error = ""
             return self
        }
        public var hasKey:Bool {
             get {
                  return builderResult.hasKey
             }
        }
        public var key:String {
             get {
                  return builderResult.key
             }
             set (value) {
                 builderResult.hasKey = true
                 builderResult.key = value
             }
        }
        public func setKey(value:String)-> Soa.ActionResultV1.ErrorDetailV1Builder {
          self.key = value
          return self
        }
        public func clearKey() -> Soa.ActionResultV1.ErrorDetailV1Builder{
             builderResult.hasKey = false
             builderResult.key = ""
             return self
        }
        public var hasDetail:Bool {
             get {
                  return builderResult.hasDetail
             }
        }
        public var detail:String {
             get {
                  return builderResult.detail
             }
             set (value) {
                 builderResult.hasDetail = true
                 builderResult.detail = value
             }
        }
        public func setDetail(value:String)-> Soa.ActionResultV1.ErrorDetailV1Builder {
          self.detail = value
          return self
        }
        public func clearDetail() -> Soa.ActionResultV1.ErrorDetailV1Builder{
             builderResult.hasDetail = false
             builderResult.detail = ""
             return self
        }
        override public var internalGetResult:GeneratedMessage {
             get {
                return builderResult
             }
        }
        public override func clear() -> Soa.ActionResultV1.ErrorDetailV1Builder {
          builderResult = Soa.ActionResultV1.ErrorDetailV1()
          return self
        }
        public override func clone() -> Soa.ActionResultV1.ErrorDetailV1Builder {
          return Soa.ActionResultV1.ErrorDetailV1.builderWithPrototype(builderResult)
        }
        public override func build() -> Soa.ActionResultV1.ErrorDetailV1 {
             checkInitialized()
             return buildPartial()
        }
        public func buildPartial() -> Soa.ActionResultV1.ErrorDetailV1 {
          var returnMe:Soa.ActionResultV1.ErrorDetailV1 = builderResult
          return returnMe
        }
        public func mergeFrom(other:Soa.ActionResultV1.ErrorDetailV1) -> Soa.ActionResultV1.ErrorDetailV1Builder {
          if (other == Soa.ActionResultV1.ErrorDetailV1()) {
           return self
          }
          if other.hasVersion {
               version = other.version
          }
          if other.hasError {
               error = other.error
          }
          if other.hasKey {
               key = other.key
          }
          if other.hasDetail {
               detail = other.detail
          }
          mergeUnknownFields(other.unknownFields)
          return self
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream) ->Soa.ActionResultV1.ErrorDetailV1Builder {
             return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
        }
        public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ActionResultV1.ErrorDetailV1Builder {
          var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
          while (true) {
            var tag = input.readTag()
            switch tag {
            case 0: 
              self.unknownFields = unknownFieldsBuilder.build()
              return self

            case 8 :
              version = input.readUInt32()

            case 18 :
              error = input.readString()

            case 26 :
              key = input.readString()

            case 34 :
              detail = input.readString()

            default:
              if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
                 unknownFields = unknownFieldsBuilder.build()
                 return self
              }
            }
          }
        }
      }

    //Nested type declaration end

    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           case "success": return success
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasSuccess:Bool = false
    public private(set) var success:Bool = false

    public private(set) var errors:Array<String> = Array<String>()
    public private(set) var errorDetails:Array<Soa.ActionResultV1.ErrorDetailV1>  = Array<Soa.ActionResultV1.ErrorDetailV1>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if !extensionsAreInitialized() {
       return false
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      if hasSuccess {
        output.writeBool(2, value:success)
      }
      if !errors.isEmpty {
        for oneValueerrors in errors {
          output.writeString(3, value:oneValueerrors)
        }
      }
      for oneElementerrorDetails in errorDetails {
          output.writeMessage(4, value:oneElementerrorDetails)
      }
      writeExtensionsToCodedOutputStream(output, startInclusive:Int32(100), endExclusive:Int32(536870912))
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasSuccess {
        serialize_size += success.computeBoolSize(2)
      }
      var dataSizeErrors:Int32 = 0
      for oneValueerrors in errors {
          dataSizeErrors += oneValueerrors.computeStringSizeNoTag()
      }
      serialize_size += dataSizeErrors
      serialize_size += 1 * Int32(errors.count)
      for oneElementerrorDetails in errorDetails {
          serialize_size += oneElementerrorDetails.computeMessageSize(4)
      }
      serialize_size += extensionsSerializedSize()
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Soa.ActionResultV1 {
      return Soa.ActionResultV1.builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Soa.ActionResultV1 {
      return Soa.ActionResultV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Soa.ActionResultV1 {
      return Soa.ActionResultV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Soa.ActionResultV1 {
      return Soa.ActionResultV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Soa.ActionResultV1 {
      return Soa.ActionResultV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ActionResultV1 {
      return Soa.ActionResultV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Soa.ActionResultV1Builder {
      return Soa.ActionResultV1.classBuilder() as! Soa.ActionResultV1Builder
    }
    public func builder() -> Soa.ActionResultV1Builder {
      return classBuilder() as! Soa.ActionResultV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ActionResultV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ActionResultV1.builder()
    }
    public func toBuilder() -> Soa.ActionResultV1Builder {
      return Soa.ActionResultV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ActionResultV1) -> Soa.ActionResultV1Builder {
      return Soa.ActionResultV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasSuccess {
        output += "\(indent) success: \(success) \n"
      }
      var errorsElementIndex:Int = 0
      for oneValueerrors in errors  {
          output += "\(indent) errors[\(errorsElementIndex)]: \(oneValueerrors)\n"
          errorsElementIndex++
      }
      var errorDetailsElementIndex:Int = 0
      for oneElementerrorDetails in errorDetails {
          output += "\(indent) errorDetails[\(errorDetailsElementIndex)] {\n"
          oneElementerrorDetails.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          errorDetailsElementIndex++
      }
      writeExtensionDescription(&output, startInclusive:Int32(100), endExclusive:Int32(536870912), indent:indent)
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasSuccess {
               hashCode = (hashCode &* 31) &+ success.hashValue
            }
            for oneValueerrors in errors {
                hashCode = (hashCode &* 31) &+ oneValueerrors.hashValue
            }
            for oneElementerrorDetails in errorDetails {
                hashCode = (hashCode &* 31) &+ oneElementerrorDetails.hashValue
            }
            hashCode = (hashCode &* 31) &+ Int(hashExtensionsFrom(Int32(100), endExclusive:Int32(536870912)))
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ActionResultV1"
    }
    override public func className() -> String {
        return "Soa.ActionResultV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ActionResultV1.self
    }
    //Meta information declaration end

  }

  final public class ActionResultV1Builder : ExtendableMessageBuilder {
    private var builderResult:Soa.ActionResultV1

    required override public init () {
       builderResult = Soa.ActionResultV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Soa.ActionResultV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Soa.ActionResultV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    public var hasSuccess:Bool {
         get {
              return builderResult.hasSuccess
         }
    }
    public var success:Bool {
         get {
              return builderResult.success
         }
         set (value) {
             builderResult.hasSuccess = true
             builderResult.success = value
         }
    }
    public func setSuccess(value:Bool)-> Soa.ActionResultV1Builder {
      self.success = value
      return self
    }
    public func clearSuccess() -> Soa.ActionResultV1Builder{
         builderResult.hasSuccess = false
         builderResult.success = false
         return self
    }
    public var errors:Array<String> {
         get {
             return builderResult.errors
         }
         set (array) {
             builderResult.errors = array
         }
    }
    public func setErrors(value:Array<String>)-> Soa.ActionResultV1Builder {
      self.errors = value
      return self
    }
    public func clearErrors() -> Soa.ActionResultV1Builder {
       builderResult.errors.removeAll(keepCapacity: false)
       return self
    }
    public var errorDetails:Array<Soa.ActionResultV1.ErrorDetailV1> {
         get {
             return builderResult.errorDetails
         }
         set (value) {
             builderResult.errorDetails = value
         }
    }
    public func setErrorDetails(value:Array<Soa.ActionResultV1.ErrorDetailV1>)-> Soa.ActionResultV1Builder {
      self.errorDetails = value
      return self
    }
    public func clearErrorDetails() -> Soa.ActionResultV1Builder {
      builderResult.errorDetails.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:ExtendableMessage {
         get {
             return builderResult
         }
    }
    public override func clear() -> Soa.ActionResultV1Builder {
      builderResult = Soa.ActionResultV1()
      return self
    }
    public override func clone() -> Soa.ActionResultV1Builder {
      return Soa.ActionResultV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Soa.ActionResultV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Soa.ActionResultV1 {
      var returnMe:Soa.ActionResultV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Soa.ActionResultV1) -> Soa.ActionResultV1Builder {
      if (other == Soa.ActionResultV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      if other.hasSuccess {
           success = other.success
      }
      if !other.errors.isEmpty {
          builderResult.errors += other.errors
      }
      if !other.errorDetails.isEmpty  {
         builderResult.errorDetails += other.errorDetails
      }
      mergeExtensionFields(other)
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Soa.ActionResultV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ActionResultV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        case 16 :
          success = input.readBool()

        case 26 :
          errors += [input.readString()]

        case 34 :
          var subBuilder = Soa.ActionResultV1.ErrorDetailV1.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          errorDetails += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class ActionResponseV1 : GeneratedMessage, GeneratedMessageProtocol {
    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           case "control": return control
           case "result": return result
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasControl:Bool = false
    public private(set) var control:Soa.ActionControlV1!
    public private(set) var hasResult:Bool = false
    public private(set) var result:Soa.ActionResultV1!
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      if hasResult {
       if !result.isInitialized() {
         return false
       }
      }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      if hasControl {
        output.writeMessage(2, value:control)
      }
      if hasResult {
        output.writeMessage(3, value:result)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasControl {
          if let varSizecontrol = control?.computeMessageSize(2) {
              serialize_size += varSizecontrol
          }
      }
      if hasResult {
          if let varSizeresult = result?.computeMessageSize(3) {
              serialize_size += varSizeresult
          }
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Soa.ActionResponseV1 {
      return Soa.ActionResponseV1.builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Soa.ActionResponseV1 {
      return Soa.ActionResponseV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Soa.ActionResponseV1 {
      return Soa.ActionResponseV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Soa.ActionResponseV1 {
      return Soa.ActionResponseV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Soa.ActionResponseV1 {
      return Soa.ActionResponseV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ActionResponseV1 {
      return Soa.ActionResponseV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Soa.ActionResponseV1Builder {
      return Soa.ActionResponseV1.classBuilder() as! Soa.ActionResponseV1Builder
    }
    public func builder() -> Soa.ActionResponseV1Builder {
      return classBuilder() as! Soa.ActionResponseV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ActionResponseV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ActionResponseV1.builder()
    }
    public func toBuilder() -> Soa.ActionResponseV1Builder {
      return Soa.ActionResponseV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ActionResponseV1) -> Soa.ActionResponseV1Builder {
      return Soa.ActionResponseV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasControl {
        output += "\(indent) control {\n"
        control?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      if hasResult {
        output += "\(indent) result {\n"
        result?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasControl {
                if let hashValuecontrol = control?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecontrol
                }
            }
            if hasResult {
                if let hashValueresult = result?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueresult
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ActionResponseV1"
    }
    override public func className() -> String {
        return "Soa.ActionResponseV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ActionResponseV1.self
    }
    //Meta information declaration end

  }

  final public class ActionResponseV1Builder : GeneratedMessageBuilder {
    private var builderResult:Soa.ActionResponseV1

    required override public init () {
       builderResult = Soa.ActionResponseV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Soa.ActionResponseV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Soa.ActionResponseV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    public var hasControl:Bool {
         get {
             return builderResult.hasControl
         }
    }
    public var control:Soa.ActionControlV1! {
         get {
             return builderResult.control
         }
         set (value) {
             builderResult.hasControl = true
             builderResult.control = value
         }
    }
    public func setControl(value:Soa.ActionControlV1!)-> Soa.ActionResponseV1Builder {
      self.control = value
      return self
    }
    public func mergeControl(value:Soa.ActionControlV1) -> Soa.ActionResponseV1Builder {
      if (builderResult.hasControl) {
        builderResult.control = Soa.ActionControlV1.builderWithPrototype(builderResult.control).mergeFrom(value).buildPartial()
      } else {
        builderResult.control = value
      }
      builderResult.hasControl = true
      return self
    }
    public func clearControl() -> Soa.ActionResponseV1Builder {
      builderResult.hasControl = false
      builderResult.control = nil
      return self
    }
    public var hasResult:Bool {
         get {
             return builderResult.hasResult
         }
    }
    public var result:Soa.ActionResultV1! {
         get {
             return builderResult.result
         }
         set (value) {
             builderResult.hasResult = true
             builderResult.result = value
         }
    }
    public func setResult(value:Soa.ActionResultV1!)-> Soa.ActionResponseV1Builder {
      self.result = value
      return self
    }
    public func mergeResult(value:Soa.ActionResultV1) -> Soa.ActionResponseV1Builder {
      if (builderResult.hasResult) {
        builderResult.result = Soa.ActionResultV1.builderWithPrototype(builderResult.result).mergeFrom(value).buildPartial()
      } else {
        builderResult.result = value
      }
      builderResult.hasResult = true
      return self
    }
    public func clearResult() -> Soa.ActionResponseV1Builder {
      builderResult.hasResult = false
      builderResult.result = nil
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Soa.ActionResponseV1Builder {
      builderResult = Soa.ActionResponseV1()
      return self
    }
    public override func clone() -> Soa.ActionResponseV1Builder {
      return Soa.ActionResponseV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Soa.ActionResponseV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Soa.ActionResponseV1 {
      var returnMe:Soa.ActionResponseV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Soa.ActionResponseV1) -> Soa.ActionResponseV1Builder {
      if (other == Soa.ActionResponseV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      if (other.hasControl) {
          mergeControl(other.control)
      }
      if (other.hasResult) {
          mergeResult(other.result)
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Soa.ActionResponseV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ActionResponseV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        case 18 :
          var subBuilder:Soa.ActionControlV1Builder = Soa.ActionControlV1.builder()
          if hasControl {
            subBuilder.mergeFrom(control)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          control = subBuilder.buildPartial()

        case 26 :
          var subBuilder:Soa.ActionResultV1Builder = Soa.ActionResultV1.builder()
          if hasResult {
            subBuilder.mergeFrom(result)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          result = subBuilder.buildPartial()

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class ServiceRequestV1 : GeneratedMessage, GeneratedMessageProtocol {
    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           case "control": return control
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasControl:Bool = false
    public private(set) var control:Soa.ControlV1!
    public private(set) var actions:Array<Soa.ActionRequestV1>  = Array<Soa.ActionRequestV1>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitactions:Bool = true
      for oneElementactions in actions {
          if (!oneElementactions.isInitialized()) {
              isInitactions = false
              break 
          }
      }
      if !isInitactions {
       return isInitactions
       }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      if hasControl {
        output.writeMessage(2, value:control)
      }
      for oneElementactions in actions {
          output.writeMessage(3, value:oneElementactions)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasControl {
          if let varSizecontrol = control?.computeMessageSize(2) {
              serialize_size += varSizecontrol
          }
      }
      for oneElementactions in actions {
          serialize_size += oneElementactions.computeMessageSize(3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Soa.ServiceRequestV1 {
      return Soa.ServiceRequestV1.builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Soa.ServiceRequestV1 {
      return Soa.ServiceRequestV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Soa.ServiceRequestV1 {
      return Soa.ServiceRequestV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Soa.ServiceRequestV1 {
      return Soa.ServiceRequestV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Soa.ServiceRequestV1 {
      return Soa.ServiceRequestV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ServiceRequestV1 {
      return Soa.ServiceRequestV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Soa.ServiceRequestV1Builder {
      return Soa.ServiceRequestV1.classBuilder() as! Soa.ServiceRequestV1Builder
    }
    public func builder() -> Soa.ServiceRequestV1Builder {
      return classBuilder() as! Soa.ServiceRequestV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ServiceRequestV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ServiceRequestV1.builder()
    }
    public func toBuilder() -> Soa.ServiceRequestV1Builder {
      return Soa.ServiceRequestV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ServiceRequestV1) -> Soa.ServiceRequestV1Builder {
      return Soa.ServiceRequestV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasControl {
        output += "\(indent) control {\n"
        control?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      var actionsElementIndex:Int = 0
      for oneElementactions in actions {
          output += "\(indent) actions[\(actionsElementIndex)] {\n"
          oneElementactions.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          actionsElementIndex++
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasControl {
                if let hashValuecontrol = control?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecontrol
                }
            }
            for oneElementactions in actions {
                hashCode = (hashCode &* 31) &+ oneElementactions.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ServiceRequestV1"
    }
    override public func className() -> String {
        return "Soa.ServiceRequestV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ServiceRequestV1.self
    }
    //Meta information declaration end

  }

  final public class ServiceRequestV1Builder : GeneratedMessageBuilder {
    private var builderResult:Soa.ServiceRequestV1

    required override public init () {
       builderResult = Soa.ServiceRequestV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Soa.ServiceRequestV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Soa.ServiceRequestV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    public var hasControl:Bool {
         get {
             return builderResult.hasControl
         }
    }
    public var control:Soa.ControlV1! {
         get {
             return builderResult.control
         }
         set (value) {
             builderResult.hasControl = true
             builderResult.control = value
         }
    }
    public func setControl(value:Soa.ControlV1!)-> Soa.ServiceRequestV1Builder {
      self.control = value
      return self
    }
    public func mergeControl(value:Soa.ControlV1) -> Soa.ServiceRequestV1Builder {
      if (builderResult.hasControl) {
        builderResult.control = Soa.ControlV1.builderWithPrototype(builderResult.control).mergeFrom(value).buildPartial()
      } else {
        builderResult.control = value
      }
      builderResult.hasControl = true
      return self
    }
    public func clearControl() -> Soa.ServiceRequestV1Builder {
      builderResult.hasControl = false
      builderResult.control = nil
      return self
    }
    public var actions:Array<Soa.ActionRequestV1> {
         get {
             return builderResult.actions
         }
         set (value) {
             builderResult.actions = value
         }
    }
    public func setActions(value:Array<Soa.ActionRequestV1>)-> Soa.ServiceRequestV1Builder {
      self.actions = value
      return self
    }
    public func clearActions() -> Soa.ServiceRequestV1Builder {
      builderResult.actions.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Soa.ServiceRequestV1Builder {
      builderResult = Soa.ServiceRequestV1()
      return self
    }
    public override func clone() -> Soa.ServiceRequestV1Builder {
      return Soa.ServiceRequestV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Soa.ServiceRequestV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Soa.ServiceRequestV1 {
      var returnMe:Soa.ServiceRequestV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Soa.ServiceRequestV1) -> Soa.ServiceRequestV1Builder {
      if (other == Soa.ServiceRequestV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      if (other.hasControl) {
          mergeControl(other.control)
      }
      if !other.actions.isEmpty  {
         builderResult.actions += other.actions
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Soa.ServiceRequestV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ServiceRequestV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        case 18 :
          var subBuilder:Soa.ControlV1Builder = Soa.ControlV1.builder()
          if hasControl {
            subBuilder.mergeFrom(control)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          control = subBuilder.buildPartial()

        case 26 :
          var subBuilder = Soa.ActionRequestV1.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          actions += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

  final public class ServiceResponseV1 : GeneratedMessage, GeneratedMessageProtocol {
    public subscript(key: String) -> Any? {
           switch key {
           case "version": return version
           case "control": return control
           default: return nil
           }
    }

    public private(set) var hasVersion:Bool = false
    public private(set) var version:UInt32 = UInt32(1)

    public private(set) var hasControl:Bool = false
    public private(set) var control:Soa.ControlV1!
    public private(set) var actions:Array<Soa.ActionResponseV1>  = Array<Soa.ActionResponseV1>()
    required public init() {
         super.init()
    }
    override public func isInitialized() -> Bool {
      var isInitactions:Bool = true
      for oneElementactions in actions {
          if (!oneElementactions.isInitialized()) {
              isInitactions = false
              break 
          }
      }
      if !isInitactions {
       return isInitactions
       }
     return true
    }
    override public func writeToCodedOutputStream(output:CodedOutputStream) {
      if hasVersion {
        output.writeUInt32(1, value:version)
      }
      if hasControl {
        output.writeMessage(2, value:control)
      }
      for oneElementactions in actions {
          output.writeMessage(3, value:oneElementactions)
      }
      unknownFields.writeToCodedOutputStream(output)
    }
    override public func serializedSize() -> Int32 {
      var serialize_size:Int32 = memoizedSerializedSize
      if serialize_size != -1 {
       return serialize_size
      }

      serialize_size = 0
      if hasVersion {
        serialize_size += version.computeUInt32Size(1)
      }
      if hasControl {
          if let varSizecontrol = control?.computeMessageSize(2) {
              serialize_size += varSizecontrol
          }
      }
      for oneElementactions in actions {
          serialize_size += oneElementactions.computeMessageSize(3)
      }
      serialize_size += unknownFields.serializedSize()
      memoizedSerializedSize = serialize_size
      return serialize_size
    }
    public class func parseFromData(data:NSData) -> Soa.ServiceResponseV1 {
      return Soa.ServiceResponseV1.builder().mergeFromData(data, extensionRegistry:Soa.SoaRoot.sharedInstance.extensionRegistry).build()
    }
    public class func parseFromData(data:NSData, extensionRegistry:ExtensionRegistry) -> Soa.ServiceResponseV1 {
      return Soa.ServiceResponseV1.builder().mergeFromData(data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromInputStream(input:NSInputStream) -> Soa.ServiceResponseV1 {
      return Soa.ServiceResponseV1.builder().mergeFromInputStream(input).build()
    }
    public class func parseFromInputStream(input:NSInputStream, extensionRegistry:ExtensionRegistry) ->Soa.ServiceResponseV1 {
      return Soa.ServiceResponseV1.builder().mergeFromInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream) -> Soa.ServiceResponseV1 {
      return Soa.ServiceResponseV1.builder().mergeFromCodedInputStream(input).build()
    }
    public class func parseFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ServiceResponseV1 {
      return Soa.ServiceResponseV1.builder().mergeFromCodedInputStream(input, extensionRegistry:extensionRegistry).build()
    }
    public class func builder() -> Soa.ServiceResponseV1Builder {
      return Soa.ServiceResponseV1.classBuilder() as! Soa.ServiceResponseV1Builder
    }
    public func builder() -> Soa.ServiceResponseV1Builder {
      return classBuilder() as! Soa.ServiceResponseV1Builder
    }
    public override class func classBuilder() -> MessageBuilder {
      return Soa.ServiceResponseV1Builder()
    }
    public override func classBuilder() -> MessageBuilder {
      return Soa.ServiceResponseV1.builder()
    }
    public func toBuilder() -> Soa.ServiceResponseV1Builder {
      return Soa.ServiceResponseV1.builderWithPrototype(self)
    }
    public class func builderWithPrototype(prototype:Soa.ServiceResponseV1) -> Soa.ServiceResponseV1Builder {
      return Soa.ServiceResponseV1.builder().mergeFrom(prototype)
    }
    override public func writeDescriptionTo(inout output:String, indent:String) {
      if hasVersion {
        output += "\(indent) version: \(version) \n"
      }
      if hasControl {
        output += "\(indent) control {\n"
        control?.writeDescriptionTo(&output, indent:"\(indent)  ")
        output += "\(indent) }\n"
      }
      var actionsElementIndex:Int = 0
      for oneElementactions in actions {
          output += "\(indent) actions[\(actionsElementIndex)] {\n"
          oneElementactions.writeDescriptionTo(&output, indent:"\(indent)  ")
          output += "\(indent)}\n"
          actionsElementIndex++
      }
      unknownFields.writeDescriptionTo(&output, indent:indent)
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
               hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasControl {
                if let hashValuecontrol = control?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecontrol
                }
            }
            for oneElementactions in actions {
                hashCode = (hashCode &* 31) &+ oneElementactions.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Soa.ServiceResponseV1"
    }
    override public func className() -> String {
        return "Soa.ServiceResponseV1"
    }
    override public func classMetaType() -> GeneratedMessage.Type {
        return Soa.ServiceResponseV1.self
    }
    //Meta information declaration end

  }

  final public class ServiceResponseV1Builder : GeneratedMessageBuilder {
    private var builderResult:Soa.ServiceResponseV1

    required override public init () {
       builderResult = Soa.ServiceResponseV1()
       super.init()
    }
    public var hasVersion:Bool {
         get {
              return builderResult.hasVersion
         }
    }
    public var version:UInt32 {
         get {
              return builderResult.version
         }
         set (value) {
             builderResult.hasVersion = true
             builderResult.version = value
         }
    }
    public func setVersion(value:UInt32)-> Soa.ServiceResponseV1Builder {
      self.version = value
      return self
    }
    public func clearVersion() -> Soa.ServiceResponseV1Builder{
         builderResult.hasVersion = false
         builderResult.version = UInt32(1)
         return self
    }
    public var hasControl:Bool {
         get {
             return builderResult.hasControl
         }
    }
    public var control:Soa.ControlV1! {
         get {
             return builderResult.control
         }
         set (value) {
             builderResult.hasControl = true
             builderResult.control = value
         }
    }
    public func setControl(value:Soa.ControlV1!)-> Soa.ServiceResponseV1Builder {
      self.control = value
      return self
    }
    public func mergeControl(value:Soa.ControlV1) -> Soa.ServiceResponseV1Builder {
      if (builderResult.hasControl) {
        builderResult.control = Soa.ControlV1.builderWithPrototype(builderResult.control).mergeFrom(value).buildPartial()
      } else {
        builderResult.control = value
      }
      builderResult.hasControl = true
      return self
    }
    public func clearControl() -> Soa.ServiceResponseV1Builder {
      builderResult.hasControl = false
      builderResult.control = nil
      return self
    }
    public var actions:Array<Soa.ActionResponseV1> {
         get {
             return builderResult.actions
         }
         set (value) {
             builderResult.actions = value
         }
    }
    public func setActions(value:Array<Soa.ActionResponseV1>)-> Soa.ServiceResponseV1Builder {
      self.actions = value
      return self
    }
    public func clearActions() -> Soa.ServiceResponseV1Builder {
      builderResult.actions.removeAll(keepCapacity: false)
      return self
    }
    override public var internalGetResult:GeneratedMessage {
         get {
            return builderResult
         }
    }
    public override func clear() -> Soa.ServiceResponseV1Builder {
      builderResult = Soa.ServiceResponseV1()
      return self
    }
    public override func clone() -> Soa.ServiceResponseV1Builder {
      return Soa.ServiceResponseV1.builderWithPrototype(builderResult)
    }
    public override func build() -> Soa.ServiceResponseV1 {
         checkInitialized()
         return buildPartial()
    }
    public func buildPartial() -> Soa.ServiceResponseV1 {
      var returnMe:Soa.ServiceResponseV1 = builderResult
      return returnMe
    }
    public func mergeFrom(other:Soa.ServiceResponseV1) -> Soa.ServiceResponseV1Builder {
      if (other == Soa.ServiceResponseV1()) {
       return self
      }
      if other.hasVersion {
           version = other.version
      }
      if (other.hasControl) {
          mergeControl(other.control)
      }
      if !other.actions.isEmpty  {
         builderResult.actions += other.actions
      }
      mergeUnknownFields(other.unknownFields)
      return self
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream) ->Soa.ServiceResponseV1Builder {
         return mergeFromCodedInputStream(input, extensionRegistry:ExtensionRegistry())
    }
    public override func mergeFromCodedInputStream(input:CodedInputStream, extensionRegistry:ExtensionRegistry) -> Soa.ServiceResponseV1Builder {
      var unknownFieldsBuilder:UnknownFieldSetBuilder = UnknownFieldSet.builderWithUnknownFields(self.unknownFields)
      while (true) {
        var tag = input.readTag()
        switch tag {
        case 0: 
          self.unknownFields = unknownFieldsBuilder.build()
          return self

        case 8 :
          version = input.readUInt32()

        case 18 :
          var subBuilder:Soa.ControlV1Builder = Soa.ControlV1.builder()
          if hasControl {
            subBuilder.mergeFrom(control)
          }
          input.readMessage(subBuilder, extensionRegistry:extensionRegistry)
          control = subBuilder.buildPartial()

        case 26 :
          var subBuilder = Soa.ActionResponseV1.builder()
          input.readMessage(subBuilder,extensionRegistry:extensionRegistry)
          actions += [subBuilder.buildPartial()]

        default:
          if (!parseUnknownField(input,unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:tag)) {
             unknownFields = unknownFieldsBuilder.build()
             return self
          }
        }
      }
    }
  }

}

// @@protoc_insertion_point(global_scope)
